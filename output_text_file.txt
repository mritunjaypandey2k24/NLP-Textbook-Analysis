A K
PETERS Computer Algebra and Symbolic ComputationCohenElementary AlgorithmsComputer Algebra and
Symbolic Computation
Elementary AlgorithmsJOEL S. COHEN

/G67/G111/G109/G112/G117/G116/G101/G114/G32/G65/G108/G103/G101/G98/G114/G97/G32/G97/G110/G100/G32/G83/G121/G109/G98/G111/G108/G105/G99/G32/G67/G111/G109/G112/G117/G116/G97/G116/G105/G111/G110

/G67/G111/G109/G112/G117/G116/G101/G114/G32/G65/G108/G103/G101/G98/G114/G97/G32/G97/G110/G100/G32/G83/G121/G109/G98/G111/G108/G105/G99/G32/G67/G111/G109/G112/G117/G116/G97/G116/G105/G111/G110
/G69/G108/G101/G109/G101/G110/G116/G97/G114/G121/G32/G65/G108/G103/G111/G114/G105/G116/G104/G109/G115
/G74/G111/G101/G108/G32/G83/G46/G32/G67/G111/G104/G101/G110
/G68/G101/G112/G97/G114/G116/G109/G101/G110/G116/G32/G111/G102/G32/G67/G111/G109/G112/G117/G116/G101/G114/G32/G83/G99/G105/G101/G110/G99/G101
/G85/G110/G105/G118/G101/G114/G115/G105/G116/G121/G32/G111/G102/G32/G68/G101/G110/G118/G101/G114
/G65/G32/G75/G32/G80/G101/G116/G101/G114/G115
/G78/G97/G116/G105/G99/G107/G44/G32/G77/G97/G115/G115/G97/G99/G104/G117/G115/G101/G116/G116/G115
/G80/G114/G105/G110/G116/G101/G100/G32/G105/G110/G32/G67/G97/G110/G97/G100/G97
/G48/G54/G32/G32/G48/G53/G32/G32/G48/G52/G32/G32/G48/G51/G32/G32/G48/G50/G32/G32/G32/G32/G32/G32/G32/G49/G48/G32/G32/G57/G32/G32/G56/G32/G32/G55/G32/G32/G54/G32/G32/G53/G32/G32/G52/G32/G32/G51/G32/G32/G50/G32/G32/G49/G76/G105/G98/G114/G97/G114/G121/G32/G111/G102/G32/G67/G111/G110/G103/G114/G101/G115/G115/G32/G67/G97/G116/G97/G108/G111/G103/G105/G110/G103/G45/G105/G110/G45/G80/G117/G98/G108/G105/G99/G97/G116/G105/G111/G110/G32/G68/G97/G116/G97
/G67/G111/G104/G101/G110/G44/G32/G74/G111/G101/G108/G32/G83/G46/G32/G32/G32/G32/G32/G67/G111/G109/G112/G117/G116/G101/G114/G32/G97/G108/G103/G101/G98/G114/G97/G32/G97/G110/G100/G32/G115/G121/G109/G98/G111/G108/G105/G99/G32/G99/G111/G109/G112/G117/G116/G97/G116/G105/G111/G110/G32/G58/G32/G101/G108/G101/G109/G101/G110/G116/G97/G114/G121
/G97/G108/G103/G111/G114/G105/G116/G104/G109/G115/G32/G47/G32/G74/G111/G101/G108/G32/G83/G46/G32/G67/G111/G104/G101/G110/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G112/G46/G32/G99/G109/G46/G32/G32/G32/G32/G32/G32/G73/G110/G99/G108/G117/G100/G101/G115/G32/G98/G105/G98/G108/G105/G111/G103/G114/G97/G112/G104/G105/G99/G97/G108/G32/G114/G101/G102/G101/G114/G101/G110/G99/G101/G115/G32/G97/G110/G100/G32/G105/G110/G100/G101/G120/G46/G32/G32/G32/G32/G32/G73/G83/G66/G78/G32/G49/G45/G53/G54/G56/G56/G49/G45/G49/G53/G56/G45/G54/G32/G32/G32/G32/G32/G32/G49/G46/G32/G65/G108/G103/G101/G98/G114/G97/G150/G68/G97/G116/G97/G32/G112/G114/G111/G99/G101/G115/G115/G105/G110/G103/G46/G32/G73/G46/G32/G84/G105/G116/G108/G101/G46
/G81/G65/G49/G53/G53/G46/G55/G46/G69/G52/G32/G46/G67/G54/G51/G53/G32/G50/G48/G48/G50
/G53/G49/G50/G150/G100/G99/G50/G49/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G32/G50/G48/G48/G49/G48/G53/G53/G49/G53/G57/G69/G100/G105/G116/G111/G114/G105/G97/G108/G44/G32/G83/G97/G108/G101/G115/G44/G32/G97/G110/G100/G32/G67/G117/G115/G116/G111/G109/G101/G114/G32/G83/G101/G114/G118/G105/G99/G101/G32/G79/G102 /G102/G105/G99/G101
/G65/G32/G75/G32/G80/G101/G116/G101/G114/G115/G44/G32/G76/G116/G100/G46/G54/G51/G32/G83/G111/G117/G116/G104/G32/G65/G118/G101/G110/G117/G101/G78/G97/G116/G105/G99/G107/G44/G32/G77/G65/G32/G32/G48/G49/G55/G54/G48/G119/G119/G119/G46/G97/G107/G112/G101/G116/G101/G114/G115/G46/G99/G111/G109
/G67/G111/G112/G121/G114/G105/G103/G104/G116/G32/G32/G169/G32/G32/G50/G48/G48/G50/G32/G98/G121/G32/G65/G32/G75/G32/G80/G101/G116/G101/G114/G115/G44/G32/G76/G116/G100/G46/G65/G108/G108/G32/G114/G105/G103/G104/G116/G115/G32/G114/G101/G115/G101/G114/G118/G101/G100/G46/G32/G78/G111/G32/G112/G97/G114/G116/G32/G111/G102/G32/G116/G104/G101/G32/G109/G97/G116/G101/G114/G105/G97/G108/G32/G112/G114/G111/G116/G101/G99/G116/G101/G100/G32/G98/G121/G32/G116/G104/G105/G115/G32/G99/G111/G112/G121/G114/G105/G103/G104/G116/G32/G110/G111/G116/G105/G99/G101
/G109/G97/G121/G32/G98/G101/G32/G114/G101/G112/G114/G111/G100/G117/G99/G101/G100/G32/G111/G114/G32/G117/G116/G105/G108/G105/G122/G101/G100/G32/G105/G110/G32/G97/G110/G121/G32/G102/G111/G114/G109/G44/G32/G101/G108/G101/G99/G116/G114/G111/G110/G105/G99/G32/G111/G114/G32/G109/G101/G99/G104/G97/G110/G105/G99/G97/G108/G44/G32/G105/G110/G99/G108/G117/G100/G105/G110/G103/G112/G104/G111/G116/G111/G99/G111/G112/G121/G105/G110/G103/G44/G32/G114/G101/G99/G111/G114/G100/G105/G110/G103/G44/G32/G111/G114/G32/G98/G121/G32/G97/G110/G121/G32/G105/G110/G102/G111/G114/G109/G97/G116/G105/G111/G110/G32/G115/G116/G111/G114/G97/G103/G101/G32/G97/G110/G100/G32/G114/G101/G116/G114/G105/G101/G118/G97/G108/G32/G115/G121/G115/G116/G101/G109/G44/G119/G105/G116/G104/G111/G117/G116/G32/G119/G114/G105/G116/G116/G101/G110/G32/G112/G101/G114/G109/G105/G115/G115/G105/G111/G110/G32/G102/G114/G111/G109/G32/G116/G104/G101/G32/G99/G111/G112/G121/G114/G105/G103/G104/G116/G32/G111/G119/G110/G101/G114/G46
/G84/G111/G32/G109/G121/G32/G119/G105/G102/G101/G32/G75/G97/G116/G104/G114/G121/G110

Contents
Preface ix
1 Introduction to Computer Algebra 1
1.1 Computer Algebra and Computer Algebra Systems . . . . . 1
1 . 2 A p p l i c a t i o n so fC o m p u t e rA l g e b r a .............. 10
2 Elementary Concepts of Computer Algebra 29
2.1 Mathematical Pseudo-language (MPL). . . . . . . . . . . 29
2 . 2 E x p r e s s i o nE v a l u a t i o n..................... 49
2 . 3 M a t h e m a t i c a lP r o g r a m s.................... 58
2 . 4 S e t sa n dL i s t s ......................... 68
3 Recursive Structure of Mathematical Expressions 77
3.1 Recursive Deﬁnitions and Algorithms . . . . . . . . . . . . . 77
3 . 2 E x p r e s s i o nS t r u c t u r ea n dT r e e s................ 84
3 . 3 S t r u c t u r e - B a s e dO p e r a t o r s .................. 108
4 Elementary Mathematical Algorithms 119
4.1 Mathematical Algorithms . . . . . . . . . . . . . . . . . . . 119
4 . 2 M P L ’ sA l g o r i t h m i cL a n g u a g e................. 132
4.3 Case Study: First Order Ordinary Diﬀerential Equations . . 156
5 Recursive Algorithms 171
5 . 1 AC o m p u t a t i o n a lV i e wo fR e c u r s i o n ............. 171
5 . 2 R e c u r s i v eP r o c e d u r e s ..................... 176
5.3 Case Study: Elementary Integration Operator . . . . . . . . 199
vii
viii Contents
6 Structure of Polynomials and Rational Expressions 213
6.1 Single Variable Polynomials . . . . . . . . . . . . . . . . . . 214
6 . 2 G e n e r a lP o l y n o m i a lE x p r e s s i o n s ............... 223
6.3 Relationships Between Generalized Variables . . . . . . . . 242
6.4 Manipulation of General Polynomial Expressions . . . . . . 247
6.5 General Rational Expressions . . . . . . . . . . . . . . . . . 259
7 Exponential and Trigonometric Transformations 275
7.1 Exponential and Trigonometric Expansion . . . . . . . . . . 275
7.2 Exponential and Trigonometric Contraction . . . . . . . . . 289
Bibliography 307
Index 316
Preface
Computer algebra is the ﬁeld of mathematics and computer science that is
concerned with the development, implementation, and application of algo-
rithms that manipulate and analyze mathematical expressions. This bookand the companion text, Computer Algebra and Symbolic Computation:
Mathematical Methods , are an introduction to the subject that addresses
both its practical and theoretical aspects. This book, which addressesthe practical side, is concerned with the formulation of algorithms that
solve symbolic mathematical problems, and with the implementation of
these algorithms in terms of the operations and control structures avail-
able in computer algebra programming languages. Mathematical Methods ,
which addresses more theoretical issues, is concerned with the basic math-ematical and algorithmic concepts that are the foundation of the subject.
Both books serve as a bridge between texts and manuals that show how
to use computer algebra software and graduate level texts that describealgorithms at the forefront of the ﬁeld.
These books have been in various stages of development for over 15
years. They are based on the class notes for a two-quarter course sequence
in computer algebra that has been oﬀered at the University of Denver every
other year for the past 16 years. The ﬁrst course, which is the basis for El-
ementary Algorithms , attracts primarily undergraduate students and a few
graduate students from mathematics, computer science, and engineering.
The second course, which is the basis for Mathematical Methods , attracts
primarily graduate students in both mathematics and computer science.
The course is cross-listed under both mathematics and computer science.
ix
x Preface
Prerequisites
The target audience for these books includes students and professionals
from mathematics, computer science, and other technical ﬁelds who would
like to know about computer algebra and its applications.
In the spirit of an introductory text, we have tried to minimize the
prerequisites. The mathematical prerequisites include the usual two yearfreshman–sophomore sequence of courses (calculus through multivariable
calculus, elementary linear algebra, and applied ordinary diﬀerential equa-
tions). In addition, an introductory course in discrete mathematics is rec-ommended because mathematical induction is used as a proof technique
throughout. Topics from elementary number theory and abstract algebra
are introduced as needed.
On the computer science side, we assume that the reader has had some
experience with a computer programming language such as Fortran, Pascal,C, C++, or Java. Although these languages are not used in these books,
the skills in problem solving and algorithm development obtained in a be-
ginning programming course are essential. One programming techniquethat is especially important in computer algebra is recursion. Although
many students will have seen recursion in a conventional programming
course, the topic is described in Chapter 5 of Elementary Algorithms from
a computer algebra perspective.
Realistically speaking, while these prerequisites suﬃce in a formal sense
for both books, in a practical sense there are some sections as the texts
progress where greater mathematical and computational sophistication is
required. Although the mathematical development in these sections can bechallenging for students with the minimum prerequisites, the algorithms
are accessible, and these sections provide a transition to more advanced
treatments of the subject.
Organization and Content
Broadly speaking, these books are intended to serve two (complementary)
purposes:
To provide a systematic approach to the algorithmic formulation and
implementation of mathematical operations in a computer algebra
programming language.
Algorithmic methods in traditional mathematics are usually not pre-
sented with the precision found in numerical mathematics or conventional
computer programming. For example, the algorithm for the expansion of
products and powers of polynomials is usually given informally instead of
with (recursive)procedures that can be expressed as a computer program.
Preface xi
The material in Elementary Algorithms is concerned with the algorith-
mic formulation of solutions to elementary symbolic mathematical prob-
lems. The viewpoint is that mathematical expressions, represented as ex-
pression trees, are the data objects of computer algebra programs, and byusing a few primitive operations that analyze and construct expressions,
we can implement many elementary operations from algebra, trigonometry,
calculus, and diﬀerential equations. For example, algorithms are given forthe analysis and manipulation of polynomials and rational expressions, the
manipulation of exponential and trigonometric functions, diﬀerentiation,
elementary integration, and the solution of ﬁrst order diﬀerential equa-
tions. Most of the material in this book is not found in either mathematics
textbooks or in other, more advanced computer algebra textbooks.
To describe some of the mathematical concepts and algorithmic tech-
niques utilized by modern computer algebra software.
For the past 35 years, the research in computer algebra has been con-
cerned with the development of eﬀective and eﬃcient algorithms for many
mathematical operations including polynomial greatest common divisor
(gcd)computation, polynomial factorization, polynomial decomposition,
the solution of systems of linear equations and multivariate polynomial
equations, indeﬁnite integration, and the solution of diﬀerential equations.Although algorithms for some of these problems have been known since the
nineteenth century, for eﬃciency reasons they are not suitable as general
purpose algorithms for computer algebra software. The classical algorithmsare important, however, because they are much simpler and provide a con-
text to motivate the basic algebraic ideas and the need for more eﬃcient
approaches.
The material in Mathematical Methods is an introduction to the math-
ematical techniques and algorithmic methods of computer algebra. Al-
though the material in this book is more diﬃcult and requires greater math-
ematical sophistication, the approach and selection of topics is designed so
that it is accessible and interesting to the intended audience. Algorithms
are given for basic integer and rational number operations, automatic (ordefault)simpliﬁcation of algebraic expressions, greatest common divisor
calculation for single and multivariate polynomials, resultant computation,
polynomial decomposition, polynomial simpliﬁcation with Gr¨ obner bases,
and polynomial factorization.
xii Preface
Topic Selection
The author of an introductory text about a rapidly changing ﬁeld is faced
with a diﬃcult decision about which topics and algorithms to include in
the work. This decision is constrained by the background of the audience,
the mathematical diﬃculty of the material and, of course, by space limita-tions. In addition, we believe that an introductory text should really be an
introduction to the subject that describes some of the important issues in
the ﬁeld but should not try to be comprehensive or include all reﬁnementsof a particular topic or algorithm. This viewpoint has guided the selection
of topics, choice of algorithms, and level of mathematical rigor.
For example, polynomial gcd computation is an important topic in
Mathematical Methods that plays an essential role in modern computer
algebra software. We describe classical Euclidean algorithms for both sin-
gle and multivariate polynomials with rational number coeﬃcients and a
Euclidean algorithm for single variable polynomials with simple algebraic
number coeﬃcients. It is well known, however, that for eﬃciency rea-sons, these algorithms are not suitable as general purpose algorithms in
a computer algebra system. For this reason, we describe the more ad-
vanced subresultant gcd algorithm for multivariate polynomials but omitthe mathematical justiﬁcation, which is quite involved and far outside the
scope and spirit of these books.
One topic that is not discussed is the asymptotic complexity of the time
and space requirements of algorithms. Complexity analysis for computer
algebra, which is often quite involved, uses techniques from algorithm anal-ysis, probability theory, discrete mathematics, the theory of computation,
and other areas that are well beyond the background of the intended audi-
ence. Of course, it is impossible to ignore eﬃciency considerations entirelyand, when appropriate, we indicate (usually by example)some of the issues
that arise. A course based on Mathematical Methods is an ideal prerequi-
site for a graduate level course that includes the complexity analysis ofalgorithms along with recent developments in the ﬁeld
1.
Chapter Summaries
A more detailed description of the material covered in these books is given
in the following chapter summaries.
1A graduate level course could be based on one of the following books: Akritas [ 2],
Geddes, Czapor, and Labahn [ 39], Mignotte [ 66], Mignotte and S ¸tef˘anescu [ 67], Mishra
[68] ,v o nz u rG a t h e na n dG e r h a r d[ 96], Winkler [ 101], Yap [ 105], or Zippel [ 108].
Preface xiii
Elementary Algorithms
Chapter 1: Introduction to Computer Algebra. This chapter is
an introduction to the ﬁeld of computer algebra. It illustrates both the
possibilities and limitations for computer symbolic computation through
dialogues with a number of commercial computer algebra systems.
Chapter 2: Elementary Concepts of Computer Algebra. This
chapter introduces an algorithmic language called mathematical pseudo-
language (or simply MPL)that is used throughout the books to describe the
concepts, examples, and algorithms of computer algebra. MPL is a simple
language that can be easily translated into the structures and operationsavailable in modern computer algebra languages. This chapter also includes
a general description of the evaluation process in computer algebra software
(including automatic simpliﬁcation), and a case study which includes anMPL program that obtains the change of form of quadratic expressions
under rotation of coordinates.
Chapter 3: Recursive Structure of Mathematical Expressions.
This chapter is concerned with the internal tree structure of mathemati-
cal expressions. Both the conventional structure (before evaluation)and
the simpliﬁed structure (after evaluation and automatic simpliﬁcation)aredescribed. The structure of automatically simpliﬁed expressions is impor-
tant because all algorithms assume that the input data is in this form.
Four primitive MPL operators ( Kind,Operand ,Number
of
operands ,
andConstruct )that analyze and construct mathematical expressions are
introduced. The chapter also includes a description of four MPL opera-tors ( Free
of,Substitute ,Sequential
 substitute ,a n d Concurrent
 substitute )
which depend only on the tree structure of an expression.
Chapter 4: Elementary Mathematical Algorithms. In this chap-
ter we describe the basic programming structures in MPL and use these
structures to describe a number of elementary algorithms. The chapter
includes a case study which describes an algorithm that solves a class ofﬁrst order ordinary diﬀerential equations using the separation of variables
technique and the method of exact equations with integrating factors.
Chapter 5: Recursive Algorithms. This chapter describes recur-
sion as a programming technique in computer algebra and gives a number
of examples that illustrate its advantages and limitations. It includes a case
study that describes an elementary integration algorithm which ﬁnds theantiderivatives for a limited class of functions using the linear properties of
the integral and the substitution method. Extensions of the algorithm to
include the elementary rational function integration, some trigonometric
integrals, elementary integration by parts, and one algebraic function form
are described in the exercises.
xiv Preface
Chapter 6: Structure of Polynomials and Rational Expres-
sions. This chapter is concerned with the algorithms that analyze and ma-
nipulate polynomials and rational expressions. It includes computational
deﬁnitions for various classes of polynomials and rational expressions thatare based on the internal tree structure of expressions. Algorithms based
on the primitive operations introduced in Chapter 3 are given for degree
and coeﬃcient computation, coeﬃcient collection, expansion, and rational-ization of algebraic expressions.
Chapter 7: Exponential and Trigonometric Transformations.
This chapter is concerned with algorithms that manipulate exponential and
trigonometric functions. It includes algorithms for exponential expansionand reduction, trigonometric expansion and reduction, and a simpliﬁcation
algorithm that can verify a large class of trigonometric identities.
Mathematical Methods
Chapter 1: Background Concepts. This chapter is a summary
of the background material from Elementary Algorithms that provides a
frameworkfor the mathematical and computational discussions in the book.
It includes a description of the mathematical psuedo-language (MPL), a
brief discussion of the tree structure and polynomial structure of algebraic
expressions, and a summary of the basic mathematical operators that ap-pear in our algorithms.
Chapter 2: Integers, Rational Numbers, and Fields. This chap-
ter is concerned with the numerical objects that arise in computer algebra,
including integers, rational numbers, and algebraic numbers. It includesEuclid’s algorithm for the greatest common divisor of two integers, the
extended Euclidean algorithm, the Chinese remainder algorithm, and a
simpliﬁcation algorithm that transforms an involved arithmetic expressionwith integers and fractions to a rational number in standard form. In ad-
dition, it introduces the concept of a ﬁeld which describes in a general way
the properties of number systems that arise in computer algebra.
Chapter 3: Automatic Simpliﬁcation. Automatic simpliﬁcation
is deﬁned as the collection of algebraic and trigonometric simpliﬁcation
transformations that are applied to an expression as part of the evaluation
process. In this chapter we take an in-depth look at the algebraic compo-nent of this process, give a precise deﬁnition of an automatically simpliﬁed
expression, and describe an (involved)algorithm that transforms mathe-
matical expressions to automatically simpliﬁed form. Although automatic
simpliﬁcation is essential for the operation of computer algebra software,
this is the only detailed treatment of the topic in the textbook literature.
Preface xv
Chapter 4: Single Variable Polynomials. This chapter is con-
cerned with algorithms for single variable polynomials with coeﬃcients in
a ﬁeld. All algorithms in this chapter are ultimately based on polynomial
division. It includes algorithms for polynomial division and expansion, Eu-clid’s algorithm for greatest common divisor computation, the extended
Euclidean algorithm, and a polynomial version of the Chinese remainder
algorithm. In addition, the basic polynomial division and gcd algorithmsare used to give algorithms for numerical computations in elementary al-
gebraic number ﬁelds. These algorithms are then used to develop division
and gcd algorithms for polynomials with algebraic number coeﬃcients. The
chapter concludes with an algorithm for partial fraction expansion that is
based on the extended Euclidean algorithm.
Chapter 5: Polynomial Decomposition. Polynomial decomposi-
tion is a process that determines if a polynomial can be represented as a
composition of lower degree polynomials. In this chapter we discuss some
theoretical aspects of the decomposition problem and give an algorithmbased on polynomial factorization that either ﬁnds a decomposition or de-
termines that no decomposition exists.
Chapter 6: Multivariate Polynomials. This chapter generalizes
the division and gcd algorithms to multivariate polynomials with coef-
ﬁcients in an integral domain. It includes algorithms for three polyno-
mial division operations (recursive division, monomial-based division, andpseudo-division); polynomial expansion (including an application to the
algebraic substitution problem); and the primitive and subresultant algo-
rithms for gcd computation.
Chapter 7: The Resultant. This chapter introduces the resultant
of two polynomials, which is deﬁned as the determinant of a matrix whose
entries depend on the coeﬃcients of the polynomials. We describe a Eu-clidean algorithm and a subresultant algorithm for resultant computation
and use the resultant to ﬁnd polynomial relations for explicit algebraic
numbers.
Chapter 8: Polynomial Simpliﬁcation with Side Relations.
This chapter includes an introduction to Gr¨ obner basis computation with
an application to the polynomial simpliﬁcation problem. To simplify the
presentation, we assume that polynomials have rational number coeﬃcients
and use the lexicographical ordering scheme for monomials.
Chapter 9: Polynomial Factorization. The goal of this chapter is
the description of a basic version of a modern factorization algorithm forsingle variable polynomials in Q[x]. It includes square-free factorization
algorithms in Q[x]a n d Z
p[x], Kronecker’s classical factorization algorithm
forZ[x], Berlekamp’s algorithm for factorization in Zp[x], and a basic ver-
sion of the Hensel lifting algorithm.
xvi Preface
Computer Algebra Software and Programs
We use a procedure style of programming that corresponds most closely
to the programming structures and style of the Maple, Mathematica, and
MuPAD systems and, to a lesser degree, to the Macsyma and Reduce
systems. In addition, some algorithms are described by transformation
rules that translate to the pattern matching languages in the Mathematica
and Maple systems. Unfortunately, the programming style used here doesnot translate easily to the structures in the Axiom system.
The dialogues and algorithms in these books have been implemented
in the Maple 7.0, Mathematica 4.1, and MuPAD Pro (Version 2.0)sys-
tems. The dialogues and programs are found on a CD included with the
books. In each book, available dialogues and programs are indicated by theword “Implementation” followed by a system name Maple, Mathematica,
or MuPAD. System dialogues are in a notebook format (mws in Maple, nb
in Mathematica, and mnb in MuPAD), and procedures are in text (ASCII)
format (for examples, see the dialogue in Figure 1.1on page 3and the pro-
cedure in Figure 4.15on page 148). In some examples, the dialogue display
of a computer algebra system given in the text has been modiﬁed so that
it ﬁts on the printed page.
Electronic Version of the Book
These books have been processed in the L ATEX2εsystem with the hyperref
package, which allows hypertext links to chapter numbers, section numbers,displayed (and numbered)formulas, theorems, examples, ﬁgures, footnotes,
exercises, the table of contents, the index, the bibliography, and web sites.
An electronic version of the book (as well as additional reference ﬁles)in
the portable document format (PDF), which is displayed with the Adobe
Acrobat software, is included on the CD.
Acknowledgements
I am grateful to the many students and colleagues who read and helpeddebug preliminary versions of this book. Their advice, encouragement,
suggestions, criticisms, and corrections have greatly improved the style and
structure of the book. Thanks to Norman Bleistein, Andrew Burt, AlexChampion, the late Jack Cohen, Robert Coombe, George Donovan, Bill
Dorn, Richard Fateman, Clayton Ferner, Carl Gibbons, Herb Greenberg,
Jillane Hutchings, Lan Lin, Zhiming Li, Gouping Liu, John Magruder,
Jocelyn Marbeau, Stanly Steinberg, Joyce Stivers, Sandhya Vinjamuri, and
Diane Wagner.
Preface xvii
I am grateful to Gwen Diaz and Alex Champion for their help with
the L ATEX document preparation; Britta Wienand, who read most of the
text and translated many of the programs to the MuPAD language; Aditya
Nagrath, who created some of the ﬁgures; and Michael Wester who trans-lated many of the programs to the Mathematica, MuPAD, and Macsyma
languages. Thanks to Camie Bates, who read the entire manuscript and
made numerous suggestions that improved the exposition and notation,and helped clarify confusing sections of the book. Her careful reading dis-
covered numerous typographical, grammatical, and mathematical errors.
I also acknowledge the long-term support and encouragement of my
home institution, the University of Denver. During the writing of the
book, I was awarded two sabbatical leaves to develop this material.
Special thanks to my family for encouragement and support: my late
parents Elbert and Judith Cohen, Daniel Cohen, Fannye Cohen, and Louis
and Elizabeth Oberdorfer.
Finally, I would like to thank my wife, Kathryn, who as long as she can
remember, has lived through draft after draft of this book, and who with
patience, love, and support has helped make this book possible.
Joel S. Cohen
Denver, ColoradoSeptember, 2001
xviii Preface
1
Introduction to Computer Algebra
1.1 Computer Algebra and Computer Algebra Systems
The mathematical scientist models natural phenomena by translating ex-
perimental results and theoretical concepts into mathematical expressions
containing numbers, variables, functions, and operators. Then, using ac-cepted methods of mathematical reasoning, these expressions are carefully
manipulated or transformed into other expressions that reveal new knowl-
edge about the phenomenon being studied. This mathematical approach
to understanding the world has been an important component of the scien-
tiﬁc method in the physical sciences since the time of Galileo and Descartes.Following in the footsteps of these scientists, Isaac Newton used this ap-
proach to formulate an axiomatic, quantitative description of the motion of
objects. By using mathematical reasoning, he discovered the universal lawof gravitation and derived additional laws that describe the motion of the
tides and the orbits of the planets. Thus the science we call mechanics was
born, and the technique of manipulating and transforming mathematicalexpressions was ﬁrmly established as an important tool for discovering new
knowledge about the physical world.
In the past ﬁfty years, the computer has become an indispensable exper-
imental tool that greatly extends our ability to solve mathematical prob-lems. Mathematical scientists routinely use computers to obtain numerical
and graphical solutions to problems that are too diﬃcult or even impossible
to solve by hand. But computers are not just number crunchers. In fact, at
a basic level, computers simply manipulate symbols (0s and 1s) according
to well-deﬁned rules, and it is natural to ask what other parts of the math-
1
2 1. Introduction to Computer Algebra
ematical reasoning process are amenable to computer implementation. Of
course, it is unreasonable to expect a machine to formulate the axioms
of mechanics as Newton did or derive from scratch the important results
of the theory. However, one part of the mathematical reasoning process,the mechanical manipulation and analysis of mathematical expressions, is
surprisingly algorithmic. There are now computer programs that routinely
simplify algebraic expressions, integrate complicated functions, ﬁnd exactsolutions to diﬀerential equations, and perform many other operations en-
countered in applied mathematics, science, and engineering.
In this book we are concerned primarily with the development and
application of algorithms and computer programs that carry out this me-
chanical aspect of the mathematical reasoning process. The ﬁeld of mathe-
matics and computer science that is concerned with this problem is knownascomputer algebra orsymbol manipulation.
Computer Algebra Systems and Languages
Acomputer algebra system (CAS) or symbol manipulation system is a com-
puter program that performs symbolic mathematical operations. In Fig-
ure1.1we show an interactive dialogue with the Maple computer algebra
system developed by Waterloo Maple Inc. The statements that are pre-ceded by the prompt ( >) are inputs to the system that are entered at a
computer workstation. The commands factor ,convert ,compoly ,a n d
simplify are examples of mathematical operators in the Maple system. In
response to these statements, the program performs a mathematical oper-
ation and displays the result using a notation that is similar to ordinary
mathematical notation.
InF i g u r e 1.1, at the ﬁrst two prompts, a polynomial is assigned (with
the operator “ :=”) to a variable u1 and then factored in terms of irre-
ducible factors with respect to the rational numbers. (In other words, none
of the polynomials in the factored form can be factored further without
introducing radicals.) At prompts three and four, we enter a rational ex-
pression and then ﬁnd its partial fraction decomposition. At the next twoprompts, Maple’s compoly command determines that the polynomial u3i s
ac o m p o s i t e
u3=f(g(x)),f(x)=x
3+1 0+8x+3x2,g(x)=3x+x2.
The process of representing a polynomial as a composite of lower degree
polynomials is called polynomial decomposition . At the remaining prompts,
1.1. Computer Algebra and Computer Algebra Systems 3
> u1 := x^5-4*x^4-7*x^3-41*x^2-4*x+35;
u1:=x5−4x4−7x3−41x2−4x+35
> factor(u1);
(x+1)(x2+2x+7)(x2−7x+5)
> u2 := (x^4+7*x^2+3)/(x^5+x^3+x^2+1);
u2:=x4+7x2+3
x5+x3+x2+1
> convert(u2,parfrac,x) ;
11
61
x+1+2
3(4+x)
x2−x+1−3
2x+1
x2+1
> u3 := x^6+9*x^5+30*x^4+45*x^3+35*x^2+24*x+10;
u3:=x6+9x5+30x4+45x3+35x2+24x+10
> compoly(u3,x);
x3+10+8 x+3x2,x=3x+x2
> u4 := 1/(1/a+c/(a*b))+(a*b*c+a*c^2)/(b+c)^2;
u4:=1
1
a+c
ab+abc+ac2
(b+c)2
> simplify(u4);
a
> u5 := (sin(x)+sin(3*x)+sin(5*x)+sin(7*x))/(cos(x)+cos(3*x)
+cos(5*x)+cos(7*x))-tan(4*x);
u5:=sin(x)+sin(3 x)+sin(5 x)+sin(7 x)
cos(x)+cos(3x)+cos(5x)+cos(7x)−tan(4x)
> simplify(u5);
0
Figure 1.1. An interactive dialogue with the Maple system that shows some
symbolic operations from algebra and trigonometry. (Implementation: Maple
(mws),Mathematica (nb),MuPAD(mnb).)
4 1. Introduction to Computer Algebra
> u6 := cos(2*x+3)/(x^2+1);
u6:=cos(2x+3)
x2+1
> diff(u6,x);
−2sin(2x+3)
x2+1−2cos(2x+3)x
(x2+1)2
> u7 := cos(x)/(sin(x)^2+3*sin(x)+4);
u7:=cos(x)
sin(x)2+3sin(x)+4
> int(u7,x);
2
7√
7arctanW1
7(2sin(x)+3)√
7}
> u8 := diff(y(x),x) + 3*y(x) = x^2+sin(x);
u8:=W∂
∂xy(x)}
+3y(x)=x2+sin(x)
> dsolve(u8,y(x));
y(x)=1
3x2−2
9x+2
27−1
10cos(x)+3
10sin(x)+e(−3x)
C1
Figure 1.2. An interactive dialogue with the Maple system that shows some
symbolic operations from calculus and diﬀerential equations. (Implementation:
Maple(mws),Mathematica (nb),MuPAD(mnb).)
Maple simpliﬁes an involved algebraic expression u4 and then veriﬁes a
trigonometric identity1.
InF i g u r e 1.2, we again call on Maple to perform some operations from
calculus and diﬀerential equations2.T h e diffcommand at the second
1Algebraic simpliﬁcation is described in Sections 2.2and6.5, and trigonometric sim-
pliﬁcation is described in Section 7.2.
For further study, the reader may consult Cohen [ 24]: algebraic simpliﬁcation is dis-
cussed in Chapter 3, Section 6.3, and Chapter 8; partial fraction decomposition in Section4.4; polynomial decomposition in Chapter 5; and polynomial factorization in Chapter 9.
2We give algorithms in the book for all of these operations. Diﬀerentiation is de-
scribed in Section 5.2, elementary integration in Section 5.3, and the solution of diﬀer-
ential equations in Section 4.3.
1.1. Computer Algebra and Computer Algebra Systems 5
prompt is used for diﬀerentiation and the intcommand at the fourth
prompt is for integration. Notice that the output of the intoperator does
not include the arbitrary constant of integration. At the ﬁfth prompt we
assign a ﬁrst order diﬀerential equation3tou7, and at the sixth prompt
ask Maple to solve the diﬀerential equation. The symbol
 C1 is Maple’s
way of including an arbitrary constant in the solution4.
We use the term computer algebra language orsymbolic programming
language to refer to the computer language that is used to interact with a
CAS. Most computer algebra systems can operate in a programming mode
as well as an interactive mode (shown in Figures 1.1and1.2). In the pro-
gramming mode, the mathematical operators factor ,simplify ,e t c .,a r e
combined with standard programming constructs such as assignment state-
ments, loops, conditional statements, and subprograms to create programs
that solve more involved mathematical problems.
To illustrate this point, consider the problem of ﬁnding the formula for
the tangent line to the curve
y=f(x)=x2+5x+6
at the point x= 2. First, we ﬁnd a general formula for the slope by
diﬀerentiation
dy
dx=2x+5.
T h es l o p ea tt h ep o i n t x= 2 is obtained by substituting this value into
this expression
m=dy
dx(2) = 2(2) + 5 = 9 .
The equation for the tangent line is obtained using the point slope form
for a line:
y=m(x−2) +f(2) = 9( x−2) + 20 (1.1)
=9x+2.
To obtain the last formula, we have expanded the right side of Equa-
tion (1.1).
InF i g u r e 1.3we give a general procedure, written in the Maple com-
puter algebra language that mimics these calculations. The procedure com-
putes the tangent line formula for an arbitrary expression fat the point
3Maple displays the derivative of an unknown function y(x) using the partial deriva-
tive symbol instead of ordinary derivative notation.
4Maple includes an arbitrary constant in the solution of a diﬀerential equation, but
does not include the arbitrary constant for an antidiﬀerentiation. Inconsistencies of thissort are commonplace with computer algebra software.
6 1. Introduction to Computer Algebra
1 Tangent_line := proc(f,x,a)
2 local
3 deriv,m,line;4 deriv := diff(f,x);
5 m := subs(x=a,deriv);
6 line := expand(m*(x-a)+subs(x=a,f));7 RETURN(line)
8 end:
Figure 1.3. A procedure in the Maple language that obtains a formula for the
tangent line. The line numbers are not part of the Maple program. (Implemen-tation:Maple(txt),Mathematica (txt),MuPAD(txt).)
x=a. The operator diffin line 4 is used for diﬀerentiation and the
operator subsin line 5 for substitution. The expand operator in line 6 is
included to simplify the output. Once the procedure is entered into theMaple system, it can be invoked from the interactive mode of the system
(see Figure 1.4).
> Tangent_line(x^2+5*x+6, x, 2);
9x+2
Figure 1.4. The execution of the Tangent
 lineprocedure in the interactive
mode of the Maple system. (Implementation: Maple(mws),Mathematica (nb),
MuPAD(mnb).)
Commercial Computer Algebra Systems
In the last 15 years, we have seen the creation and widespread distribution
of a number of large (but easy to use) computer algebra systems. The most
prominent of the commercial and University packages are:
•Axiom – a very large CAS originally developed at IBM under the
name Scratchpad. Information about Axiom can be found in Jenks
and Sutor [ 50].
•Derive – a small CAS originally designed by Soft Warehouse Inc. for
use on a personal computer. Derive has also been incorporated in the
1.1. Computer Algebra and Computer Algebra Systems 7
TI-89 and TI-92 handheld calculators produced by Texas Instruments
Inc. Information about Derive can be found at the web site
http://www.derive.com .
•Macsyma – a very large CAS originally developed at M.I.T. in the
late 1960s and 1970s. There are currently a number of versions of the
original Macsyma system. Information about Macsyma can be found
in Wester [ 100].
•Maple – a very large CAS originally developed by the Symbolic
Computation Group at the University of Waterloo (Canada) and now
distributed by Waterloo Maple Inc. Information about Maple is found
in Heck [ 45]o ra tt h ew e bs i t e
http://www.maplesoft.com .
•Mathematica – a very large CAS developed by Wolfram Research
Inc. Information about Mathematica can be found in Wolfram [ 102]
or at the web site
http://www.wolfram.com .
•MuPAD – a large CAS developed by the University of Paderborn
(Germany) and SciFace Software GmbH & Co. KG. Information about
MuPAD can be found in Gerhard et al. [ 40]o ra tt h ew e bs i t e
http://www.mupad.com .
•Reduce – one of the earliest computer algebra systems originally
developed in the late 1960s and 1970s. Information about Reduce isfound in Rayna [ 83]o ra tt h ew e bs i t e
http://www.uni-koeln.de/REDUCE .
All of these packages are integrated mathematics problem solving sys-
tems that include facilities for exact symbolic computations (similar to
those in Figures 1.1,1.2,a n d 1.3), along with some capability for (ap-
proximate) numerical solution of mathematical problems and high quality
graphics. The examples in this book refer primarily to the computer al-
gebra capabilities of the Maple, Mathematica, and MuPAD systems, since
these systems are readily available and support a programming style that
is most similar to the one used here.
8 1. Introduction to Computer Algebra
Mathematical Knowledge in Computer Algebra Systems
Computer algebra systems have the capability to perform exact symbolic
computations in many areas of mathematics. A sampling of these capabil-
ities includes:
•Arithmetic – unlimited precision rational number arithmetic, com-
plex (rational number) arithmetic, transformation of number bases,
interval arithmetic, modulo arithmetic, integer operations (greatestcommon divisors, least common multiples, prime factorization), com-
binatorial functions.
•Algebraic manipulation – simpliﬁcation, expansion, factorization,
substitution operations.
•Polynomialoperations – structural operations on polynomials (de-
gree, coeﬃcient extraction), polynomial division, greatest common
divisors, factorization, resultant calculations, polynomial decomposi-tion, simpliﬁcation with respect to side relations.
•Solution of equations – polynomial equations, some non-linear
equations, systems of linear equations, systems of polynomial equa-
tions, recurrence relations.
•Trigonometry – trigonometric expansion and reduction, veriﬁcation
of identities.
•Calculus – derivatives, antiderivatives, deﬁnite integrals, limits, Tay-
lor series, manipulation of power series, summation of series, opera-
tions with the special functions of mathematical physics.
•Diﬀerentialequations – solution of ordinary diﬀerential equations,
solution of systems of diﬀerential equations, solution using series,solution using Laplace transforms, solution of some partial diﬀerential
equations.
•Advanced algebra – manipulations with algebraic numbers, group
theory, Galois groups.
•Linear algebra and related topics – matrix operations, vector
and tensor analysis.
•Code generation – formula translation to conventional program-
ming languages such as FORTRAN and C, formula translation to
mathematics word processing languages (L
ATEX).
1.1. Computer Algebra and Computer Algebra Systems 9
In addition, computer algebra systems have the capability to utilize this
mathematical knowledge in computer programs that solve other mathe-
matical problems.
Exercises
1. What transformation rules from algebra, trigonometry, or calculus must a
computer “know” to perform the following operations? Be careful not toomit any obvious arithmetic or algebraic rules that are used to obtain theresult in a simpliﬁed form.
(a)d(ax+xe
x2)
dx=a+ex2+2x2ex2.
(b)sec(x)
sin(x)−sin(x)
cos(x)−cot(x)=0.
(c)1
1/a+c/(ab)+abc+ac2
(b+c)2=a.
2. All computer algebra systems include an algebraic expansion command
that obtains transformations similar to
(x+2)(x+3)(x+4) = x3+9x2+26x+24,
(x+y+z)3=x3+y3+z3+3x2y+3x2z+3y2x
+3y2z+3z2x+3z2y+6xyz,
(x+1)2+(y+1)2=x2+2x+y2+2y+2,
((x+2)2+3)2=x4+8x3+30x2+56x+49.
(In Maple, the expandcommand; in Mathematica the Expandcommand;
in MuPAD, the expandcommand.)
What algorithm would you use to perform this operation? It is not nec-
essary to give the exact algorithm. Rather describe some of the issues
that arise when youtry to design a mechanical procedu re for this opera-
tion. What mathematical and computational techniques are useful for thisalgorithm?
3. The simpliﬁcation of mathematical expressions is an important aspect of
themathematical reasoning processandallcomputeralgebra systemshavesome capability to perform this operation (see Figure 1.1on page3). Al-
though simpliﬁcation is described in elementary mathematics textbooks,
it is deﬁned in a vague way. However, to give an algorithm that performssimpliﬁcation, we must have a precise deﬁnition of the term. Is it possibleto give a precise deﬁnition for simpliﬁcation?
10 1. Introduction to Computer Algebra
1.2 Applications of Computer Algebra
The Purpose of Applied Mathematics
In the fascinating book Mathematics Applied to Deterministic Problems in
the Natural Sciences ([63], SIAM, 1988, pages 5-7), Lin and Segel describe
the purpose of applied mathematics in the following way:
The purpose of applied mathematics is to elucidate scientiﬁc
concepts and describe scientiﬁc phenomena through the use of
mathematics, and to stimulate the development of new mathe-matics through such studies.
They discuss three aspects of this process that relate to the solution of
scientiﬁc problems:
(i) theformulation of the scientiﬁc problem in mathematical terms.
(ii) thesolution of the mathematical problems thus created.
(iii) theinterpretation of the solution and its empirical veriﬁcation in
scientiﬁc terms.
In addition, they mention a closely related adjunct of this process:
(iv) the generation of scientiﬁcally relevant new mathematics through cre-
ation, generalization, abstraction, and axiomatic formulation.
In principle, computer algebra can help facilitate steps (i), (ii), and (iv)
of this process. In practice, computer algebra is primarily involved in step
(ii) and to a much lesser degree in steps (i) and (iv).
Examples of Computer Algebra
In the remainder of this section, we give four examples that illustrate theuse of computer algebra software in the problem solving process. All of the
examples are concerned with the solution of equations.
Example 1.1. (Solution of a linear system of equations.) AC A S
is particularly useful for calculations that are lengthy and tedious but
straightforward. The solution of a linear system of equations with symbolic
coeﬃcients provides an example of this situation. The following system of
equations occurs in a problem in statistical mechanics5:
5The author encountered this system of equations while working on a problem in
statistical mechanics in 1982. At that time the solution of the system with pencil and
paper (including checking and re-checking the result) took two days. Unfortunately,the published result still contains a minor coeﬃcient error. See Cohen, Haskins, andMarchand [ 23].
1.2. Applications of Computer Algebra 11
d0+d1+d2+d3+d4=1,
d1+2d2+3d3+4d4=2 ( 1 −m),
3d0−d2+3d4=2γ2,0+γ1,1, (1.2)
φd0+ψd1−ψd3−φd4=m,
2φd0+ψd1+ψd3+2φd4=2γ1,0.
In this system the ﬁve unknown variables are d0,d1,d2,d3,a n dd4.T h e
coeﬃcients of these variables and the right-hand sides of the equations
depend on the six parameters m,φ,ψ,γ 1,0,γ1,1,a n dγ2,0, and the object is
to express the unknowns in terms of these parameters. Whether or not this
is a good problem for a CAS depends on the purpose of the computation. Inthis case a solution is needed to help understand the eﬀect of the various
parameters on the individual unknowns. What is needed is not just a
solution, but one that is compact enough to allow for an easy interpretationof the result.
The symbolic solution of ﬁve linear equations with ﬁve unknowns has
the potential to produce expressions with hundreds of terms. In this case,
however, the coeﬃcients are not completely random but instead contain
a symmetry pattern. Because of this there is reason to believe (but no
guarantee) that the solutions will simplify to expressions of reasonable size.
Figure 1.5shows an interactive dialogue with the Mathematica system
that solves the system of equations. The input statements in Mathematica
are indicated by the label “ In” followed by an integer in brackets and the
symbol “ :=”(In[1]:=, In[2]:= ,e t c . ) .T h es y m b o l s Out[1]=, Out[2]= ,e t c . ,
are labels that represent the output produced by each input line. The other
equal sign in lines In[1]through In[6]is an assignment symbol and the
symbol “ ==” is used for equality in an equation. The command to solve
the system of equations is given in In[6]and the solution to the system
is displayed in the lines following Out[6] . As we suspected, the solution
simpliﬁes to expressions of reasonable size. /square
One application of computer algebra systems is the exact solution of
polynomial equations. For polynomial equations with degree less than orequal to four it is always possible to obtain solutions in terms of expressions
with radicals, although for cubic and quartic equations these solutions are
often quite involved. For polynomials with degree ﬁve or greater, it istheoretically impossible to represent the solutions of all such equations
using expressions with radicals
6, although it is possible to solve some of
these equations.
6This statement follows from Galois theory, the algebraic theory that describes the
nature of solutions to polynomial equations.
12 1. Introduction to Computer Algebra
In[1]: = eq1=d[0]+d[1]+d[2]+d[3]+d[4]= = 1
Out[1]=d[0]+d[1]+d[2]+d[3]+d[4] == 1
In[2]: = eq2=d[1]+2∗d[2]+3∗d[3]+4∗d[4]= = 2∗(1−m)
Out[2]=d[1]+2 d[2]+3 d[3]+4 d[4] == 2(1 −m)
In[3]: = eq3=3∗d[0]−d[2]+3∗d[4]= = 2∗γ[2,0]+γ[1,1]
Out[3]: = 3 d[0]−d[2]+3 d[4] == γ[1,1]+2γ[2,0]
In[4]: = eq4=φ∗d[0]+ϕ∗d[1]−ϕ∗d[3]−φ∗d[4]= = m
Out[4]: =φd[0]+ϕd[1]−ϕd[3]−φd[4] == m
In[5]: = eq5=2∗φ∗d[0]+ϕ∗d[1]+ϕ∗d[3]+2∗φ∗d[4]= = 2∗γ[1,0]
Out[5]: = 2 φd[0]+ϕd[1]+ϕd[3]+2 φd[4] ==2 γ[1,0]
In[6]: = Solve[{eq1,eq2,eq3,eq4,eq5},{d[0],d[1],d[2],d[3],d[4]}]
Out[6]=
d[2]→−1
2(φ−2ϕ)(3ϕ−6γ[1,0]+2φγ[1,1]−ϕγ[1,1]+4φγ[2,0]
−2ϕγ[2,0]),
d[0]→−1
4(φ−2ϕ)(−2m+ϕ+4mϕ−2γ[1,0]+ϕγ[1,1]+2ϕγ[2,0]),
d[1]→−1
2(φ−2ϕ)(2m−φ−2mφ+4γ[1,0]−φγ[1,1]−2φγ[2,0]),
d[3]→−1
2(φ−2ϕ)(−2m−φ+2mφ+4γ[1,0]−φγ[1,1]−2φγ[2,0]),
d[4]→−1
4(φ−2ϕ)(2m+ϕ−4mϕ−2γ[1,0]+ϕγ[1,1]+2ϕγ[2,0])11
Figure 1.5. An interactive dialogue with the Mathematica system that solves a
system of linear equations. (Implementation: Maple(mws),Mathematica (nb),
MuPAD(mnb).)
Example 1.2. (Solution of cubic polynomial equations.) To exam-
ine the possibilities (and limitations) for symbolic solutions of polynomial
equations, consider the cubic equation
x3−2ax+a3=0 ( 1 . 3 )
1.2. Applications of Computer Algebra 13
where the symbol ais a parameter. We examine the nature of the solution
for various values of ausing the Maple system7in Figures 1.6,1.7,a n d1.8.
At the ﬁrst prompt ( >)i nF i g u r e 1.6, the equation is assigned to the vari-
able eq. At the second prompt, the equation is solved for xusing Maple’s
solve c o m m a n da n ds t o r e di nt h ev a r i a b l e general
 solution .T h e i n -
volved solution, which contains three expressions separated by commas, is
expressed in terms of an auxiliary expression for which Maple has chosenthe name %1 and the symbol Iwhich represents√
−1. In ordinary (and
more user friendly) mathematical notation the three solutions are
x=1
6r1/3+4a
r1/3,
−1
12r1/3−2a
r1/3+1/2ı√
3/parenleftbigg1
6r1/3−4a
r1/3/parenrightbigg
,
−1
12r1/3−2a
r1/3−1/2ı√
3/parenleftbigg1
6r1/3−4a
r1/3/parenrightbigg
,
where
r=−108a3+1 2/radicalbig
−96a3+8 1a6,ı =√
−1.
At the next prompt the subscommand8is used to substitute a=1i nt h e
general solution to obtain the solution s1. In this form the expressions are
so involved that it is diﬃcult to tell which roots are real numbers and whichones have an imaginary part. Since a cubic equation with real number
coeﬃcients can have at most two roots with non-zero imaginary parts, at
least one of the roots must be a real number. At the fourth prompt, we
attempt to simplify the solutions with Maple’s radsimp command, which
can simplify some expressions with radicals
9. In this case, unfortunately,
it only transforms the solution to another involved form.
To determine the nature (real or not real) of the roots, at the next
prompt we apply Maple’s evalc command, which expresses the roots in
7For the Maple dialogues in this section, the Output Display is set to the Typeset
Notation option. Other options display output expressions in other forms.
8This input statement has one unfortunate complication. Observe that in the subs
command we have placed the set braces {and}about general
 solution . The reason
for this has to do with the form of the output of Maple’s solve command. For this
equation, general
 solution consists of three expressions separated by commas which is
known as an expression sequence in the Maple language. Unfortunately, an expression
sequence cannot be input for the Maple subs command, and so we have included the two
braces so that the input expression is now a Maple setwhich is a valid input. Observe
that the output s1i sa l s oaM a p l es e t .
9Another possibility is the Maple command radsimp(s1,ratdenom) which is an op-
tional form that rationalizes denominators. This command obtains a slightly diﬀerentform, but not the simpliﬁed form.
14 1. Introduction to Computer Algebra
>e q: =x ∧3-2*a*x+a ∧3=0;
eq:=x3−2ax+a3=0
> general
 solution := solve(eq,x);
general
 solution :=1
6%1(1/3)+4a
%1(1/3),
−1
12%1(1/3)−2a
%1(1/3)+1
2I√
3(1
6%1(1/3)−4a
%1(1/3)),
−1
12%1(1/3)−2a
%1(1/3)−1
2I√
3(1
6%1(1/3)−4a
%1(1/3))
%1 := −108a3+1 2√
−96a3+8 1a6
> s1 := subs(a=1, {general
 solution });
s1: =M
1
6%1 +4
i−108 + 12√
−15J1/3,
−1
12%1−2
i−108 + 12√
−15J1/3+1
2I√
3~
1
6%1−1
i−108 + 12√
−15J1/3^
,
−1
12%1−2
i−108 + 12√
−15J1/3−1
2I√
3~
1
6%1−1
i−108 + 12√
−15J1/3^r
%1 :=i−108 + 12√
−15J1/3
> radsimp(s1);


1
6Q
−108 + 12 I√
15w(2/3)
+2 4
3
−108 + 12 I√
15,1
12−%1(2/3)−24 +I√
3% 1(2/3)−24I√
3
%1,
−1
12%1(2/3)+2 4+I√
3% 1(2/3)−24I√
3
%1,r
%1 := −108 + 12 I√
3√
5
> simplify(evalc(s1))
k
−1
3√
2(√
3 cos(%1) + 3 sin(%1)) ,−1
3√
2(√
3 cos(%1) −3s i n ( % 1 ) ) ,2
3√
2√
3 cos(%1)L
%1 := −1
3arctanW1
9√
3√
5}
+1
3π
Figure 1.6. An interactive dialogue with the Maple system for solving a cubic
equation. (Implementation: Maple(mws),Mathematica (nb),MuPAD(mnb).)
1.2. Applications of Computer Algebra 15
> eq2 := subs(a=1,eq);
eq2:=x3−2x+1=0
> solve(eq2,x);
1,−1
2+1
2√
5,−1
2−1
2√
5
Figure 1.7. Solving a cubic equation with Maple (continued). (Implementation:
Maple(mws),Mathematica (nb),MuPAD(mnb).)
terms of their real and imaginary parts, and then apply the simplify
command, which attempts to simplify the result. Observe that the solutions
are now expressed in terms of the trigonometric functions sin and cos andthe inverse function arctan. Although the solutions are still quite involved,
we see that all three roots are real numbers. We will show below that the
solutions can be transformed to a much simpler form, although this cannotbe done directly with these Maple commands.
Actually, a better approach to ﬁnd the roots when a= 1 is to substitute
this value in Equation ( 1.3), and solve this particular equation rather than
use the general solution. This approach is illustrated in Figure 1.7.A t
the ﬁrst prompt we deﬁne a new equation eq2, and at the second prompt
solve the equation. In this case the roots are much simpler since Maple can
factor the polynomial as x
3−2x+1=(x−1)(x2+x−1) which leads
to simple exact expressions. On the other hand the general equation ( 1.3)
cannot be factored for all values of a, and so the roots in Figure 1.6for
a= 1 are given by much more involved expressions.
This example illustrates an important maxim about computer algebra:
A general approach to a problem should be avoided when a par-
ticular solution will suﬃce.
Although the general solution gives a solution for a= 1, the expres-
sions are unnecessarily involved, and to obtain useful information requires
an involved simpliﬁcation, which cannot be done easily with the Maplesoftware
10.
Let’s consider next the solution of Equation ( 1.3)w h e na=1/2. In
Figure 1.8, at the ﬁrst prompt we deﬁne a new cubic equation eq3, and
10This simpliﬁcation can be done with the Mathematica system using the
FullSimplify command and with the MuPAD system using the radsimp command.
There are, however, other examples that cannot be simpliﬁed by any of the systems.See Footnote 6on page 145for a statement about the theoretical limitations of algorith-
mic simpliﬁcation.
16 1. Introduction to Computer Algebra
> eq3 := subs(a=1/2,eq);
eq3:=x3−x+1
8=0
> s2:=solve(eq3,x);
s2:=1
12%1 +4
(−108 + 12 I√
687)(1/3),
−1
24%1−2
(−108 + 12 I√
687)(1/3)+1
4I√
3(1
6%1−8
(−108 + 12 I√
687)(1/3)),
−1
24%1−2
(−108 + 12 I√
687)(1/3)−1
4I√
3(1
6%1−8
(−108 + 12 I√
687)(1/3))
%1 := ( −108 + 12 I√
687)(1/3)
> s3 := radsimp( {s2});
s3: =M
1
12(−108 + 12 I√
687)(2/3)+4 8
(−108 + 12 I√
687)(1/3),1
24−%1(2/3)−48 +I√
3%1(2/3)−48I√
3
%1(1/3),
−1
24%1(2/3)+4 8+I√
3% 1(2/3)−48I√
3
%1(1/3)r
%1 := −108 + 12 I√
3√
229
> simplify(evalc( {s2}))
k2
3√
3 cos(%1) ,−1
3√
3 cos(%1) −sin(%1),−1
3√
3 cos(%1) + sin(%1)L
%1 := −1
3arctanW1
9√
3√
229}
+1
3π
> evalf(s3)
{.9304029266 −.8624347141 10−10I,−1.057453771+ .4629268900 10−9I,
.1270508443 −.2120100566 10−9I}
Figure 1.8. Solving cubic equations with Maple (continued). (Implementation:
Maple(mws),Mathematica (nb),MuPAD(mnb).)
at the next three prompts solve it and try to simplify the roots. Again
the representations of the roots in s2ands3are quite involved, and it
is diﬃcult to tell whether the roots are real or include imaginary parts.
Again, to determine the nature of the roots, we apply Maple’s evalc and
simplify commands and obtain an involved representation in terms of
1.2. Applications of Computer Algebra 17
the trigonometric functions sin and cos and the inverse function arctan.
Although the solutions are still quite involved, it appears that all three
roots are real numbers.
In this case, nothing can be done to simplify the exact roots. In fact,
even though the three roots are real numbers, we can’t eliminate the symbol
ı=√
−1f r o m s2ors3without introducing the trigonometric functions
as in s4. This situation, which occurs when none of the roots of a cubic
equation is a rational number11, shows that there is a theoretical limitation
to how useful the exact solutions using radicals can be. The exact solutions
can be found, but cannot be simpliﬁed to a more useful form.
Given this situation, at the last prompt, we apply Maple’s evalf
command that evaluates the roots s3to an approximate decimal format.
The small non-zero imaginary parts that appear in the roots are due to
the round-oﬀ error that is inevitable with approximate numerical calcula-
tions. /square
Example 1.3. (Solution of higher degree polynomial equations.)
Although computer algebra systems can solve some higher degree polyno-
mial equations, they cannot solve all such equations, and in cases wheresolutions can be found they are often so involved that they are not useful
in practice (Exercise 2(a)). Nevertheless, computer algebra systems can
obtain useful solutions to some higher degree equations. This is shown in
the ﬁrst two examples in the MuPAD dialogue in Figure 1.9.
At the ﬁrst prompt (the symbol •) we assign a polynomial to the vari-
ableu, and then at the next prompt solve u=0f o rx. In this case MuPAD
obtains the solutions by ﬁrst factoring uin terms of polynomials with in-
teger coeﬃcients as
u=(x−1)(x
2+x+2 )(x2+5x−4),
and then using the quadratic formula for the two quadratic factors.
At the third prompt we assign a sixth degree polynomial to v,a n dt r yt o
factor it at the next prompt. Since MuPAD returns the same polynomial,
it is not possible to factor vin terms of lower degree polynomials that have
integer coeﬃcients. At the next prompt, however, MuPAD obtains the sixroots tov= 0. In this case MuPAD ﬁnds the solutions by ﬁrst recognizing
that the polynomial vcan be written as a composition of polynomials
v=f(g(x)),f(w)=w
3−2,w=g(x)=x2−2x−1.
11See Birkhoﬀ and Mac Lane [ 10], page 450, Theorem 22. An interesting historical
discussion of this problem is given in Nahin [ 74].
18 1. Introduction to Computer Algebra
•u:=x∧5+5∗x∧4−3∗x∧3+3∗x∧2−14∗x+8;
−14·x+3·x2−3·x3+5·x4+x5+8
•solve (u=0,x,MaxDegree =5);
M
1,−√
41
2−5
2,√
41
2−5
2,Q
−ı
2w
·√
7−1
2,Qı
2w
·√
7−1
2r
•v:=x∧6−6∗x∧5+4∗x∧3+9∗x∧4−9∗x∧2−6∗x−3;
−6·x−9·x2+4·x3+9·x4−6·x5+x6−3
•factor (v);
−6·x−9·x2+4·x3+9·x4−6·x5+x6−3
•solve (v=0,x,MaxDegree =6);


6
3√
2+2+1 ,−6
3√
2+2+1 ,−6
−8·3√
2+(−8·ı)·3√
2·√
3+3 2
4+1,
6
−8·3√
2+(−8·ı)·3√
2·√
3+3 2
4+1,−6
−8·3√
2+( 8 ·ı)·3√
2·√
3+3 2
4+1,
6
−8·3√
2+( 8 ·ı)·3√
2·√
3+3 2
4+1


•w:=x∧8−136∗x∧7+6476∗x∧6−141912 ∗x∧5+1513334 ∗x∧4
−7453176 ∗x∧3+13950764 ∗x∧2−5596840 ∗x+46225 ;
−5596840 ·x+ 13950764 ·x2−7453176 ·x3+ 1513334 ·x4−141912 ·x5
+ 6476 ·x6−136·x7+x8+ 46225
•solve (w=0,x,MaxDegree =8);
RootOfi
−5596840 ·X1 + 13950764 ·X12−7453176 ·X13+ 1513334 ·X14
−141912 ·X15+ 6476 ·X16−136·X17+X18+ 46225,X1J
•r:= (sqrt(2)+sqrt(3)+sqrt(5)+sqrt(7))∧2;
Q√
2+√
3+√
5+√
7w2
•expand (subs(w,x=r));
0
Figure 1.9. The solution of high degree polynomial equations using MuPAD.
(Implementation: Maple(mws),Mathematica (nb),MuPAD(mnb).)
In this form the solution to v= 0 is obtained by solving w3−2=0t o
obtain
w=21/3,−21/3
2+21/331/2
2ı,−21/3
2−21/331/2
2ı,
1.2. Applications of Computer Algebra 19
and then solving the three equations
x2−2x−1=21/3,
x2−2x−1= −21/3
2+21/331/2
2ı,
x2−2x−1= −21/3
2−21/331/2
2ı.
For example, by solving the ﬁrst of these equations we obtain the ﬁrst two
roots ofv=0i nF i g u r e 1.9.
Next, we assign an involved eighth degree polynomial to w, and attempt
to solve the equation w= 0. Even though the equation has the eight roots
x=(√
2±√
3±√
5±√
7)2, (1.4)
the MuPAD solve command is unable to ﬁnd them, and returns instead a
curious expression that simply says the solutions are roots of the original
equation. At the next two prompts we assign to the variable rone of the
roots in Equation ( 1.4), and then use the subsand expand commands to
verify that it is a solution to the equation. /square
A Word of Caution
It goes without saying (but let’s say it anyway), that there is more to
mathematical reasoning than the mechanical manipulation of symbols. Itis easy to give examples where a mechanical approach to mathematical
manipulation leads to an incorrect result. This point is illustrated in the
next example.
Example 1.4. Consider the following equation for x:
√
x+7+√
x+2=1, (1.5)
where we assume that the square root symbol represents a non-negative
number and x≥−2 so that the expressions under the radical signs are
non-negative. Suppose that the goal is to ﬁnd all real values of x that
satisfy this equation. First transform the equation to
√
x+7=1 −√
x+2. (1.6)
Squaring both sides of this equation and simplifying gives
−2=√
x+2. (1.7)
20 1. Introduction to Computer Algebra
By squaring both sides of this equation and solving for x,w eo b t a i n
x=2. (1.8)
However, this value is not a root of the original Equation ( 1.5). What is
wrong with our reasoning?
In this case, the problem lies with the interpretation of the square root
symbol. If we insist that the square roots are always non-negative, there
are no real roots. However, if we allow (somewhat arbitrarily) the secondsquare root in Equation ( 1.5) to be negative, the value x=2i sar o o t .
Indeed, the necessity of this assumption appears during the calculation in
Equation ( 1.7).
Let’s see what happens when we try to solve Equation ( 1.5)w i t ha
computer algebra system. Consider the dialogue with the Macysma systemin Figure 1.10. The input statements in Macysma are preceded by the letter
cfollowed by a positive integer ( (c1), (c2) ,e t c . ) . T h es y m b o l s( (d1),
(d2), etc.) are labels that represent the output produced by each input
line. The colon in line (c1)is the assignment symbol in Macysma. At
line(c1), we assign the equation to the variable eq1a n da t (c2)attempt
to solve the equation for x. Observe that Macysma simply returns the
equation in a modiﬁed form indicating that it cannot solve the equation
with its solve command.
We can, however, help Macysma along by directing it to perform ma-
nipulations similar to the ones in Equations ( 1.6) through ( 1.8). At (c3),
(c4),(c5),a n d (c6)we direct the system to put the equation in a form
that can be solved for xat(c7). Again we obtain the extraneous root
x= 2. Of course, at (c8)when we substitute this value into the original
equation, we obtain an inequality since Macysma assumes that all square
roots of positive integers are positive.
This example shows that it is just as important to scrutinize our com-
puter calculations as our pencil and paper calculations. The point is mathe-
matical symbols have meaning, and transformations that are correct in one
context may require subtle assumptions in other contexts that render themmeaningless. In this simple example it is easy to spot the ﬂaw in our rea-
soning. In a more involved example with many steps and involved output
we may not be so lucky. Additional examples of how incorrect conclusions
can follow from deceptive symbol manipulation are given in Exercises 10,
11,12,a n d13. /square
Exploring the Capabilities of a CAS
An important prerequisite for successful use of a CAS is an understanding
of its capabilities and limitations. Since some symbolic operations are
1.2. Applications of Computer Algebra 21
(c1)eq1 : sqrt(x+7)+sqrt(x+2)=1;
(d1)√
x+7+√
x+2=1
(c2)solve(eq1,x);
(d2) [√
x+7=1 −√
x+2]
(c3)eq2 : eq1 - sqrt(x+2);
(d3)√
x+7=1 −√
x+2
(c4)eq3 : expand(eq2 ∧2);
(d4) x+7= −2√
x+2+ x+3
(c5)eq4 : eq3 - x - 3;
(d5) 4=−2√
x+2
(c6)eq5 : eq4 ∧2;
(d6) 16 = 4( x+2)
(c7)solve(eq5,x);
(d7) [x=2 ]
(c8)subst(2,x,eq1);
(d8) 5=1
Figure 1.10. A Macsyma 2.1 dialogue that attempts to solve Equation ( 1.5)b y
mimicking the manipulations in Equations ( 1.6) through ( 1.8).
quite involved, it may not be practical to list in detail all the capabilities
of a particular command. For this reason, it is important to explore the
capabilities of a CAS. Some of the exercises in this section and others
throughout the book are designed with this objective in mind.
22 1. Introduction to Computer Algebra
Exercises
For the exercises in this section, the following operators are useful:
•In Maple, the diff,int,factor,solve,simplify,radsimp,subs,a n d
evalfoperators (Implementation: Maple(mws)).
•In Mathematica, the D, Integrate, Factor, Solve, Reduce, //N,
Simplify, FullSimplify, and ReplaceAll operators (Implementation:
Mathematica (nb)).
•In MuPAD the diff,int,Factor,solve,simplify,radsimp,subs,a n d
floatoperators (Implementation: MuPAD(mnb)).
1. Which of the following expressions can be factored with a CAS? Does the
CAS return the result in the form you expect?
(a)x2−1
4.
(b)x2−a2.
(c)x2−(√
2)2.
(d)x2+1=( x−ı)(x+ı).
(e)xy+1
xy+2=( x+1/y)(y+1/x).
(f) (exp( x))2−1=e xp (2 x)−1. (Notice that these two expressions
are equivalent. Can a CAS factor both forms?)
(g)x2n−1=(xn−1)(xn+1).
(h)xm+n−xn−xm+1 = ( xm−1)(xn−1).
(i)x2+√
3x+√
2x+√
2√
3.
(j)√
3x5−√
6x4+√
2x3−2x2+√
5x−√
10 = ( x−√
2) (√
3x4
+√
2x2+√
5).
(k)x4−10x2+1=( x+√
2+√
3)(x+√
2−√
3)(x−√
2+√
3)(x−√
2−√
3).
2. In this problem we ask youto explore the capability of a CAS to ﬁnd the
exact solutions to equations. Since the solution of equations is an involvedoperation, some computeralgebra systems haveeither more thanone com-
mand for this operation or optional parameters that modify the operation
of the commands. Before attempting this exercise, you should consult thesystem documentation to determine best use the of the commands. In
addition, a CAS may return a solution in a form that includes advanced
functions that you may not be familiar with. Again, consult the systemdocumentation for the deﬁnitions of these functions.
Solve each of the following with a CAS.
(a)x
4−3x3−7x2+2x−1=0f o r x. Are the roots real or do they have
non-zero imaginary parts?
1.2. Applications of Computer Algebra 23
(b)x8−8x7+28x6−56x5+70x4−56x3+28x2−8x−1=0for x.S i n c e
this equation has degree 8, a CAS ﬁnds the solution by using either
polynomial factorization or decomposition to reduce the problem to
the solution of lower degree polynomial equations. Which approachdoes the CAS use in this case? Hint:See Example 1.3.
(c)x−π/2=c o s( x+π)f o rxa real number. (Solution x=π/2.)
(d) sin( x)=1f o r xareal. (Solution x=π/2+2πn , n=0,±1,±2,....)
(e)√
x=1−xforx≥0. By squaring both sides of this equation
we obtain the equivalent equation x2−3x+1=0w hi c hha st w o
positive roots. However, only one of these roots is a root of the
original equation.
(f) 4(x2)2x=8f o r xa real number. By taking logarithms of both sides
of this equation, we obtain the equivalent equation 2 x2+x−3=0.
(g)x2=2xforxa real number. (Solution x=2,4,x≈−.7666.)
(h)ex2−4+x=3f o r xa real number. (Solution x=2 )
(i) i.x2−1
x+1=2 (Solution x=3 ).
ii.x2−1=2( x+1)(Solution x=3,−1).
Noticethat(i)and(ii)arealgebraically equivalentexceptatthepoint
x=−1. (Strictly speaking, (i) is not deﬁned at x=−1.) Does a
CAS distinguish between these two equations?
3. Let ( x,y) be the rectangular coordinates of a point in the plane, and let
(r, θ) be the polar coordinates. Then
r2=x2+y2,tan(θ)=y/x, (1.9)
and
x=rcos(θ),y=rsin(θ). (1.10)
(a) Can a CAS solve ( 1.9)f o rxandy?
(b) Can a CAS solve ( 1.10)f o rrandθ?
4. Use a CAS system to ﬁnd the antiderivative	
1/cos5(x)dx.Verify the
result with a CAS by diﬀerentiation and simpliﬁcation.
5. The following integral is given in an integral table
1
(x+1)√
xdx=−arcsinW1−x
1+x}
,x >0.(1.11)
(a) Evaluate the integral with a CAS. (All seven computer algebra sys-
t e m sd e s c r i b e di nS e c t i o n 1.1return a form diﬀerent from Equation
(1.11).)
(b) Is it possible to use a CAS to show that the antiderivative obtained
in part (a) diﬀers by at most a constant from the one given by the
integral table?
24 1. Introduction to Computer Algebra
6. Consider the six equations with six unknowns {x1,x2,y1,y2,z1,z2}:
a=m1x1+m2x2
m1+m2,
b=m1y1+m2y2
m1+m2,
c=m1z1+m2z2
m1+m2,
rsin(θ)cos(φ)= x1−x2,
rsin(θ)sin(φ)= y1−y2,
rcos(θ)= z1−z2.
Solve these equations with a CAS. Do you expect the solution to simplify
to expressions of reasonable size?
7. Use a CAS to help ﬁnd the exact value of the bounded area between the
curves
u=2x−1
x+2
x2,
v=x+2.
Assume that x>0.
8. (a) Consider the equation x3−a2x2+(a+3)x−a=0 .U s eaC A St o
ﬁndareal valuefor asothattheequation hasoneroot of multiplicity
2 and one of multiplicity 1. Hint:At a root x0of multiplicity 2, both
the polynomial and its derivative evaluate to 0.
(b) Consider the equation x3+ax2+a2x+a3=0 . F o r a=0t h e
equation has the root x= 0 with multiplicity 3. Use a CAS to show
that it is impossible to ﬁnd an aso that the equation has one root of
multiplicity 2 and one of multiplicity 1.
9. Giveageneralformulaforthe nthderivativeoftheproductoftwofunctions
f(x)a n dg(x). A CAS can be useful for this problem. Use a CAS to ﬁnd
thenth derivative of the product f(x)g(x)f o rn=1,2,3,4. Use this
data to ﬁnd a general expression for the pattern youobserve.
10. In each of the following manipulations we ostensibly show that 1 = −1.
What is the fallacy in the reasoning in each case?
(a) 1 =√
1=√
ı4=ı2=−1w h e r e ı=√
−1.
(b) 1 =√
1=
(−1)(−1) =√
−1√
−1=ı2=−1.
11. Inthefollowingmanipulationsweostensiblyshowthateverycomplexnum-
ber is real and positive. Let z=reıθbe a complex number in the polar
representation where r>0. Certainly, if θ=0 ,t h e n z=rwhich is real
and positive. If θ/negationslash=0 ,the nf o r α=eıθ,
α2π/θ=Q
eıθw2π/θ
=e2πı=c o s(2 π)+ısin(2π)=1.
1.2. Applications of Computer Algebra 25
Therefore,
α=Q
α2π/θwθ/(2π)
=1θ/(2π)=1.
Therefore z=rwhich is real and positive. What is wrong with our rea-
soning?
12. Consider the following sequence of steps that ostensibly shows that 2=1.
Let
a=b. (1.12)
Then
a2=ab,
a2−b2=ab−b2,
(a+b)(a−b)= b(a−b),
a+b=b.
SubstitutingEquation ( 1.12) intothis last expression we obtain 2 b=band
so 2 = 1. What is the fallacy in the reasoning?
13. Consider the indeﬁnite integral
dx
xln(x).
To evaluate this integral we use the integration by parts formula	
ud v=
uv−	
vd uwithu=1/ln(x)a n ddv=dx/xand obtain
dx
xln(x)=1+dx
xln(x).
Subtracting the integral from both side of this equation we obtain 0 = 1.
What is wrong with our reasoning?
14. Consider the system equations
(x2+y2+x)2=9 ( x2+y2), (1.13)
x2+y2=1. (1.14)
(a) Solve this system of equations for xandywith a CAS.
(b) Let’strytosolvethissystemofequationsusingsymbolmanipulation.
Substituting Equation ( 1.14)i n(1.13)w eh a v e( x+1 )2=9a n d
sox=2,−4. Substituting x=2i n(1.13)w eo b t a i na f t e rs o m e
manipulation y2(y2+3)=0 which has the real root y= 0. However,
x=2,y= 0isnotobtainedbyaCASasasolutionofEquation( 1.14).
What is the fallacy in our reasoning?
26 1. Introduction to Computer Algebra
Further Reading
1.1Computer Algebra and Computer Algebra Systems. Kline [54]g i v e s
an interesting discussion of the use of mathematics to discover new knowledge
about the physical world.
Additional information on computer algebra can be found in Akritas [ 2],
Buchberger et al. [ 17], Davenport, Siret, and Tournier [ 29], Geddes, Czapor, and
Labahn [39], Lipson [ 64], Mignotte [ 66], Mignotte and S ¸tef˘anescu[67], Mishra
[68], von zur Gathen and Gerhard [ 96], Wester [ 100], Winkler [ 101], Yap [105],
and Zippel [ 108]. Two older (butinteresting) discussions of computeralgebra are
found in Pavelle, Rothstein, and Fitch [ 77] and Yun and Stoutemyer [ 107].
Simon ([90]and[89]) and Wester [ 100] (Chapter3) give acomparison of com-
mercialcomputeralgebrasoftware. Comparisonsofcomputeralgebrasystemsare
also found at
http://math.unm.edu/~wester/cas_review.html .
Information about computer algebra and computer algebra systems can be
found at the following Internet sites.
•SymbolicNet:
http://www.SymbolicNet.org .
•Computer Algebra Information Network (CAIN):
http://www.riaca.win.tue.nl/CAN/ .
•COMPUTER ALGEBRA, Algorithms, Systems and Applications:
http://www-troja.fjfi.cvut.cz/~liska/ca/ .
•sci.math.symbolic discussion site:
http://mathforum.org/discussions/about/sci.math.symbolic.html
The Association for Computing Machinery (ACM) has a Special Interest
GrouponSymbolicandAlgebraicManipulation(SIGSAM) .This grouppublishes
a quarterly journal the SIGSAMBulletin which provides a forum for exchanging
ideas about computer algebra. In addition, SIGSAM sponsors an annual con-
ference, the International Symposium on Symbolic and Algebraic Computation
(ISSAC). Information about SIGSAM can be found at the Internet site
http://www.acm.org/sigsam .
The main research journal in computer algebra is the Journal of Symbolic
Computation published by Academic Press. Information about this journal can
be found at
http://www.academicpress.com/jsc .
1.2. Applications of Computer Algebra 27
Computers have also been used to prove theorems. See Chou [ 20] for an
introduction to computer theorem proving in Euclidean geometry.
Computers have even been used to generate mathematical conjectures or
statementswhich haveahigh probability ofbeingtrue. SeeCipra[ 21]for details.
Therehasalsobeensomeworktouseartiﬁcialintelligencesymbolicprograms
to help interpret the results of numerical computer experiments and even to
suggest which experiments should be done. See Kowalik [ 58] for the details.
See Kajler [ 51] for a discussion of research issues in human-computer inter-
action in symbolic computation.
1.2Applications ofComputer Algebra. The article by Nowlan [ 76]h a sa
discussion of the consequences a purely mechanical approach to mathematics.
Stoutemyer [ 94], which describes some problems that arise with CAS software,
should be required reading for any user of this software.
Bernardin (see [ 7]o r[8]) compares the capability to solve equations for six
computer algebra systems. Some of the equations in Exercise 2on page22are
from these references.
Exercise11on page24is fromThe College Mathematics Journal , Vol. 27,
No. 4, Sept. 1996, p. 283. This journal occasionally has examples of faultysymbolic manipulation in its section Fallacies,Flaws, andFlimﬂam. See
http://www.maa.org/pubs/cmj.html .

2
Elementary Concepts of
Computer Algebra
In this chapter we introduce a language that is used throughout the book
to describe the concepts, examples, and algorithms of computer algebra.The language is called mathematical pseudo-language or simply MPL. In
Sections 2.1and2.2we describe the form of an MPL mathematical ex-
pression and discuss what happens to an expression during the evaluation
process. In Section 2.3we consider elementary MPL programs and give
a case study that illustrates the concept. Finally, in Section 2.4we de-
scribe MPL lists and sets, which are two ways to represent collections of
mathematical expressions.
2.1 Mathematical Pseudo-language (MPL)
Mathematical pseudo-language (MPL) is a symbolic language that is used
in this book to describe the concepts, examples, and algorithms of com-
puter algebra. The term pseudo-language is used to emphasize that MPL
is not a real CAS language that has been implemented on a computer.
Although MPL is similar in spirit to real computer algebra languages, it
is less formal and utilizes both mathematical symbolism and ordinary En-glish when appropriate. The reader should have little diﬃculty following
discussions in MPL.
The reader may wonder, why introduce another algorithmic language?
Why not use the programming language associated with a particular CAS?
29
30 2. Elementary Concepts of Computer Algebra
One reason has to do with the current state of language and system de-
velopment in the computer algebra ﬁeld. There is now a proliferation of
computer algebra systems, and, undoubtedly, there will be new ones in
the future. Each system has its strong points and limitations, and its ownfollowing among members of the technical community. The systems are
distinguished from each other by the nature of the mathematical knowl-
edge encoded in the system and the language facilities that are availableto access and extend this knowledge. However, at the basic level, there are
more similarities than diﬀerences, and the organization of mathematical
concepts and language structures do not diﬀer signiﬁcantly from system to
system. By using a generic pseudo-language we are able to emphasize the
concepts and algorithms of symbolic computation without being conﬁnedby the details, quirks, and limitations of a particular language.
Perhaps the most important role for MPL is that it provides a way to
evaluate and compare computer algebra systems and languages. In fact,
a useful approach to this chapter is to read it with one or more computeralgebra systems at your side and, as MPL concepts and operations are
described, implement them in real software. Although you will ﬁnd that
MPL’s style is similar to real software, you will also ﬁnd diﬀerences be-tween it and real languages, and especially subtle diﬀerences between the
languages themselves.
Mathematical Expressions in MPL
To use a computer algebra system eﬀectively, it is important to have a
clear understanding of both the structure and meaning of mathematicalexpressions. Since there is much to say about this subject, mathematical
expressions will occupy much of our attention in this chapter and Chapter
3. In Chapter 4we introduce other elements of the MPL language.
Let’s begin by looking at the various forms an MPL expression can have.
Roughly speaking, MPL expressions are similar to those found in ordinary
mathematical symbolism with some allowance made to accommodate the
need for more precision in a computational environment. MPL expressions
are constructed using the following symbols and operators:
Integers and fractions. Software that performs the exact manipula-
tion of mathematical expressions must have the capability to perform exactarithmetic. Real ﬂoating point arithmetic, which is used by conventional
programming languages for purely numerical work, involves round-oﬀ er-
ror and is not appropriate for most computer algebra computation. Indeed,
even the small numerical errors that are inevitable with ﬂoating point arith-
metic can alter the mathematical properties of an expression. To illustrate
2.1. Mathematical Pseudo-language (MPL) 31
this point, consider the following two expressions which are identical except
for a small change in one coeﬃcient:
f=x2−1
x−1,g=x2−.99
x−1.
Although the numerical values of fandgare nearly the same for most
values ofx, the mathematical properties of the two expressions are diﬀerent.
First of all, fsimpliﬁes to the polynomial x+1w h e n x/negationslash= 1 while gdoes
not. Consequently, their antiderivatives diﬀer by a logarithmic term:
/integraldisplay
fd x =x2/2+x+C, x /negationslash=1,
/integraldisplay
gd x =x2/2+x+.01ln(x−1) +C, x /negationslash=1.
Furthermore, the graph of ghas an asymptote at x= 1, while fis simply
undeﬁned at x=1 .
To avoid these discrepancies, MPL utilizes exact arbitrary precision ra-
tional number arithmetic for most numerical computations rather than ap-
proximate ﬂoating point arithmetic. The term arbitrary precision means
an integer or fraction can have an arbitrary number of digits. Examplesinclude
2/3,−1/4,123456789 /987654321 ,2432902008176640000 .
Arithmetic calculations are performed using the ordinary rules for rational
number arithmetic.
All computer algebra systems utilize this type of arithmetic, however,
because a computer is a ﬁnite machine, there is a maximum number of
digits permitted in a number. This bound is usually quite large and rarely
a limitation in applications.
Realnumbers. In MPL, a real number is one that has a ﬁnite number
of digits, includes a decimal point, and may include an optional power of
10. Examples include
467.22,.33333333,6.02·10
23. (2.1)
Real number arithmetic is similar to real ﬂoating point arithmetic in a
conventional programming language. Since this mode of computation may
involve round-oﬀ error, it is, in general, inexact. Most computer algebra
systems support real numbers, and some systems allow for choice of nu-
merical precision.
32 2. Elementary Concepts of Computer Algebra
The deﬁnition of an MPL real number should not be confused with the
mathematical concept of a real number. Since all MPL real numbers have
a ﬁnite number of digits, they are really rational numbers in the mathe-
matical sense. In mathematics, a real number that is not rational is calledanirrational number . For example,√
2,π,a n deare irrational numbers,
and it is hard to imagine doing symbolic computation without them. Since
irrational numbers require an inﬁnite decimal representation which is notpossible in a computational setting, they are represented instead using re-
served symbols ( e,π), algebraic expressions (2 ∧(1/2)), or function forms
(ln(2)), all of which are described below.
Identiﬁers .InM P L ,a n identiﬁer is a string of characters constructed
with English letters, Greek letters, the digits 0 ,1,...,9, and the underscore
symbol “
”. An identiﬁer begins with an English or Greek letter. The
following are examples of MPL identiﬁers:
x, y1, α, general
 solution, ∆x.
Identiﬁers are used in MPL as programming variables that represent the re-
sult of a computation, as function, operator, or procedure names, as mathe-
matical symbols that represent indeterminates (or variables) in a mathemat-
ical expression, and as reserved symbols. All computer algebra languages
use identiﬁers in this way although the characters allowed in an identiﬁername vary from system to system.
Algebraic operators and parentheses . The algebraic operators in
MPL are listed in Figure 2.1. Parentheses are used as they are in math-
ematics to alter the structure of an expression. Examples of expressionsthat include the operators, numbers, and identiﬁers described so far are
(n−m)!,x∧2−5∗x+6,((x+∆x)∧2−x∧2)/∆x.
Mathematical Operation
 MPL Operator
addition, subtraction
 +,−
multiplication, division
 ∗,/
power
 ∧
factorial
 !
Figure 2.1. Algebraic operators in MPL.
Reservedsymbols. Areserved symbol is an identiﬁer or other mathe-
matical symbol that has mathematical meaning. In MPL, the reserved sym-
bols include π,e,ı(for√
−1),∞, and the logical constants trueandfalse.
2.1. Mathematical Pseudo-language (MPL) 33
MPL
 Maple
 Mathematica
 MuPAD
π
 Pi
 Pi
 PI
e
 exp(1)
 E
 E
ı
 I
 I
 I
∞
 infinity
 Infinity
 infinity
true
 true
 True
 TRUE
false
 false
 False
 FALSE
Figure 2.2. MPL reserved symbols in Maple, Mathematica, and MuPAD.
A few more reserved symbols are introduced in later sections. The corre-
sponding reserved symbols in three computer algebra systems are given in
Figure 2.2.
In a CAS, reserved symbols acquire mathematical meaning through the
actions of the transformation rules encoded in the system. For example,most computer algebra systems recognize the simpliﬁcations
sin(π/2)→1, (2.2)
arctan(1) →π/4, (2.3)
ln(e∧2)→2, (2.4)
ı∧2→− 1,
e∧(−ı∗π)→− 1
as either part of the evaluation process or the output of a simpliﬁcation
operator. (Implementation: Maple (mws), Mathematica (nb),MuPAD
(mnb).)
Function forms. In MPL, function forms are used for mathemat-
ical functions (sin( x), exp(x), arctan( x), etc.), mathematical operators
(Expand (u),Factor (u),Integral (u,x),etc.), and undeﬁned functions ( f(x),
g(x,y), etc.).
In a CAS, mathematical functions acquire meaning through the ac-
tions of transformation rules encoded in the system. For example, most
computer algebra systems obtain function transformations similar to thesimpliﬁcations ( 2.2), (2.3), and ( 2.4)a b o v e .
Function forms that manipulate and analyze mathematical expressions
are called mathematical operators . Although computer algebra systems
contain hundreds of mathematical operators, we use only a small number
of them in this book. Figure 2.3gives some of the MPL operators used in
the examples, algorithms, and exercises in this chapter, and Figure 2.4
34 2. Elementary Concepts of Computer Algebra
Mathematical
 MPL
 Example
Operation
 Operator
Absolute value, |u|
Absolute
 value (u)
Absolute
 value (−2)→2
Evaluate rational
 Decimal (u)
 Decimal (1/4)→.25
numbers, arithmetic
 Decimal (x+1/4)→x+.25
operations, and
 Decimal (sin(2) + 1 /2)→1.409297
numerical functions
in an expression u
to a real value
Substitution
 Substitute (u,t=r)
Substitute (2∗x+1,x=b+1 )
inuof each
 →2(b+1 )+1
occurrence of t
byr
ith operand in
 Operand (u,i)
 Operand (a+b+c,2)→b
an expression u
 Operand ({a,b,c},3)→c
Operand (a=b,2)→b
Degree in x
 Degree (u,x)
Degree (x∧2+5 ∗x+7,x)
of a polynomial
 →2
expression u
Coeﬃcient of
 Coeﬃcient (u,x,j )
Coeﬃcient (x∧2+5 ∗x+7,x , 1)
xjin a
 →5
polynomial
expression u
Algebraic
 Algebraic
 expand (u)
Algebraic
 expand (
expansion
 (x+2 )∗(x+3 ) )
→x2+5∗x+6
Polynomial
 Factor (u)
 Factor (x∧2+5 ∗x+6 )
factorization
 →(x+2 )(x+3 )
Solution of
 Solve (u,x)
 Solve (a∗x=b,x)
an equation
 →x=b/a
uforx
or a set of
 Solve ({u1,...,u n},
Solve (
equations
 {x1,...,x n})
{2∗x+4∗y=3,3∗x−y=7},
for a set of
 {x,y})
variables
 →{x=3 1/14,y=−5/14}
lim
x→au
 Limit (u,x,a )
Limit (1/x,x, ∞)→0
du
dx
Derivative (u,x)
Derivative (sin(x),x)→cos(x)
	ud x
 Integral (u,x)
Integral (cos(x),x)→sin(x)
Solution of
 Solve
ode(u,x,y )
Solve
ode(
a diﬀerential
 Derivative (y(x),x)=y(x),x,y)
equation u
 →C∗exp(x)
fory(x)
Figure 2.3. Some mathematical operators in MPL. In column 3, the expression
to the right of the evaluation symbol →is the result obtained by evaluating the
operator. The corresponding operators in three computer algebra systems are
giving in Figure 2.4.
2.1. Mathematical Pseudo-language (MPL) 35
MPL
 Maple
 Mathematica
 MuPAD
Absolute
 value (u)
 abs(u)
 Abs[u]
 abs(u)
Decimal (u)
 evalf(u)
 u//N
 float(u)
Substitute (u,t=r)
 subs(t=r,u)
 ReplaceAll[u,t->r]
 subs(u,t=r)
Operand (u,i)
 op(i,u)
 Part[u,i]
 op(u,i)
Degree (u,x)
 degree(u,x)
 Exponent[u,x]
 degree(u,x)
Coeﬃcient (u,x,j )
 coeff(u,x,j)
 Coefficient[u,x,j]
 coeff(u,x,j)
Algebraic
 expand (u)
 expand(u)
 Expand[u]
 expand(u)
Factor (u)
 factor(u)
 Factor[u]
 expr(factor(u))
Solve (u,x)
 solve(u,x)
 Solve[u,x]
 solve(u,x)
Limit (u,x,a )
 limit(u,x=a)
 Limit[u,x->a]
 limit(u,x,a)
Derivative (u,x)
 diff(u,x)
 D[u,x]
 diff(u,x)
Integral (u,x)
 int(u,x)
 Integrate[u,x]
 int(u,x)
Solve
ode(u,x,y )
dsolve(u,y(x))
 DSolve[u,y[x],x]
 solve(ode(u,y(x)))
Figure 2.4. Theoperators in theMaple, MuPAD,andMathematica systemsthat
correspond most closely to the MPL operators in Figure 2.3. (Implementation:
Maple(mws),Mathematica (nb),MuPAD(mnb).)
gives the operators in the Maple, Mathematica, and MuPAD systems that
correspond most closely to these operators.
Another important function form is the undeﬁned function which is an
expression in function notation (e.g., f(x),g(x,y),h(n+ 1)), where the
function is undeﬁned. In a computational setting this means there are no
transformation rules or other properties associated with the function be-
yond the implied dependence of the function name on the expressions in
parentheses. In ordinary mathematical notation, dependency relationshipsof this sort are usually understood from context. In the computational set-
ting, however, more precision is required, and undeﬁned functions provide
one way to represent this dependency.
One use of undeﬁned functions is in expressions that involve arbitrary
or unknown functions. For example, in the diﬀerentiation
Derivative (f(x)∗g(x),x)→df(x)
dxg(x)+f(x)dg(x)
dx,
MPL’s Derivative operator uses the dependency information to obtain a
general form of the product rule. Without this information, the Derivative
operator assumes that fandgdo not depend on x,a n ds o Derivative (f∗
g,x) evaluates to 0.
All computer algebra systems use function forms in the three ways
described above. In Figure 2.5, we give a Mathematica dialogue which
obtains the solution of the diﬀerential equation
dy
dx+y=x+e x p ( −2x) (2.5)
36 2. Elementary Concepts of Computer Algebra
In[1]: = u=D[y[x],x]+y[x]= = x+Exp[−2∗x]
Out[1] = y[x] + y/prime[x] == e−2x+x
In[2]: = DSolve [u,y[x],x]
Out[2]={{y[x]→e−x(−e−x+ex(−1+x ) )+e−xC[1]}}
Figure 2.5. A Mathematica dialogue which obtains the solution of a diﬀerential
equation. The Mathematica language uses the brackets [ and ] to representfunction forms. (Implementation: Maple(mws),Mathematica (nb),MuPAD
(mnb).)
which illustrates this point. At the ﬁrst prompt In[1], we enter the diﬀer-
ential equation using the function notation y[x]to represent the depen-
dency ofyonx,a n da t Out[1] , the system returns an expression where the
derivative is represented in symbolic form as y/prime[x]. At In[2],w ee n t e rt h e
command to solve the diﬀerential equation and obtain the general solution
inOut[2] . Observe that Mathematica represents the arbitrary constant in
the solution by C[1].
Relational operators and expressions. In MPL, a relational ex-
pression is one that expresses a relationship between two expressions using
one of the relational operators
=,/negationslash=,< , ≤,> , ≥.
Examples include x∧2+2 ∗x−1=0 ,i<n,a n d∆p∗∆x≥h.
Logical operators and expressions. An MPL logical expression is
one constructed using logical constants ( trueandfalse), relational expres-
sions, and identiﬁers combined together with one or more of the logical
operatorsand,or,a n dnot. As with algebraic expressions, parentheses
are used to alter the structure of an expression. Examples include
(trueandfalse )ortrue,not(pandq),0≤xandx≤1.
All computer algebra languages provide relational and logical expressions
(see Figure 2.6) although their roles in the languages vary from system to
system1
1We return to this point in Section 3.2(see pages 97-99).
2.1. Mathematical Pseudo-language (MPL) 37
MPL
Maple
Mathematica
 MuPAD
true
 true
 True
 TRUE
false
 false
 False
 FALSE
=
 =
 ==or===
 =
/negationslash=
 <>
 !=or=!=
 <>
<
 <
 <
 <
≤
 <=
 <=
 <=
>
 >
 >
 >
≥
 >=
 >=
 >=
and
 and
 &&
 and
or
 or
 ||
 or
not
 not
 !
 not
Figure 2.6. Relational operators, logical constants, and logical operators in
Maple, Mathematica, and MuPAD.
Sets and lists. InM P L ,b o t hs e t sa n dl i s t sa r eu s e dt or e p r e s e n t
collections of mathematical expressions. A set is expressed using the braces{and}and a list using the brackets [ and ]. Examples include
{2∗x+4∗y=3,3∗x−y=7},[1,x ,x ∧2,x∧3].
In MPL, a set or a list is considered a mathematical expression rather than
a data structure that contains mathematical expressions
2.In f a c t , a s e t
or a list can be a sub-expression of another mathematical expression. For
example, the expression
Solve({2∗x+4∗y=3,3∗x−y=7},{x,y})
which contains sets, is used to obtain the solution of a system of linear equa-
tions. Although both sets and lists are used for collections of expressions,they have diﬀerent mathematical properties and are used in diﬀerent ways
in our examples and algorithms. In Section 2.4, we discuss these diﬀerences
and describe the operations that are appropriate for each of them.
Most computer algebra languages provide lists and sets.
MPLmathematical expressions . An MPL mathematical expres-
sion is any valid mathematical expression that is formed using integers,
fractions, real numbers, identiﬁers, reserved symbols, function forms, sets,lists, and the algebraic, relational and logical operators described above.
(A few additional operators are introduced in later sections.) For our pur-
poses, any expression with appropriate operands for each operator and
2A data structure is a programming language structure that is used to organize data.
An array is an example of a data structure.
38 2. Elementary Concepts of Computer Algebra
balanced parentheses is valid. For example, {a,b,c}∗yis not valid because
the ﬁrst operand of ∗is not appropriate. The expression ( a+b)∗c)i sn o t
valid because there is a dangling right parenthesis.
Although this description of mathematical expressions is suﬃcient for
our purposes, a theoretician would rightfully complain that we haven’t
given a deﬁnition at all since the word validis not precisely deﬁned. A
more formal deﬁnition would include a set of syntax orgrammar rules that
deﬁne when a sequence of symbols is a valid expression in our language.The syntax rules would tell us, for example, that the expression m∗x+b
is a valid expression, while ( a+b)∗c)i sn o t .
The syntax rules for expressions are quite involved, even for expressions
as simple as those considered here. A precise listing of the rules is essential
for the designer of a computer algebra system, who must determine which
expressions are valid statements in a language. The syntax rules are en-
coded in a program called a parser that determines if an input expression is
a valid expression in the language, determines its structure, and translates
it into an internal form that is used by the CAS to manipulate and analyze
the expression. The structure of an expression involves the relationships
between the operators and operands that make up the expression. For ex-
ample, the expression m∗x+bhas the structure of a sum with operands
m∗xandbrather than a product with operands mandx+b.
Although syntax rules and parsing algorithms are important topics for
system design, they are not essential to the understanding of computer
algebra and are not addressed in this book. On the other hand, since
an understanding of expression structure is essential for computer algebraprogramming, we examine this topic in detail in Chapter 3.
Variable Initialization and Assignment
In MPL (as in a CAS), all variables are initially undeﬁned symbols. This
assumption allows a variable to fulﬁll its traditional role as an indetermi-
nate symbol in a mathematical expression.
A variable that is used in the programming sense to represent the result
of a computation is given a value with an assignment statement. In MPL,
the assignment operator is a colon followed by an equal sign (:=), and anassignment statement has the form:
variable := mathematical expression.
An assignment statement causes two actions to occur. First, the expression
to the right of the assignment symbol is evaluated giving a new expression.
2.1. Mathematical Pseudo-language (MPL) 39
Next, this new expression is assigned to the variable to the left of the
assignment symbol. For example in
y:=Factor (x∧2+5 ∗x+6 )
the right side evaluates to ( x+2)∗(x+3), which is assigned to the variable
y. In future manipulations, this expression is the value of y.
All computer algebra languages provide assignment statements that
operate in this way3.
Role of Mathematical Expressions in MPL
One aspect of computer algebra programming that distinguishes it fromconventional programming is the role of mathematical expressions. In
MPL, mathematical expressions have two (somewhat overlapping) roles
as either program statements that represent a computational step in a pro-
gram or as data objects that are processed by program statements. For
example, suppose xis an unassigned variable and consider the statement
f:=x∧2+5 ∗x+6. (2.6)
In this statement the polynomial expression which is assigned to fis a data
object that can be manipulated or analyzed by other program statements.
On the other hand, in
g:=Substitute (Derivative (f,x),x=c)∗(x−c)
+Substitute (f,x=c), (2.7)
the expression to the right of the assignment operator is a program state-
ment that obtains the formula for the tangent line to fatx=c, and assigns
the result to the variable g. For example, if cis assigned the expression
1/2a n dfis given by the statement ( 2.6), thengis assigned the new data
object, the expression 6 ∗(x−1/2) + 35/4.
Although this description of the role of expressions is useful for empha-
sizing their dual nature, the distinction should not be taken too literally.Indeed, the role of an expression can depend on other actions that have oc-
curred in a computation. For example, in Statement ( 2.6), the polynomial
is a data object as long as xhas not been assigned. On the other hand,
ifxhas been assigned the integer 3, the polynomial in Statement ( 2.6)
can be viewed as a program statement which upon evaluation obtains the
expression 30 which is then assigned to f.
3In Maple and MuPAD, the assignment symbol is the colon followed by the equal
sign ( :=); in Mathematica, the assignment symbol is the equal sign ( =).
40 2. Elementary Concepts of Computer Algebra
<1>Algebraic
expand((x+2)2∗(x+3));
→ x3+7x2+16x+12
<2>Factor(2∗x3+7∗x2∗y+4∗x2+14∗x∗y+18∗x+63∗y);
→(x2+2x+9)(2 x+7y)
<3>Integral(x∗sin(x),x);
→sin(x)−xcos(x)
Figure 2.7. An MPL dialogue. (Implementation: Maple(mws),Mathematica
(nb),MuPAD(mnb).)
Most computer algebra languages employ expressions as both program
statements and data objects, although a language may restrict the use of
some expression types to certain contexts4.
MPL Dialogues
An MPL dialogue which mimics the interactive dialogues found in real
computer algebra systems is given in Figure 2.7. In this simulation, the
prompt is represented by a positive integer surrounded by the symbols <
and>and the mathematical expression following each prompt represents
an input to our imaginary system. Following the practice in some computer
algebra systems, each input statement is terminated by a semicolon5.T h e
arrow “ →” to the left of the centered expressions means “evaluates to” and
indicates the result of evaluating the preceding input expression.
MPL Notation versus Ordinary Mathematical Notation
The notation for MPL expressions closely resembles the notation used forinput expressions in most computer algebra systems. However, as withmost programming notations, it is notoriously unreadable for large ex-
pressions. On the other hand, ordinary mathematical notation, which is
4The Maple, Mathematica and MuPAD systems allow all the expressions described
here both as program statements and data objects. On the other hand, the Macsyma
system does not permit some logical expressions as data objects. For example, thelogical expression p and q ,w i t h pand qundeﬁned symbols, cannot be entered in the
interactive mode in that system.
5The Mathematica system does not require a termination symbol at the end of an
expression. Most systems allow a choice of terminating symbol to provide an option todisplay or not display a result.
2.1. Mathematical Pseudo-language (MPL) 41
far more understandable, lacks the precision of MPL notation and is un-
suitable in some computational contexts. Since there is clearly a place for
both notations, we adopt the following strategy for using and intermingling
the two:
•We usually use MPL notation for input to MPL dialogues and for
statements, procedures, and examples that involve manipulations ina computational context. However, in some of these situations, MPL
notation is unwieldy and for clarity we resort to ordinary mathemati-
cal notation. For example, in the MPL dialogue in Figure 2.7,w eu s e
raised exponents for powers in the inputs <2>and<3>instead of
using the ∧operator.
•We usually use ordinary mathematical notation in theorems, exam-
ples, and discussions that are not in a computational context. In
addition, since most computer algebra systems display output in aform similar to ordinary mathematical notation, we use this form for
output in MPL dialogues as well (see Figure 2.7). There are, however,
some instances where the conciseness of MPL notation invites its use
in purely mathematical contexts.
We assume the reader can readily translate between the two notations.
Translating Mathematical Discourse into MPL
We conclude this section with an example that shows how a sequence of
operations in ordinary mathematical discourse is translated into a sequence
of statements in MPL.
Example 2.1. Consider the following equation which deﬁnes yimplicitly as
a function of x:
exp(x)+y4=4x2+y. (2.8)
Let’s consider the manipulations that are used to compute implicitly the
derivatives
dy
dxandd2y
dx2.
First, diﬀerentiating both sides of Equation ( 2.8) with respect to x,w eh a v e
exp(x)+4y3dy
dx=8x+dy
dx. (2.9)
Solving fordy
dx,w eo b t a i n
dy
dx=−exp(x)+8x
4y3−1. (2.10)
42 2. Elementary Concepts of Computer Algebra
To obtain the second derivative, we diﬀerentiate this expression
d2y
dx2=−exp(x)+8
4y3−1−12(−exp(x)+8x)y2dy
dx
(4y3−1)2, (2.11)
and then substitute the right side of Equation ( 2.10)f o rdy
dxto obtain
d2y
dx2=−exp(x)+8
4y3−1−12(−exp(x)+8x)2y2
(4y3−1)3. (2.12)
Let’s consider now the MPL operations that produce the manipulations
in Equations ( 2.8) through ( 2.12). Three operations are required: diﬀer-
entiations in ( 2.9)a n d( 2.11), a solution of a linear equation in ( 2.9), and
a substitution in ( 2.12). These manipulations are readily translated into
a sequence of statements in MPL (see Figure 2.8). We begin at <1>by
assigning Equation ( 2.8)t ou, where an undeﬁned function y(x)i su s e d
to represent the dependence of yonx. At statement <2>,w eu s et h e
Derivative operator to diﬀerentiate both sides of uand assign this result
<1>u:= exp( x)+y(x)4=4x2+y(x);
→exp(x)+y(x)4=4x2+y(x)
<2>v:=Derivative (u, x);
→exp(x)+4y(x)3dy(x)
dx=8x+dy(x)
dx
<3>First
derivative :=Solve(v,Derivative (y(x),x));
→dy(x)
dx=−exp(x)+8x
4y(x)3−1
<4>w:=Derivative (First
derivative ,x);
→d2y(x)
dx2=−exp(x)+8
4y(x)3−1−12(−exp(x)+8x)y(x)2dy(x)
dx
(4y(x)3−1)2
<5>Second
 derivative :=Substitute (w,First
derivative );
→d2y(x)
dx2=−exp(x)+8
4y(x)3−1−12(−exp(x)+8x)2y(x)2
(4y(x)3−1)3
Figure 2.8. The MPL manipulations that correspond to Equations ( 2.8) through
(2.12).
2.1. Mathematical Pseudo-language (MPL) 43
tov.A t<3>,w eu s et h e Solveoperator to solve the equation vfor the
expression
dy(x)
dx
and assign this result to First
 derivative . To obtain the second derivative,
at<4>we apply the Derivative operator to both sides of First
 derivative
and assign this result to w. Finally, at <5>we use the Substitute operator
to apply the substitution deﬁned by First
 derivative towand assign this
result to Second
 derivative . /square
Interactive Dialogues with Real Computer Algebra Systems
MPL provides a way to express a sequence of symbolic calculations in a
form that resembles the statements and operations in a real CAS. Although
the MPL dialogues indicate in a general way the sequence of manipulations
needed for a calculation, we caution the reader not to take the input state-
ments and outputs in the dialogues too literally. The actual implementation
of a dialogue in a real CAS language will vary from system to system.
To illustrate this point, we implement the MPL dialogue in Figure 2.8
in the Maple, Mathematica, MuPAD languages (see Figures 2.9,2.10,a n d
2.11). These dialogues use each system’s versions of MPL’s Derivative ,
Solve,a n d Substitute operators along with each system’s version of MPL’s
selection operator Operand (u,i) which returns the ith operand of the ex-
pressionu. For example, this operator obtains
Operand (a+b+c,2)→b,
Operand ({a,b,c},3)→c,
Operand (a=b,2)→b.
Although this operator was not needed in the MPL dialogue, it is re-
quired to handle the various forms of the input and output of the Solve
andSubstitute operators in a real CAS.
Maple
The Maple implementation of Figure 2.8is given in Figure 2.9.T h es t a t e -
ments at the ﬁrst two prompts are similar to those in the MPL dialogue,
although Maple displays the results as assignments and displays the deriva-
tive with partial derivative notation. At the third prompt, Maple solves
44 2. Elementary Concepts of Computer Algebra
> u := exp(x)+y(x)^4=4*x^2+y(x);
u:=ex+y (x)4=4x2+y (x)
> v := diff(u,x);
v:=ex+4y (x)3W∂
∂xy(x)}
=8x+W∂
∂xy(x)}
> d := solve(v,diff(y(x),x));
d:=−ex+8x
4y (x)3−1
> First_derivative := diff(y(x),x) = d;
First
derivative :=∂
∂xy(x)=−ex+8x
4y(x)3−1
> w := diff(First_derivative,x);
w:=∂2
∂x2y(x)=−ex+8
4y (x)3−1−12 (−ex+8x)y (x)2(∂
∂xy(x))
(4 y(x)3−1)2
> subs(First_derivative,w);
∂
∂x−ex+8x
4y (x)3−1=−ex+8
4y (x)3−1−12 (−ex+8x)2y(x)2
(4 y(x)3−1)3
> Second_derivative := diff(y(x),x,x) = subs(First_derivative,op(2,w));
Second
 derivative :=∂2
∂x2y(x)=−ex+8
4y (x)3−1−12 (−ex+8x)2y(x)2
(4 y(x)3−1)3
Figure 2.9. A Maple implementation of the MPL dialogue in Figure 2.8.( I m p l e -
mentation: Maple(mws).)
the equation vfordiff(y(x),x) , where the solution is returned as an
expression
−ex+8x
4y(x)3−1, (2.13)
rather than, as in the MPL dialogue, as an equation with the derivative
symbol on the left side. We compensate for this at the fourth prompt by
entering an equation with the derivative symbol on the left side. At the
ﬁfth prompt, we diﬀerentiate both sides of the equation First
 derivative ,
2.1. Mathematical Pseudo-language (MPL) 45
and at the sixth prompt apply Maple’s subscommand to substitute Ex-
pression ( 2.13) for the ﬁrst derivative symbol in the previous expression.
Unfortunately, we get a little more than we bargained for, since the left side
of the equation is returned as a ﬁrst derivative symbol applied to an ex-pression rather than as a second derivative symbol. The reason for this has
to do with Maple’s internal representation of the second derivative symbol
as nested ﬁrst derivatives
∂
∂x/parenleftbigg∂
∂xy(x)/parenrightbigg
.
Since Maple’s subsoperator replaces all occurrences of the ﬁrst derivative
symbol with Expression ( 2.13), we obtain the result shown in the dialogue.
Finally, at the seventh prompt, we compensate for this by using Maple’soperator op(which selects operands of an expression) to select the right
side of wand by applying the subsoperator to the resulting expression.
In addition, to obtain the MPL result, we include the second derivativesymbol on the left side of an equation.
Mathematica
The Mathematica implementation of Figure 2.8is given in Figure 2.10.T h e
statements at In[1]a n d In[2] are similar to those in the MPL dialogue.
Observe that Mathematica uses the equal sign ( =) for assignment, two
equal signs ( ==) for an equal sign in an equation, and the Doperator for
diﬀerentiation. At In[3], Mathematica’s Solve operator is used to solve
the equation vfor the derivative, where the result is returned as a set which
contains another set which contains the solution. The expression
y/prime[x]→−ex+8x
−1+4y[x]3, (2.14)
which is known as a transformation rule in the Mathematica language, is
the form Mathematica uses for the substitution operation later in the dia-
logue. However, if we insist that the solution be displayed as an equation,
we can obtain this form by using Mathematica’s Partoperator which selects
operands of an expression. At In[4], the expression Part[s,1] removes
the outer set braces, the next Partoperation removes the inner set braces,
and the outer Partoperation selects the right side of Expression ( 2.14).
We obtain the desired form by entering an equation with the derivative
symbol on the left side and then assign the result to FirstDerivative6.
6Since the underscore character (
 ) has special meaning in Mathematica, we
use the identiﬁers FirstDerivative and SecondDerivative instead of the identiﬁers
First
derivative andSecond
 derivative used in the MPL dialogue.
46 2. Elementary Concepts of Computer Algebra
In[1]: = u=e xp[ x]+y[x]ˆ4==4∗xˆ2+y[x]
Out[1]= ex+y[x]4==4x2+y[x]
In[2]: = v=D[u,x]
Out[2]= ex+4y[x]3y/prime[x]== 8x+y/prime[x]
In[3]: = s=Solve[v,D[y[x],x]]
Out[3]={{y/prime[x]→−ex+8x
−1+4y[x]3}}
In[4]: = FirstDerivative =D[y[x],x]] == Part[Part[Part[s,1],1],2]
Out[4]= y/prime[x] ==−ex+8x
−1+4y[x]3
In[5]: = w=D[FirstDerivative ,x]]
Out[5]= y/prime/prime[x] ==8−ex
−1+4y[x]3−12(−ex+8x)y[x]2y/prime[x]
(−1+4y[x]3)2
In[6]: = SecondDerivative =ReplaceAll [w,Part[Part[s,1],1]]
Out[6]= y/prime/prime[x] == −12(−ex+8x)2y[x]2
(−1+4y[x]3)3+8−ex
−1+4y[x]3
Figure 2.10. A Mathematica implementation of the MPL dialogue in Figure 2.8.
(Implementation: Mathematica (nb).)
To obtain the second derivative, at In[5] we diﬀerentiate both sides of
the equation FirstDerivative ,a n da t In[6], we obtain the substitution
with Mathematica’s ReplaceAll command. The substitution is deﬁned by
Part[Part[s,1],1] which selects the expression ( 2.14).
MuPAD
The MuPAD implementation of Figure 2.8is given in Figure 2.11.T h e
statements at the ﬁrst two prompts are similar to those in the MPL dia-
2.1. Mathematical Pseudo-language (MPL) 47
•u:=exp(x)+y(x)∧4=4∗x∧2+y(x);
ex+y(x)4=y(x)+4·x2
•v:=diff(u,x);
ex+4·y(x)3·∂
∂xy(x)=8·x+∂
∂xy(x)
•v2:=subs(v,diff(y(x),x)=Dy);
ex+4·Dy·y(x)3=8·x+Dy
•d:=solve(v2,Dy,IgnoreSpecialCases );
k8·x−ex
4·y(x)3−1L
•First
 derivative :=diff(y(x),x)=op(d,1);
∂
∂xy(x)=8·x−ex
4·y(x)3−1
•w:=diff(First
 derivative ,x);
∂2
∂x2y(x)=−ex+8
4·y(x)3−1−12·y(x)2·∂
∂xy(x)·(8·x−ex)
(4·y(x)3−1)2
•Second
 derivative :=subs(w,First
 derivative );
∂2
∂x2y(x)=−ex+8
4·y(x)3−1−12·y(x)2·(8·x−ex)2
(4·y(x)3−1)3
Figure 2.11. A MuPAD implementation of the MPL dialogue in Figure 2.8.
(Implementation: MuPAD(mnb).)
logue. The next three prompts, however, correspond to the single state-
ment<3>in the MPL dialogue. At the third prompt, we use MuPAD’s
subsoperator to replace the derivative diff(y(x),x) in the previous ex-
pression by the symbol Dy. This step is required because MuPAD’s solve
operator cannot solve for the expression diff(y(x),x) , even though it can
solve for other function forms. At the fourth prompt, MuPAD’s Solve
operator solves the equation v2forDy. Notice that we have included the
option IgnoreSpecialCases because, without this, the system performs
a more detailed analysis of the equation and also includes solutions forwhich the denominator 4 ·y(x)
3−1 = 0. These special solutions are not
required in our dialogue. At the ﬁfth prompt, we use MuPAD’s opopera-
tor (which selects operands of an expression) to extract the solution from
the set dand include diff(y(x),x) on the left side of an equation so that
First
 derivative corresponds to the output of <3>in the MPL dialogue.
48 2. Elementary Concepts of Computer Algebra
The operations at the next two prompts are the same as those at <4>and
<5>in the MPL dialogue.
Exercises
For the exercises in this section, the following operators are useful:
•In Maple, the expand,diff,subs,solve,op,a n d dsolveoperators. (Im-
plementation: Maple(mws).)
•In Mathematica, the Expand,D,ReplaceAll ,Solve,Part,a n d DSolve
operators. (Implementation: Mathematica (nb).)
•In MuPAD, the expand,diff,subs,solve,op,a n d odeoperators. (Im-
plementation: MuPAD(mnb).)
1. In this exercise we ask youto give an interactive dialogu e in a CAS similar
to the one in Figure 2.8that simulates the mathematical discourse in Fig-
ure2.12. UseaCAS’scommandforsolvingadiﬀerentialequationtoobtain
the general solution as in Expression ( 2.16), but don’t use this command
to obtain the arbitrary constant in the solution. Rather, use statements
similar to those in Figure 2.8to set up an equation for the arbitrary con-
stant and solve the equation. The last statement in the dialogue should
return an equation similar to Expression ( 2.19).
Consider the diﬀerential equation and initial condition:
dy
dx+y=x+exp( −2x),y(1)=3 . (2.15)
The general solution to this equation is given by
y=x−1−exp(−2x)+cexp(−x), (2.16)
where cis an arbitrary constant. To ﬁnd c, we substitute the initial condition
y( 1 )=3i n t oE q ua t i o n( 2.16) and obtain an equation for c:
3=−e−2+ce−1. (2.17)
Solving for c, we obtain
c=3e+e−1. (2.18)
Substituting Equation ( 2.18)i n t oE q ua t i o n( 2.16), we obtain the particular so-
lution to the diﬀerential equation:
y=x−1−exp(−2x)+(3e+e−1)e x p ( −x). (2.19)
Figure 2.12. A mathematical discourse that obtains the arbitrary constant in
the solution of a diﬀerential equation.
2.2. Expression Evaluation 49
2. Consider the second order diﬀerential equation
d2y(x)
dx2+5dy(x)
dx+6y(x)=sin( x),y(0)=2 .dy
dx(0) =1 .
This equation has a general solution that involves two arbitrary constants
which are found by substituting the two initial conditions into both thegeneral solution and its derivative and then solving the resulting system of
linear equations.
Give an interactive dialogue in a CAS similar to the one in Figure 2.8,
which ﬁnds the general solution to the diﬀerential equation, sets up the
equations for the arbitrary constants, solves for the arbitrary constants,and then substitutes them back into the general solution. Use a CAS’s
command for solving a diﬀerential equation to obtain the general solution
to the diﬀerential equation, but don’t use this command to obtain thearbitrary constantsinthesolution. Rather, usestatementssimilar tothose
in Figure 2.8to obtain the arbitrary constants. The last statement in the
dialogue should return an equation equivalent to
y(x)=(1/10) sin( x)−(1/10) cos( x)+(36 /5)e
−2x−(51/10)e−3x.
3. (a) Consider the polynomial y=ax3+bx2+cx+d.Give an interactive
dialogue in a CAS that ﬁnds the coeﬃcients a, b, c,anddsuch that
atx=2 ,
y=5,dy
dx=−2,d2y
dx2=2,d3y
dx3=−3.
The last statement should return the polynomial with the numerical
values for the coeﬃcients.
(b) Use the dialogue to show there are inﬁnitely may expressions of the
formy=(ax+b)/(cx+d) that satisfy the conditions in part (a).
(c) Use the dialogue to show it is impossible to ﬁnd an expression of the
formy=(ax+b)/(cx+d) that satisﬁes the conditions
y=1,dy
dx=2,d2y
dx2=3,d3y
dx3=4.
2.2 Expression Evaluation
The term expression evaluation (or just evaluation ) refers to the actions
taken by a CAS in response to an input expression. These actions include:
1. the analysis of the structure of an expression and the translation
of this structure into an internal form that is used by the CAS to
represent the expression;
50 2. Elementary Concepts of Computer Algebra
2. the evaluation of assigned variables and mathematical operators that
appear in an expression; and
3. the application of some elementary algebraic and trigonometric sim-
pliﬁcation rules.
In this section we consider the evaluation of variables and operators,
and take a brief look at the simpliﬁcation process. Expression structure is
described in detail in Chapter 3.
Variable and Operator Evaluation
Figure 2.13shows an MPL dialogue that gives some examples of variable
and operator evaluation. At <1>the expression t+ 1 is assigned to xand
at<2>a polynomial in xis assigned to y.S i n c exhas been assigned, its
value is included in the expression for y. In a similar way at <3>,t h e
values for xandyare included in the expression and the Factor operator
is evaluated. Statements <4>and<5>show that the evaluation process
a p p l i e st of u n c t i o nn a m e sa sw e l la so t h e rv a r i a b l e si na ne x p r e s s i o n .
But now, what happens when the value of an assigned variable is an-
other expression which also contains assigned variables? Statements <6>
through<9>illustrate what can happen in this situation. At <6>,<7>,
and<8>,t h ev a r i a b l e s u,v,a n dware assigned values where all variables
to the right of the assignment symbols are unassigned. What is the value of
u2after the execution of these assignments? Statement <9>contains two
responses that illustrate two diﬀerent approaches to variable evaluation.In the ﬁrst approach, called single-level evaluation ,t h ev a l u eo f uis the
value it was originally assigned ( v+ 2), and the assigned value of vin this
expression is ignored. In other words, with single-level evaluation only onelevel of active assignments is used.
In the second approach, called multi-level evaluation , the evaluation
process uses all active assignments. In this case, the value of u
2is obtained
using three levels of assignments
u2→(v+2 )2→(w2+2 )2→((t+3 )2+2 )2. (2.20)
Since some systems provide a way to control the evaluation level, MPL
provides the Evaluate operator for this purpose. At <10>,w ee v a l u a t e u2
using two levels of assignments.
Occasionally, it is useful to suppress the evaluation of a variable or
operator. We denote this operation in MPL by placing the variable or
operator name in quotes. For example, at <11>we suppress evaluation of
theDerivative operator and at <12>suppress evaluation of the assigned
variablew. Finally, there are times when it is necessary to unassign or
2.2. Expression Evaluation 51
<1>x:=t+1;
→ x:=t+1;
<2>y:=x2+4∗x+4;
→ y:= (t+1)2+4(t+1)+4
<3>x ∗Factor(y);
→(t+1)(t+3)2
<4>z:=f;
→ f;
<5>z(x);
→ f(t+1)
<6>u:=v+2;
→ u:=v+2;
<7>v:=w2;
→ v:=w2;
<8>w:=t+3;
→ w:=t+3
<9>u2;
→(v+2)2(single-level evaluation)
→((t+3)2+2)2(multi-level evaluation)
<10>Evaluate(u2,2);
→(w2+2)2
<11>”Derivative ”(t2,t);
→d(t2)
dt
<12>Derivative (”w”,t);
→0
<13>Unassign(w);
→ w
<14>Algebraic
expand((w+1)∗(w+2));
→ w2+3w+2
Figure 2.13. An MPL dialogue that shows examples of variable and operator
evaluation. (Implementation: Maple(mws),Mathematica (nb),MuPAD(mnb).)
52 2. Elementary Concepts of Computer Algebra
MPL
 Maple
 Mathematica
 MuPAD
multi-level
 multi-level
 multi-level
 multi-level
(dialogues),
 (interactive mode),
 in
 (interactive mode),
single-level
 single-level
 interactive mode
 single-level
(in procedures)
 (in procedures)
 and
 (in procedures)
procedures
control
evaluation
level
Evaluate(u,n)
 eval(u,n)
 not available
 level(u,n)
suppress
evaluation
”u”
 ’u’
 HoldForm[u]
 hold(u)
”Derivative ”(u,x)
 ’diff’(u,x)
 HoldForm[D][u,x] ,
hold(diff)(u,x)
and release
suppressed
evaluation
with
ReleaseHold[u]
Unassign(u)
 unassign(’u’)
 u=.
 delete(u)
Figure 2.14. Evaluation concepts in Maple, Mathematica, and MuPAD.
remove the value of an assigned variable. In MPL, the Unassign operator
is used for this purpose. At <13>, we apply Unassign tow,w h i c hm e a n s
at<14>wacts as a symbol in the mathematical expression.
InF i g u r e 2.14, we summarize the evaluation concepts considered above
in the Maple, Mathematica, and MuPAD systems. Observe that all three
systems use multi-level evaluation in the interactive mode, while both
Maple and MuPAD switch to single-level evaluation inside procedures7.In
MPL, we also use multi-level evaluation in dialogues, and following Mapleand MuPAD, use single level evaluation in procedures.
Automatic Simplification
The term automatic (ordefault )simpliﬁcation refers to the mathematical
simpliﬁcation rules that are applied to an expression during the evaluation
process. In computer algebra systems, this usually involves the “obvious”
simpliﬁcation rules from algebra and trigonometry that remove extraneous
symbols from an expression and transform it to a standard form.
7Procedures in a CAS language are like procedures or functions in a conventional
programming language. A procedure in the Maple language is given in Figure 1.3on
page 6. We consider procedures in Chapter 4.
2.2. Expression Evaluation 53
<1>2+3/4+5/6;
→43
12
<2>x+y+2∗x;
→3x+y
<3>x ∗y∗x2;
→ x3y
<4>1∗x3+a∗x0+b∗x1+0∗x2;
→ a+bx+x3
<5>x ∗y+3∗y∗x;
→4xy
<6>sin(π/2);
→1
<7>ln(e2);
→2
<8>arctan(1);
→ π/4
<9>ı2;
→− 1
<10>e(−ı∗π);
→− 1
<11>0≤1and1≤2;
→ true
<12>P andPandQ;
→ PandQ
Figure 2.15. An MPL dialogue that shows some examples of automatic simpliﬁ-
cation. (Implementation: Maple(mws),Mathematica (nb),MuPAD(mnb).)
The MPL dialogue in Figure 2.15illustrates some of these obvious sim-
pliﬁcations. Example <1>shows a simpliﬁcation that involves the sum
of rational numbers. Example <2>shows that automatic simpliﬁcation
combines numerical coeﬃcients of like terms. The next example <3>illus-
trates a similar simpliﬁcation in which integer exponents of the common
basexare combined. Example <4>illustrates some simpliﬁcation rules
that involve the integers 0 and 1. Notice that after evaluation, the x3term
appears at the right end of the expression. This reordering, which is an
54 2. Elementary Concepts of Computer Algebra
application of the commutative law of addition, serves to put the result in
a more readable form and, in some cases, contributes to the simpliﬁcation
process8. The next example <5>illustrates this point. To simplify this
expression, the term 3 ∗y∗xis ﬁrst reordered (using the commutative law
for multiplication) to 3 ∗x∗yafter which the coeﬃcients of the two like
terms are combined. Examples <6>,<7>,a n d<8>illustrate automatic
simpliﬁcation rules that involve known functions, while Examples <9>and
<10>illustrate simpliﬁcation rules that involve reserved symbols.
Examples <11>and<12>illustrate the automatic simpliﬁcation rules
that are applied in some systems to logical expressions as data objects9.In
Example<12>,PandQare unassigned identiﬁers and the simpliﬁcation
follows from the general logical rule PandP→P.
The examples in Figure 2.15are roughly similar to what happens in a
real computer algebra system. However, since there is no consensus about
which simpliﬁcation rules should be included in automatic simpliﬁcation,
the process can vary somewhat from system to system.
Figure 2.16shows an interactive dialogue with the Macsyma system
that shows what happens when automatic simpliﬁcation is suppressed. At
the prompt (c1)we assign an expression to uand at (c2)turn oﬀ the
automatic simpliﬁer by assigning the value false to the variable simp.A t
(c3)we diﬀerentiate uand obtain an expression that is so involved it is
diﬃcult to interpret10.A t (c4)we turn the automatic simpliﬁer back on
and at (c5)obtain a much more reasonable form for the derivative.
In MPL (as in a CAS), all expressions in dialogues and computer pro-
grams operate in the context of automatic simpliﬁcation. This means:
•All input operands to mathematical operators are automatically sim-
pliﬁed before the operators are applied.
•The result obtained by evaluating an expression is in automatically
simpliﬁed form.
Since automatic simpliﬁcation is so central to the programming process, it
is a good idea to understand which simpliﬁcation rules are applied by the
process and which are not. For now, the exercises in this section can beused to explore the automatic simpliﬁcation process in a CAS.
8The reordering process in Mathematica and MuPAD is similar to what is described
here. The reordering process in Maple is handled in a diﬀerent way (see Cohen [ 24],
Section 3.1).
9Maple obtains <11>and<12>. Mathematica obtains <11>, but not <12>.M u -
PAD obtains <12>, but not <11>.
10Notice that Macsyma uses logarithmic diﬀerentiation to diﬀerentiate ex2. Logarith-
mic diﬀerentiation provides a way to diﬀerentiate general powers of the form f(x)g(x).
2.2. Expression Evaluation 55
(c1) u : a*x + x*exp(x ∧2);
(d1) xex2+ax
(c2) simp : false;
(d2) false
(c3) diﬀ(u,x);
(d3) 1a+0x+ex2/parenleftbig
e−1x20 + log(e)(2x)/parenrightbig
x+1ex2
(c4) simp : true;
(d4) true
(c5) diﬀ(u,x);
(d5) 2x2ex2+ex2+a
Figure 2.16. An interactive dialogue with the Macsyma system that shows what
happens when automatic simpliﬁcation is suppressed.
In Chapter 3, we show how automatic simpliﬁcation modiﬁes the struc-
ture of expressions, which in turn leads to simpler algorithms and programs.InC o h e n[ 24], Chapter 3, we give the formal algebraic properties of au-
tomatically simpliﬁed expressions and describe an algorithm that obtains
the simpliﬁed form.
Exercises
1. (a) Consider the following transformations of powers11:
i.x2x3→x5.
ii.x1/2x1/3→x5/6.
iii.xaxb→xa+b.
11Some of the power transformations in this problem are only valid in certain (real or
complex) contexts.
56 2. Elementary Concepts of Computer Algebra
iv. (x2)3→x6.
v. (xa)2→x2a.
vi. (x2)1/2→|x|.
vii. (x1/2)2→x.
viii. (x2)a→x2a.
ix. (xy)2→x2y2.
x. (xy)1/3→x1/3y1/3.
xi. (xy)a→xaya.
Which of these transformations is obtained with automatic simpliﬁ-
cation?
(b) Based on the data obtained in part (a), give a summary of how the
power translations are applied in automatic simpliﬁcation.
2. The algebraic operations addition and multiplication obey the following
distributive laws:
a·(b+c)=a·b+a·c,(a+b)·c=a·c+b·c
(a) Considerthefollowing transformationswhicharebasedontheselaws:
i. 2x+3x→5x.
ii. (1+ x)+2(1+ x)→3(1+ x).
iii. 2x+√
2x→(2+√
2)x.
iv.ax+bx→(a+b)x.
v. (a+b)x→ax+bx.
vi. 2(x+y)→2x+2y.
vii.−(x+y)→−x−y.
viii.a(x+y)→ax+ay.
Whichof thethese transformations are obtained with automatic sim-
pliﬁcation?
(b) Based on the data obtained in part (a), give a summary of how the
distributive laws are applied in automatic simpliﬁcation.
3. (a) Consider the following transformations of the sin function:
i. sin(0) →0.
ii. sin( π/2)→1.
iii. sin( π/5)→√
26
5−√
(5)
4.
iv. sin( π/60)→√
5+√
5
8−√
5+√
5√
3
8−Q
−√
5
4+1/4w√
2
4Q
−√
5
4+1/4w√
2√
3
4.
v. sin(15 π/16)→sin(π/16).
vi. sin( −x)→−sin(x).
vii. sin( −x+1)→−sin(x−1).
2.2. Expression Evaluation 57
viii. sin( x+π/2)→cos(x).
ix. sin( x+2π)→sin(x).
x. sin( a+b)→sin(a)c o s (b)+cos( a)s i n (b).
xi. sin( a)c o s (b)+cos( a)s i n (b)→sin(a+b).
xii. sin2(x)+cos2(x)→1.
Which of the these transformations is obtained with automatic sim-
pliﬁcation?
(b) Based on the data obtained in part (a), give a summary of the trans-
formationrulesforthesinfunctionwhichareobtainedwithautomatic
simpliﬁcation.
4. In this problem we ask youto explore how the indeterminate forms 0 /0
and 00are handled in automatic simpliﬁcation.
(a) Enter each of the following expressions in the interactive mode of a
CAS.
i. 0/0.
ii. 00.
iii. (a(x+y)−ax−ay)/(x−x).
iv. (x−x)/(a(x+y)−ax−ay).
v. (x−x)a(x+y)−ax−ay.
vi. (a(x+y)−ax−ay)x−x.
(b) Based on the data obtained in part (a), give a summary of how inde-
terminate forms are handled by automatic simpliﬁcation.
5. Enter each of the following expressions in the interactive mode of a CAS:
−b, a −2∗b,1/a2,a / b .
Although each of the expressions is returned in the form it was entered,
some “hidden”transformations have been applied. In other words, theinternal form used by the CAS is diﬀerent from the displayed form. Use
the operand selection operator in a CAS to determine the internal form.
(Use opin Maple and MuPAD, and Partin Mathematica.)
6. This exercise refers to the Macsyma dialogue in Figure 2.16on page55.
What simpliﬁcation rules are used to obtain (d5)instead of (d3)?
7. Consider a CAS such as Mathematica or MuPAD where terms in a sum
or factors in a product are reordered as part of automatic simpliﬁcation.
ExperimentwiththeCAStodeterminehowitcarriesouttheorderingpro-
cess. Try polynomials such as <4>in Figure2.15as well as more involved
expressions. For example, are any terms or factors in
i
1+zy
2+(a+1)b+cJ
(a+1)
reordered by automatic simpliﬁcation?
58 2. Elementary Concepts of Computer Algebra
2.3 Mathematical Programs
Simply put, an MPL mathematical program (ormathematical algorithm )i s
a sequence of statements in the MPL language that can be implemented
in terms of the operations and control structures available in a computeralgebra programming language. The design and implementation of math-
ematical programs is a major theme of this book.
In a sense, the MPL dialogue in Figure 2.8is an example of a simple
interactive program. What we really have in mind, however, are more
involved programs that have the following features:
1. The statements in the program are viewed collectively as a unit which
either is entered at a single prompt or input region in the interactive
mode or, for larger programs, is contained in a text ﬁle that is loaded
into the system.
2. The program statements include mathematical expressions, assign-
ment statements, decision statements, iteration statements, and func-
tion and procedure deﬁnitions
12.
3. As with conventional programs, some statements serve as input state-
ments, some statements are for intermediate calculations for which
the output is not displayed, and some statements serve as outputstatements that display the result of a computation.
4. The program is designed in a general way so that it performs a cal-
culation for a class of problems rather than for a single problem.
For an example of a program that incorporates some of these points,
let’s consider again the computation of the ﬁrst and second derivatives of
an implicitly deﬁned function such as
exp(x)+y
3=4x2+y.
This problem, which was considered in Section 2.1, involves the manip-
ulations in Equations ( 2.8) through ( 2.12), and anMPL dialogue that
performs the calculations is given in Figrue 2.8on page 42. This dialogue
assumes that xis the independent variable, yis the dependent variable,
and requires that ybe expressed as the function form y(x).
In this section we modify the program to permit a choice of mathe-
matical variable names and do not require that the dependent variable be
12Decision statements, iteration statements, and function and procedure deﬁnitions
are described in Chapter 4.
2.3. Mathematical Programs 59
1 u
in:= exp( s)+t4=4∗s2+t:
2x
var:=s:
3y
var:=t:
4 u
new:=Substitute (u
in,y
var=y
var(x
var)):
5 u
p:=Derivative (u
new,x
var):
6First
derivative :=Solve(u
p,Derivative (y
var(x
var),x
var);
7 u
pp:=Derivative (First
derivative,x
var):
8Second
 derivative :=Substitute (u
pp,First
derivative );
Figure 2.17. An MPL mathematical program that obtains the ﬁrst and second
derivativesofanimplicitfunction. (Implementation: Maple(mws),Mathematica
(nb),MuPAD(mnb).)
expressed as a function form. By simply modifying the input statements,
we can obtain
dy
dx,d2y
dx2ordx
dy,d2x
dy2,
or, for that matter, if the input expression is expressed in terms of the
variablessandtas exp(s)+t3=4s2+t,the derivatives
dt
ds,d2t
ds2ords
dt,d2s
dt2.
An MPL program that performs these calculations is given in Fig-
ure2.17. Observe that some statements are terminated by a colon (lines 1,
2, 3, 4, 5, and 7) and some by a semicolon (lines 6 and 8). This notationis interpreted as follows: statements that end with a colon suppress the
display of the output, while those that end with a semicolon display the
output. Most computer algebra systems allow control of output display,
although the termination symbols vary from system to system
13.
Lines 1 through 3 serve as input statements for the program. Since the
program is designed to allow a choice of mathematical variable names, we
have chosen programming variable names ( u
in,x
var,y
var,etc.)t h a ta r e
unlikely to be used as mathematical variables. At line 1 we assign an input
expression, and at lines 2 and 3, we initialize two programing variables
x
varandy
varwhich contain the mathematical variables ( sandtfor
13In both Maple and MuPAD, statements that are terminated with a colon suppress
the output, while those that are terminated with a semicolon display the output. InMathematica, statements that are terminated with a semicolon suppress the output,while those without a terminating symbol display the output.
60 2. Elementary Concepts of Computer Algebra
this input) which serve as the independent and dependent variables. With
these two assignments, the output of the program is the derivatives
dt
dsandd2t
ds2.
The derivative operations at lines 5 and 7 require that the dependent vari-
abletbe expressed as the function form t(s). Since this is not done in line
1, we account for this at line 4 with a substitution that replaces each tin
u
inbyt(s). Except for changes in notation, lines 5 through 8 are similar
to those in Figure 2.8. With the choice of input, the outputs from lines 6
and 8 are
dt(s)
ds=−exp(s)+8s
4t(s)3−1, (2.21)
d2t(s)
ds2=−exp(s)+8
4t(s)3−1−12(−exp(s)+8s)2t(s)2
(4t(s)3−1)3.(2.22)
Observe that the dependent variable tis expressed in function notation
t(s), even though this is not done in the input at line 1. In Exercise 1we
describe a modiﬁcation of the program that removes this function notationfrom the output.
Case Study: General Quadratic Equations and Rotation of Axes
We conclude this section with a more involved MPL program that ob-tains the change of form of a quadratic equation under rotation of coordi-
nate axes.
A general quadratic equation in xandyhas the form
Ax
2+Bxy+Cy2+Dx+Ey+F=0, (2.23)
where the coeﬃcients are rational numbers and at least one of the coef-
ﬁcientsA,B,C /negationslash= 0. This equation represents one of the following eight
graphs in the plane:
1. a circle (such as x2+y2−1=0 ) .
2. an ellipse (such as x2+2y2−1=0 ) .
3. a single point (such as x2+y2=0o r(x,y)=( 0,0)).
4. an empty graph (such as x2+y2=−1).
2.3. Mathematical Programs 61
5. a hyperbola (such as x2−y2=1 ) .
6. a parabola (such as x2−y=0 ) .
7. two intersecting lines (such as x2−y2=0o rx=±y).
8. a single line (such as x2+2xy+y2=(x+y)2=0o rx=−y).
IfB=0i nE q u a t i o n( 2.23), it is a simple matter to determine the
type of graph and some of its important features by using the techniques of
analytical geometry. If B/negationslash= 0, the analysis is more involved. However, by
rotating the coordinate system, it is possible to transform Equation ( 2.23)
into a general quadratic equation in terms of new variables ( u,v)s ot h a t
the coeﬃcient of the uvterm is zero.
Consider the coordinate rotation shown in Figure 2.18,w h e r et h e( u,v)
coordinate system is rotated by an angle αfrom the ( x,y) system. To ﬁnd
a relationship between the ( x,y)a n d(u,v)c o o r d i n a t e s ,w eh a v e
x=rcos(α+β)y=rsin(α+β) (2.24)
and
u=rcos(β)v=rsin(β). (2.25)
xy
yuvP(x, y )o r( u, v )
xu
αβv
Figure 2.18. The point Pin the ( x,y)a n d( u,v)c o o r d i n a t es y s t e m s .
62 2. Elementary Concepts of Computer Algebra
By expanding the trigonometric expressions in Equations ( 2.24), we obtain
x=rcos(α)cos(β)−rsin(α)sin(β), (2.26)
y=rsin(α)cos(β)+rcos(α)sin(β). (2.27)
Substituting Equations ( 2.25)i n t oE q u a t i o n( 2.27), we obtain the coordi-
nate transformation
x=ucos(α)−vsin(α),y=usin(α)+vcos(α). (2.28)
By substituting Equations ( 2.28) into the original Equation ( 2.23), we ob-
tain a quadratic equation in the ( u,v)s y s t e m
A/primeu2+B/primeuv+C/primev2+D/primeu+E/primev+F/prime=0, (2.29)
where
A/prime=Acos2(α)+Bcos(α)sin(α)+Csin2(α),
B/prime=B(cos2(α)−sin2(α)) + 2(C−A)s i n (α)c o s (α),
C/prime=Asin2(α)−Bsin(α)cos(α)+Ccos2(α), (2.30)
D/prime=Dcos(α)+Esin(α),
E/prime=−Dsin(α)+Ecos(α),
F/prime=F.
To ﬁnd an αso that the coeﬃcient of the uvtermB/prime=0 ,w eu s et h e
trigonometric reduction rules
2sin (α)cos(α)=s i n ( 2α),cos2(α)−sin2(α)=c o s ( 2α),
so that the second equation in ( 2.30) becomes
B/prime=Bcos(2α)+(C−A)s i n ( 2α).
SettingB/prime= 0, we obtain when B/negationslash=0
cot(2α)=A−C
B. (2.31)
(WhenB= 0, a rotation is not needed and so α=0 . )W h e n0 <α<π/ 2,
the function cot(2 α) takes on all real values. Therefore, Equation ( 2.31)
deﬁnes a unique rotation αin this interval.
Example 2.2. Consider the quadratic equation x2+2xy+y2=0 . S i n c e
the left side can be factored as ( x+y)2, the quadratic equation represents
2.3. Mathematical Programs 63
the straight line y=−x. To ﬁnd the equation of the line in the ( u,v)
system, we have from Equation ( 2.31)
cot(2α)=A−C
B=1−1
2=0
and soα=π/4. Using Equation ( 2.30), we obtain the simple equation
u= 0 for the line in the new coordinate system. /square
To apply Equation ( 2.30) in more involved situations, we need expres-
sions for sin( α)a n dc o s ( α). Since 0 <2α<π,c o s ( 2α) has the same sign
as cot(2α). Therefore Equation ( 2.31) implies
cos(2α)=B
|B|A−C
/radicalbig
(A−C)2+B2(2.32)
whereB/|B|is included so that cos(2 α) has the correct sign. We obtain
values for sin( α)a n dc o s ( α) with Equation ( 2.32) and the identities
cos(α)=/radicalbigg
1+c o s ( 2α)
2,sin(α)=/radicalbigg
1−cos(2α)
2.
By using these identities together with Equation ( 2.32), we obtain the
coeﬃcients in Equation ( 2.30) in the new system without ﬁnding α.
Before giving a program that performs these calculations, we describe
two polynomial operators that are available in most computer algebra sys-
tems. Consider the polynomial in x
w=wnxn+wn−1xn−1+···+w0, (2.33)
where the coeﬃcients wjcan be integers, fractions, symbols, or even more
involved expressions, xrepresents a variable or a more involved expres-
sion, and nis a non-negative integer. Recall, the largest power of xin a
polynomial is called the degree of the polynomial.
The two most important operators for polynomials are the Degree and
Coeﬃcient operators14. The operator Degree (w,x) returns the degree of
the polynomial wwith respect to an expression x.
Example 2.3.
Degree (3x2+x+5,x)→2,
Degree (asin2(x)+bsin(x)+c,sin(x))→2.
14TheDegree andCoeﬃcient operators are described in greater detail in Chapter
6. In Chapter 6, these operators are called Degree
gpeandCoeﬃcient
 gpe,w h e r et h e
suﬃxgpestands for general polynomial expression (see Deﬁnition 6.14 on page 223).
64 2. Elementary Concepts of Computer Algebra
Observe that in the second example the expression is considered a polyno-
mial in the function form sin( x). (Implementation: Maple (mws), Mathe-
matica (nb),MuPAD (mnb).) /square
The operator Coeﬃcient (w, x, j ) returns the coeﬃcient wjofxjin
Equation ( 2.33).
Example 2.4.
Coeﬃcient (3x2+x+5,x ,2)→3,
Coeﬃcient (asin2(x)+bsin(x)+c,sin(x),2)→a,
Coeﬃcient (ax+bx+c, x,1)→a+b,
Coeﬃcient (Coeﬃcient (2x2+3xy+4y2+5x+6y+7,x,1),y ,0)→5.
In the last example, the inner application of the Coeﬃcient operator obtains
3y+5 and the outer application obtains the value 5. Maple (mws), Math-
ematica (nb), MuPAD (mnb).) Maple (mws), Mathematica (nb),MuPAD
(mnb).) /square
The degree and coeﬃcient operations in Maple, Mathematica and Mu-
PAD are given in Figure 2.4on page 35.
An MPL program that obtains an expression for the polynomial in the
(u,v) coordinate system is given in Figure 2.19. The input to the program
is given in the assignment at line 1. Notice that we permit both sidesof the equation to contain terms of the polynomial and combine the two
sides using the Operand selection operator. The output of the program
is the equation obtained by evaluating the expression in line 17. For the
expression in line 1, the output is the equation (1 /2)u
2−(1/2)v2−1=0 .
The programs considered so far are quite elementary. In later chapters
we introduce other MPL mathematical operators and language featuresthat enable us to construct more involved and interesting programs.
Exercises
For the exercises in this section, the following operators are useful:
•In Maple, the coeff,expand,abs,diff,subs,solve,op,int,a n d dsolve
operators. (Implementation: Maple(mws).)
•In Mathematica, the Coefficient ,Expand,Abs,D,Derivative ,
ReplaceAll ,Solve,Part,Integral,a n d DSolveoperators. (Imple-
mentation: Mathematica (nb).)
•In MuPAD, the coeff,expand,abs,diff,subs,solve,op,int,a n d ode
operators (Implementation: MuPAD(mnb).)
2.3. Mathematical Programs 65
1 eq:=x∗y=1:
2 w:=Operand(eq,1)−Operand(eq,2) :
3 A:=Coeﬃcient (w,x,2) :
4 B:=Coeﬃcient (Coeﬃcient (w,x,1),y,1) :
5 C:=Coeﬃcient (w,y,2) :
6 D:=Coeﬃcient (Coeﬃcient (w,x,1),y,0) :
7 E:=Coeﬃcient (Coeﬃcient (w,y,1),x,0) :
8 F:=Coeﬃcient (Coeﬃcient (w,x,0),y,0) :
9 g:=B/Absolute
value(B)∗(A−C)/((A−C)2+B2)1/2:
10 ca:=((1+ g)/2)1/2:
11 sa:= ((1 −g)/2)1/2:
12 Ap:=A∗ca2+B∗ca∗sa+C∗sa2:
13 Cp:=A∗ca2−B∗ca∗sa+C∗sa2:
14 Dp:=D∗ca+E∗sa:
15 Ep:=−D∗sa+E∗ca:
16Fp:=F:
17 Ap∗u2+Cp∗v2+Dp∗u+Ep∗v+Fp=0 ;
Figure 2.19. An MPL program that transforms a quadratic polynomial in xand
yto a quadratic polynomial in uandvwithout the u∗vterm. (Implementation:
Maple(mws),Mathematica (nb),MuPAD(mnb).)
1. The output of the program in Figure 2.17i sg i v e ni nE q ua t i o n s( 2.21)a n d
(2.22). Observe that the dependent variable tis displayed as a function
form. Modifytheprogramsothattheoutputisdisplayedwithoutfunction
forms including the function forms that appear in the derivative symbols.
2. An implicit equation f(x,y)=Kdeﬁnes a family of curves that depends
on the parameter K. We deﬁne two families f(x,y)=Kandg(x,y)=C
to beorthogonal trajectories if, whenever a curve f(x,y)=Kintersects a
curveg(x,y)=C, thetangent lines (derivatives)to the curvesat the point
of intersection are perpendicular. For example, the circles x2+y2=K
(with K>0) and the straight lines y/x=Care orthogonal trajectories.
Indeed, using implicit diﬀerentiation, a circle has a tangent with slope
dy
dx=−x/y,
while the straight line has slope
dy
dx=y/x.
Therefore, at a point of intersection, the circle and line have derivatives
that are negative reciprocals and so they intersect at a right angle.
66 2. Elementary Concepts of Computer Algebra
For a given family f(x,y)=K, we can ﬁnd the family of curves that is
orthogonal to it by solving a diﬀerential equation. For example, for the
family of parabolas f(x,y)=y−x2=K, we ﬁrst diﬀerentiate (implicitly)
to obtain a diﬀerential equation satisﬁed by the family of curves
dy
dx−2x=0.
Next, we obtain the diﬀerential equation for the orthogonal family by re-
placing the derivative symbol by its negative reciprocal. Therefore, the
orthogonal family to the parabolas satisﬁes the diﬀerential equation
dy
dx+1/2x=0.
Solving this equation we obtain the orthogonal family g(x,y)=l o g |x|+
2y=C.
Now let urepresent a family of curves in the form f(x,y)=K.G i v e
a program that ﬁnds the orthogonal family to f(x,y)=K.T e s t y o ur
program for the families x2+y2=K,y−x2=K,a n dx2−y2=K.
3. Let wbea general quadraticEquation ( 2.23)i nxandywithA/negationslash=0 ,C/negationslash=0
andB= 0. Give a program that completes the square in xandy.F o r
example, the program should transform 2 x2+3y2−4x−12y+10=0
to 2(x−1)2+3(y−2)2−4 = 0. (Do not use the Factoroperator in this
program.)
4. A ﬁrst order linear diﬀerential equation has the form
dy
dx=p(x)y+q(x). (2.34)
It is shown in books on diﬀerential equations that the general solution to
this equation is
y=(1/u)W
uqdx}
+C(1/u), (2.35)
where
u=e xpW
−
p(x)dx}
andCis an arbitrary constant. The arbitrary constant is found by substi-
tuting an initial condition y(x0)=y0into the general solution and solving
for the constant. Give a program that ﬁnds the general solution to a lin-
ear diﬀerential equation and uses an initial condition to ﬁnd the arbitrary
constant. For example, for
dy(x)
dx=xy(x)+x, y(1)=2 , (2.36)
the solution returned is equivalent to
y(x)=−1+3exp( −1/2) exp(( −1/2)x2).
Assume the input to your program is similar to Equations ( 2.36).
2.3. Mathematical Programs 67
5. A linear diﬀerential Equation ( 2.34) has a general solution of the form
y=f(x)+Cg(x) (2.37)
where Cis an arbitrary constant (see Equation ( 2.35) above). In this
problem, we are given an expression in the form ( 2.37) and ﬁnd the ﬁrst
order linear diﬀerential equation which has the expression as a generalsolution. For example, given
y=xln(x)+Cx , (2.38)
we can ﬁnd the diﬀerential equation by ﬁrst solving Equation ( 2.38)f o r
the arbitrary constant
C=y−xln(x)
x. (2.39)
Diﬀerentiating Equation ( 2.38)w eo b t a i n
dy
dx=1+l n( x)+C,
and substituting the value for Cin Equation ( 2.39) into this expression we
obtain
dy
dx=y/x+1.
Give a program that ﬁnds the diﬀerential equation using steps similar to
the ones in this example. Assume the input expression has the form ( 2.37)
where g(x)/negationslash= 0. Test your program for the functions y=xln(x)+Cx,
y=x+Csin(x), and y=e xp ( x)+Csin(x).
6. A linear second order diﬀerential equation has the form
d2y
dx2=p(x)dy
dx+q(x)y+r(x). (2.40)
This equation has a general solution of the form
y=c1f(x)+c2g(x)+h(x), (2.41)
where c1andc2are arbitrary constants. In this problem, we are given
an expression in the form ( 2.41) and ﬁnd a second order linear diﬀerential
equation which has the expression as a general solution. For example, for
y=c1x+c2x2+x3,
we obtain
d2y
dx2=(2/x)dy
dx−(2/x)y+2x.
GiveaprogramthathasanexpressionoftheformEquation( 2.41)asinput
andﬁndsthe diﬀerential equation. The approachis similar totheone used
68 2. Elementary Concepts of Computer Algebra
in Exercise 5,exceptnowwemusteliminate twoarbitrary constants c1and
c2fromthesecondderivativeoftheinputexpression. Thisprobleminvolves
thesolutionasystemoftwoequationsforthetwounknowns c1andc2,a n d
to guarantee a solution to the system, assume that f(x)g/prime(x)−f/prime(x)g(x)
is not identically 0.
7. ThemethodofLagrangemultipliersisatechniqueforﬁndingthemaximum
andminimumvaluesofafunctionofseveralvariableswhentheindependentvariables are subject to one or more constraints
15. For example, to ﬁnd
the maximum and minimum values of f(x,y)w h e r e xandyare subject to
t h es i d er e l a t i o n g(x,y)=c, form a new function
L(x,y,λ)=f(x,y)−λg(x,y),
where the variable λis called the Lagrange multiplier. Next solve the
following three simultaneous equations for the unknowns x,y,a n dλ:
∂L
∂x=0,∂L
∂y=0,∂L
∂λ=0. (2.42)
Themaximumandminimumvalues(iftheyexist)occuratthepoints( x,y)
that are solutions to this system. For example, if f=x−xy+2andthe
side relation is theline x−2y=1, thenEquations ( 2.42)ha v etheso lutio n
λ=3/4,x=3/2,y=1/4,
and the maximum value of foccurs at this point. Give a program that
sets up the equations in ( 2.42) and ﬁnds their solution.
8. Let wbe a general quadratic equation in xandywithA=−C/negationslash=0 .
(a) Show there is a rotation of axes αthat gives A/prime=0a nd C/prime=0 .
(b) Give a program that ﬁnds the equation in the ( u,v) system deﬁned
by the rotation in part (a).
(c) Usethealgorithminpart(b)toﬁndtheequationfor x2+xy−y2−1=
0i nt h e( u,v)s y s t e m .
2.4 Sets and Lists
In computer algebra languages both sets and lists are used to represent
collections of mathematical expressions. In this section we give the math-ematical properties of sets and lists, and describe the operations that are
a p p l i e dt oe a c ho ft h e m .
15See Simmons [ 88] for an elementary discussion of the method.
2.4. Sets and Lists 69
Sets
Inm a t h e m a t i c s ,a setis deﬁned as simply a collection of objects. In MPL,
a set is a ﬁnite collection of expressions that is surrounded by the braces {
and}. For example, the expression
{x+y=1,x−y=2}
represents a set with two members, the equations x+y=1a n dx−y=2 .
Following mathematical convention, MPL sets satisfy the two proper-
ties:
1.The contents of a set does not depend on the order of the elements in
the set. This means that {u, v}and{v, u}are the same set.
2.The elements of a set are distinct. In other words, a set cannot
contain duplicate elements.
In MPL, sets are used in situations where the order of expressions in the
set is not signiﬁcant. For example, sets are used in the expression
Solve({2x+4y=3,3x−y=7},{x, y}),
since the order of both the equations and the variables does not change the
result of the operation.
Algebraic Operations On Sets
LetAandBrepresent sets and let xrepresent an arbitrary expression.
The following operations are deﬁned for sets:
•Union of Sets ,A∪B.T h e union of setsAandBis a new set that
contains all the elements in Aor inBor in both sets. For example,
{a, b, c, d }∪{c, d, e, f }→{a, b, c, d, e, f }.
•Intersection of Sets ,A∩B.T h e intersection of setsAandBis a
new set that contains all the elements that are in both AandB.F o r
example,
{a, b, c, d }∩{c, d, e, f }→{c, d}.
•Diﬀerence of Sets ,A∼B.T h e diﬀerence of setsAandBis a new
set that contains all the elements that are in Abut not in B.F o r
example,
{a, b, c, d }∼{c, d, e, f }→{a, b}.
70 2. Elementary Concepts of Computer Algebra
MPL
 Maple
 Mathematica
 MuPAD
set notation
{a,b,c}
 {a,b,c }
 {a,b,c }
 {a,b,c }
∅
 {}
 {}
 {}
A∪B
 A union B
 Union[A,B]
 A union B
A∩B
 A intersect B
 Intersection[A,B]
 A intersect B
A∼B
 A minus B
 Complement[A,B]
 A minus B
x∈A
 member(x, A)
 MemberQ[x,A]
 contains(A,x)
Figure 2.20. Set operations in Maple, Mathematica, and MuPAD. (Implementa-
tion:Maple(mws),Mathematica (nb),MuPAD(mnb).)
•Set membership, x∈A.The expression x∈Aevaluates to trueifx
is inA, and otherwise evaluates to false. For example,
a∈{a, b, c, d }→true,
e∈{a, b, c, d }→false.
In the course of manipulating sets, we might obtain the empty set or
the set with no elements. Following mathematical convention, we representthis set with the reserved symbol ∅. For example, {a,b,c}∩{d,e,f }→∅.
Most computer algebra systems provide sets along with the algebraic
operations described above (see Figure 2.20).
Set Operations on Symbols
Some computer algebra systems allow variable symbols as operands of the
set operations ∪,∩,a n d ∼, and obtain general set identities as either part
of the automatic simpliﬁcation process or as the output of an operator.
This facility is illustrated in the MuPAD dialogue in Figure 2.21.A t t h e
ﬁrst three prompts, automatic simpliﬁcation obtains the identities
A∪A∪B=A∪B,
A∩∅=∅,
(A∩B)∼(B∩A)= ∅,
and at the fourth prompt, the expand operator obtains the distributive law
for sets
A∩(B∪C)=(A∩B)∪(A∩C).
Similar results are obtained with the Maple system.
2.4. Sets and Lists 71
•A union A union B ;
A∪B
•A intersect {};
∅
•(A intersect B )minus (B intersect A );
∅
•expand (A intersect (B union C ));
A∩B∪A∩C
Figure 2.21. General set identities in MuPAD (Implementation: Maple(mws),
MuPAD(mnb).)
Lists
An MPL listis a ﬁnite collection of expressions that is surrounded by the
brackets [ and ]. For example, the expression [ y(x)=3,x=1 ]i sa
list with two equations. The empty list, which contains no expressions, is
represented by [ ].
Lists are distinguished from sets by the following two properties:
1.The order of expressions in a list is signiﬁcant. This means the ex-
pressions [ y(x)=3,x=1 ]a n d[ x=1,y(x) = 3] represent diﬀerent
lists.
2.Duplicate elements are permitted in a list. This means the expressions
[x,y]a n d[x,y,y] represent diﬀerent lists.
In MPL, lists are used in situations where the order or duplication of
expressions is signiﬁcant. For example, Figure 2.22illustrates the eﬀect of
order on the sequential substitution operation. The Sequential
 substitute
operator shown in the dialogue performs a sequence of substitutions. Sincethe outcome of this operation depends on the order of substitutions, a list
is used to indicate this order. In <1>, the substitution y(x) = 3 occurs
beforex= 2 while in <2>this order is reversed. Multiple substitutions,
including the Sequential
substitute operator, are described in greater detail
in Section 3.3.
72 2. Elementary Concepts of Computer Algebra
<1>Sequential
substitute(y(x)=m∗x+b,[y(x)=3,x=2 ] );
→3=2m+b
<2>Sequential
substitute(y(x)=m∗x+b,[x=2,y(x)=3]);
→ y(2)=2 m+b
Figure 2.22. An MPL dialogue that illustrates the eﬀect of order in a list on the
Sequential
substitute operation. (Implementation: Maple(mws),Mathematica
(nb),MuPAD(mnb).)
Primitive Operations on Lists
LetL,M,a n dNrepresent lists and let xrepresent an arbitrary expression.
The MPL operations for lists reﬂect the order preserving property:
•First(L). IfLcontains one or more expressions, the operator returns
the ﬁrst expression in L.IfL= [ ], the operator returns the symbol
Undeﬁned . For example,
First([a,b,c])→a.
•Rest(L). IfLcontains one or more expressions, the operator returns
a new list that contains all expressions in Lexcept the ﬁrst expression.
The original list Lis not changed by this operation. If L=[] ,t h e
operator returns the symbol Undeﬁned . For example,
Rest([a,b,c])→[b,c].
•Adjoin (x,L). The operator returns a new list that contains the ex-
pressionxfollowed by expressions in L. The original list Lis not
changed by this operation. For example,
Adjoin (d,[a,b,c])→[d,a,b,c ].
•Join(L,M,...,N ). The operator returns a new list that contains the
expressions in the list Lfollowed by the expressions in Mand so on.
For example,
Join([a,b],[b,c],[c,d,e])→[a,b,b,c,c,d,e ].
2.4. Sets and Lists 73
MPL
 Maple
 Mathematica
 MuPAD
list notation
[a,b,c ]
 [a,b,c]
 {a,b,c }
 [a,b,c]
empty list
[]
 []
 {}
 []
First (L)
 op(1,L)
 First[L]
 op(L,1)
Rest(L)
 [op(2..nops(L),L)]
 Rest[L]
 [op(L,2..nops(L)]
Adjoin (x,L)
 [x,op(L)]
 Prepend[L,x]
 append(L,x)
Join(L,M )
 [op(L),op(M)]
 Join[L,M]
 concat(L,M)
Reverse (L)
 see Fig. 2.24
 Reverse[L]
 see Fig. 2.25
Delete (x,L)
 see Fig. 2.24
 Delete[L,
 listlib ::
Position[L,x]]
 setDifference (L,[x])
x∈L
 member(x,L)
 MemberQ[x,L]
 contains(L,x)
Figure 2.23. List operations in Maple, Mathematica, and MuPAD. (Implemen-
tation:Maple(mws),Mathematica (nb),MuPAD(mnb).)
•Reverse (L). The operator returns a new list with elements of the
listLin reverse order. The original list Lis not changed by this
operation. For example,
Reverse ([a,b,c])→[c,b,a].
•Delete (x,L). This operator returns a new list with all instances of x
removed from L. The original list Lis not changed by this operation.
For example,
Delete (b,[a,b,c,b ])→[a,c].
•List membership, x∈L. The operator returns trueifxis inL,a n d
otherwise returns false. For example,
b∈[a,b,c]→true.
Most computer algebra languages provide lists and most of the list
operations described above (see Figure 2.23). Although Maple does not
provide the Reverse andDelete operators, and MuPAD does not provide
theReverse operator, these operations can be deﬁned with procedures (see
Figures 2.24and2.25).
Exercises
1. Let A={a,b,c,d },B={b,d,e,f },a n dC={a,c,e,f }.
(a) Evaluate
i.A∪B.
ii.A∩B∩C.
74 2. Elementary Concepts of Computer Algebra
Reverse:=proc(L)
#Input
# L: a list#Output
# a new list with the elements of L in reverse order
i fL=[]o r nops(L)=1 then RETURN(L)
else RETURN([op(Reverse([op(2..nops(L),L)])),op(1,L)])
fi
end:
Delete:=proc(x,L)
#Input
# L: a list
#Output# a new list with all instances of x removed from L
local position;
if member(x,L,position) then
RETURN([op(1..position-1,L),
op(Delete(x,[op(position+1..nops(L),L)]))])
else RETURN(L)
fi
end:
Figure 2.24. Mapleproceduresfor ReverseandDelete. (Implementation: Maple
(txt).)
iii. (A∪B)∩C.
iv. (A∪B)∼C.
v.d∈A.
(b) Implement each of the operations in part (a) with a CAS.
2. Let L=[a,b,c,d],M=[b,d,e,f]a n dN=[a,c,e,f].
(a) Evaluate
i.Rest(Join(L, M,N)).
ii.Adjoin(First(L),M).
iii.Join(Delete(a,L),Reverse(N)).
(b) Implement each of the operations in part (a) with a CAS.
2.4. Sets and Lists 75
Reverse := proc(L)
/*Input
L: a list
Output
a new list with the elements of L in reverse order */
beginif L = [ ] or nops(L)=1 then return(L)
else return([op(Reverse([op(L,2..nops(L))])),op(L,1)])
end_ifend_proc:
Figure 2.25. A MuPAD procedure for Reverse. (Implementation: MuPAD
(txt).)
3. Let M=[a,b,c,d].
(a) Give a sequence of MPL statements that performs each of the follow-
ing operations:
i. Obtain the last element of M.
ii. Form a new list with the expression eadded to the end of M.
iii. Form a new list with the second expression removed from M.
(b) Implement each of the operations in part (a) with a CAS.
Further Reading
2.2Expression Evaluation. The evaluation process in computer algebra sys-
t e m si sd e s c r i b e di nF a t e m a n[ 37]. Evaluation in Maple is described in Heal,
Hansen, and Rickard [ 44]. Evaluation in Mathematica is described in Wolfram
[102]. Evaluation in MuPAD is described in Gerhard et al. [ 40].
2.3Mathematical Programs. Programming in Maple is described in Mon-
agan et al. [ 69]. Programming in Mathematica is described in Wolfram [ 102].
Programming in MuPAD is described in Gerhard et al. [ 40].
2.4Sets and Lists. Sets and set operations are described in Maurer and Ral-
ston [65].

3
Recursive Structure of
Mathematical Expressions
This chapter is concerned with the structure of mathematical expressions.
Since mathematical expressions are the data objects in computer algebra,
an understanding of this structure is essential for computer algebra pro-gramming.
In Section 3.1we introduce the concept of recursion and describe a
number of ways it is used in mathematics and mathematical algorithms.In this chapter, recursion’s main role is to describe the structure of ex-
pressions. Since recursion is also an essential programming technique in
computer algebra, this topic is covered in detail in Chapter 5.
In Section 3.2we describe two structural forms for mathematical ex-
pressions that correspond to the internal forms used by computer algebra
systems before and after automatic simpliﬁcation. In addition, we intro-duce four primitive operators that provide a way to analyze and construct
expressions. Finally, in Section 3.3we describe a number of operators, in-
cluding the Free
ofandSubstitute operators, for which the actions depend
primarily on the structure of an expression.
3.1 Recursive Definitions and Algorithms
Inm a t h e m a t i c s ,a recursive deﬁnition or algorithm is one that is deﬁned
in terms of a simpler version of itself or sometimes in terms of just an-
other version of itself. The recursion concept is fundamental to nearly all
of computer algebra. Indeed, recursiveness in one form or another plays
a crucial role in the implementation of many standard operations in com-
77
78 3. Recursive Structure of Mathematical Expressions
puter algebra including simpliﬁcation, substitution, factorization, solution
of equations, diﬀerentiation, and integration. In this section, we give a
brief introduction to recursion, and explain why it plays such an important
role in the manipulation of expressions.
For a simple example, let’s consider the operation n! which we ﬁrst
deﬁne in a non-recursive way:
n!=/braceleftbigg1i f n=0 ,
1·2···(n−1)·nifn>0.(3.1)
Forn≥1, the factorial operation is deﬁned as the product of all integers
from 1 to n. This description does not apply for n=0 . In s t e a d ,w e
deﬁne 0! = 1. This convention is a convenient and consistent one for manyapplications that involve the factorial operation
1.
As a consequence of the deﬁnition ( 3.1), forn>0,n!=n·(n−1)!.
This relationship forms the basis for a recursive deﬁnition of the factorialoperation:
n!=/braceleftbigg1i f n=0 ,
n·(n−1)! ifn>0.(3.2)
This deﬁnition is recursive since for n>0,n!i sd e ﬁ n e di nt e r m so fa
simpler factorial ( n−1)!. In this case the adjective simpler refers to the
factorial operation for a smaller integer value.
The approach in ( 3.2) is more than just another way to deﬁne the
factorial operation; it actually suggests another way to implement the cal-culation. To see what we mean by this, consider ﬁrst a computation based
on the non-recursive deﬁnition ( 3.1). An MPL procedure that performs
this calculation is given in Figure 3.1.
The procedure is expressed in the MPL notation and terminology that is
used throughout the book to describe mathematical algorithms. Althoughwe will have much to say about this aspect of our pseudo-language in
Chapter 4, the examples in this section are simple enough to be understood
without a detailed description of the language.
Here is a brief description of the terminology we use in the procedure.
A procedure deﬁnition in MPL is similar to a function deﬁnition in a con-
ventional programming language. The procedure declaration at the top of
Figure 3.1gives the name Iter
factto the sequence of statements in lines 1
through 7. The procedure can be invoked by a statement such as
Iter
fact(4)→24.
1For example, by deﬁning 0! = 1, the binomial theorem can be expressed in the
compact form
(x+y)n=n
i=0n!
i!(n−i)!xn−iyi.
3.1. Recursive Definitions and Algorithms 79
Procedure Iter
fact(n);
Input
n: non-negative integer;
Output
n!;
Local Variables
f,i;
Begin
1 ifn=0then
2Return(1)
3 else
4 f:= 1;
5 fori=1tondo
6 f:=f∗i;
7Return(f)
End
Figure 3.1. An MPL iterative procedure for n!. (Implementation: Maple(txt),
Mathematica (txt),MuPAD(txt).)
Communication with the procedure is through the input parameter ( nin
this case) and the Return statements in lines 2 and 7. The if-then-else
statement provides a way to select the appropriate course of action as
required by the deﬁnition ( 3.1), and theforstatement provides a loop that
performs the computation. Since this procedure is based primarily on thislooping process, it is called an iterative procedure.
Let’s compare the iterative procedure to a factorial procedure based on
the recursive deﬁnition ( 3.2). First, observe how a numerical computation
b a s e do n( 3.2) proceeds:
4! = 4(3!) = 4(3(2!)) = 4(3(2(1!))) = 4(3(2(1(0!))))
= 4(3(2(1(1)))) (3.3)
=2 4.
To perform the calculation, we repeatedly apply the deﬁnition ( 3.2)u n t i l
the casen= 0 is encountered. Once this point is reached, the value 0!
is replaced by the value 1, and the numerical computation proceeds as
indicated by the parentheses in the second line of Equation ( 3.3).
Although this computation has an iterative ring to it, we can give an
MPL procedure that is a direct translation of the recursive deﬁnition which
does not utilize an explicit iteration statement (see Figure 3.2). Forn>0,
80 3. Recursive Structure of Mathematical Expressions
Procedure Rec
fact(n);
Input
n: non-negative integer;
Output
n!;
Local Variables
f;
Begin
1 ifn=0then
2 f:= 1
3 else
4 f:=n∗Rec
fact(n−1);
5Return(f)
End
Figure 3.2. An MPL recursive procedure for n!. (Implementation: Maple(txt),
Mathematica (txt),MuPAD(txt).)
the operator simulates the looping operation by calling on itself (line 4) to
perform a simpler version of the calculation. A procedure that calls itself
directly (as in this example) or indirectly through a sequence of procedures
is called a recursive procedure .T h e c a s e n= 0 (lines 1 and 2) is referred
to as a termination condition for the procedure since it is deﬁned directly
and does not require further calls on Rec
fact.A s i n E q u a t i o n ( 3.3), for
n>0 the calculation is eventually reduced to the termination condition
that stops the process. Each recursive procedure must have one or more
termination conditions.
TheRec
factprocedure is presented to illustrate simply what is meant
by recursion in mathematics and to show how a recursive procedure isexpressed in MPL. However, there is more to recursive programming than
is shown by this example, and the topic will be discussed in greater detail
in Chapter 5.
Recursive Structure of Expressions
One reason recursion is essential to symbolic computation has to do with
therecursive structure of mathematical expressions. This structure is de-
scribed using the terms in the following deﬁnition:
Definition 3.1. Mathematical expressions are classiﬁed as either atomic
expressions or compound expressions:
3.1. Recursive Definitions and Algorithms 81
1. An atomic expression is an integer, real, symbol, or reserved symbol
(e,∞,true, etc.). The atomic expressions are the atoms or basic
building blocks of more involved mathematical expressions.
2. A compound expression is composed of an operator with operands.
The operator can be an algebraic operator ( +,−, etc.), a relational
operator ( =,<, etc.), a logical operator ( and,or,not), a set oper-
ator ( ∪,∩,∼), a function or operator name, or the terms setor
list. An operand of an operator can be either an atomic expression
or another compound expression. Depending on the operator, each
operator can have one or more operands. /square
Example 3.2. Consider the expression m∗x+b. Since it is common
practice in mathematics to give higher precedence to ∗than +, we view
the expression as a sum with two operands: the compound expression m∗x
and the atomic expression b. The operator ∗has two operands, the atomic
expressions mandb. In a similar way, the equation y=m∗x+bhas the
operator = with two operands, the atom yand the compound expression
m∗x+b. /square
Example 3.3. The expression n! has one operator ! with one operand the
symboln. /square
Example 3.4. Consider the expression Integral (sin(x),x). The Integral
operator has two operands, the compound expression sin( x)a n dt h es y m b o l
x. The function sin( x) has the operator sin with the single operand the
symbolx. /square
Example 3.5. Consider the list [ a,b,c]. In MPL, a list is viewed as a math-
ematical expression with the term listas the operator and the members
of the list, a,b,a n dc, as operands. It may seem odd to think of the term
listas an operator since it is not as “action oriented” as an operator like
+. However, this view of lists gives a uniform structure for all compoundexpressions. In a similar way, the set {a,b,c}is a compound expression
with operator set. /square
Deﬁnition 3.1is a recursive description of a mathematical expression
since a compound expression is constructed with an operator and simpler
expressions (the operands) that are either compound expressions them-
selves or termination symbols (atomic expressions). Although it may sound
as if we are using a recursive deﬁnition to state the obvious, we shall see that
82 3. Recursive Structure of Mathematical Expressions
the recursive structure of expressions implies that a recursive algorithm is
appropriate (or even essential) for many mathematical operations.
Recursion in Mathematics
Although the recursion concept is discussed in textbooks on computer sci-ence, it is rarely mentioned in textbooks on algebra, trigonometry, andcalculus. Therefore, you may ﬁnd it surprising that you often use recursion
when doing pencil and paper manipulations. For example, consider the
algebraic simpliﬁcation of the expression
3·(x+x)+x
2/x→7·x (3.4)
using the simpliﬁcation rules ordinarily found in automatic simpliﬁcation.
To simplify the sum we ﬁrst simplify each of its operands. And to simplify
the ﬁrst operand
3·(x+x), (3.5)
we ﬁrst simplify each of its operands 3 and x+x. The expression 3 is an
atom and requires no further simpliﬁcation. To simplify x+x,w eﬁ r s t
simplify its operands (the two xsymbols which are atoms and require no
simpliﬁcation) and then apply a simpliﬁcation rule to obtain 2 ·x.A tt h i s
point Expression ( 3.5) has been transformed to the form 3 ·(2·x), and we
apply simpliﬁcation rules to obtain 6 ·xfor the ﬁrst term in Expression
(3.4). In a similar way, we simplify the second term in ( 3.4)t oxand apply
the simpliﬁcation rules to 6 ·x+xto obtain 7 ·x.
An outline of the Automatic
 simplify procedure2we have used to sim-
plify this expression is shown in Figure 3.3. This simpliﬁcation process
is recursive since a compound expression uis simpliﬁed by ﬁrst applying
Automatic
 simplify (line 4) to each of its operands (the simpler expres-
sions) followed by an application of the appropriate rules. In fact, any
mathematical operation that involves a systematic examination of all parts
of an expression is most likely recursive.
Recursion can arise in computer algebra for another reason. Many
mathematical problems are solved by transforming the original probleminto another problem. If the new problem involves the same operation as
the original problem, then the process is recursive. For example, consider
the evaluation of the indeﬁnite integral/integraltext
xsin(x
2)dx. Using the substitu-
tionu=x2, the integral is transformed to
/integraldisplay
xsin(x2)dx=/integraldisplaysin(u)
2du.
2The interested reader may consult Cohen [ 24], Section 3.2, for the full version of the
Automatic
 simplify algorithm.
3.1. Recursive Definitions and Algorithms 83
Procedure Automatic
simplify(u);
Input
u: an algebraic expression;
Output
A simpliﬁed version of u;
Begin
1 ifuis an atomic expression then
2Return(u)
3 else
4 v:= the new expression formed by applying the
Automatic
simplifyprocedure to each operand of u;
5 w:= the new expression formed by applying the
appropriate simpliﬁcation rules to v;
6Return(w)
End
Figure 3.3. An outline of an MPL recursive simpliﬁcation procedure.
To evaluate the original integral, the Integral operator must choose the
proper substitution and apply itself to a new integral. Since the integration
is deﬁned in terms of another (simpler) integration, the process is recursive.
In Section 5.3we describe a recursive algorithm for a basic Integral operator
that can evaluate integrals similar to the one above.
Exercises
1. Explain why each of the operations can be viewed as a recursive process,
and give a termination condition for the recursion:
(a) The diﬀerentiation operation.
(b) The operation lim
x→af(x).
(c) Polynomial division.
(d) The expansion of products and powers of polynomials. For example,
i
(x+1)2+2J2(x+3)→x5+7x4+22x3+42x2+45x+27.
2. Describe (in words) a recursive algorithm that ﬁnds the set of symbols in
an expression.
84 3. Recursive Structure of Mathematical Expressions
3.2 Expression Structure and Trees3
Although Deﬁnition 3.1provides a descriptive language for the recursive
structure of an expression, it does not give a scheme for associating aunique structure with an expression. For example, what is the structure of
x+y+z?Isi tt h es u mo f x+yandz,o rt h es u mo f xandy+z,o re v e n
a sum with three operands x,y,a n dz? Since mathematical expressions
are the data objects in computer algebra programming, an understanding
of the relationships between their operators and operands is essential. In
this section we describe two views of expression structure. The ﬁrst, which
is called the conventional structure, corresponds to the structure in both
mathematics and conventional programming languages. The second view,which is called the simpliﬁed structure, corresponds to the structure after
automatic simpliﬁcation.
To simplify matters, we focus initially on the algebraic expressions de-
scribed in the following deﬁnition.
Definition 3.6. Analgebraicexpression uis one that satisﬁes one of the
following rules:
1.uis an integer.
2.uis a symbol.
3.uis a sum, product, power, diﬀerence, quotient, factorial, or function
form, where each operand of uis also an algebraic expression. /square
The algebraic expressions are the ones we manipulate using the trans-
formation rules of elementary algebra. Notice that the deﬁnition is recur-
sive because Rule (3) requires that the operands of a compound algebraicexpression are algebraic expressions.
Example 3.7. The expressions
2,1/2,sin(x),x∧2+c o s (x),f(x,y,z)
are algebraic expressions, while
[a,b,c],x+1=2,aandb
are not. /square
3In this section, to help clarify expression structure, we use ∗for the multiplication
operator and ∧for the power operator.
3.2. Expression Structure and Trees 85
Operator Classification
The following terminology for operators is used to describe expression struc-
ture.
Definition 3.8. Two operators in an algebraic expression uare atdiﬀerent
parentheses levels if one of the operators is inside a pair of matching
parentheses, while the other is not. On the other hand, when two operators
are not at diﬀerent levels, they are considered at the same parentheses
level.
Example 3.9. Ina∗(b+c), the operators ∗and + are at diﬀerent parentheses
levels. In a∗(b+c)/d, the operators ∗and/are at the same level, while
+ is at a diﬀerent level from either one of them. /square
Operators in an expression are also classiﬁed according to the number
of operands and the location of the operands relative to an operator. These
properties are described with the following terminology:
•Aunary postﬁx operator is one with one operand that immediately
precedes the operator. For example, in n!, the factorial operator is a
unary postﬁx operator.
•Aunary preﬁx operator is one with one operand that immediately
follows the operator. For example, in −x, the diﬀerence operator is
a unary preﬁx operator.
•Afunction preﬁx operator is an expression in function notation with
one or more operands. For example, in f(x,y), the function name f
is a function preﬁx operator with two operands xandy.
•Abinary inﬁx operator is one with two operands, one that immedi-
ately precedes the operator and the other that immediately followsthe operator. For example, in a+b, the + is a binary inﬁx operator.
Furthermore, with the conventional view of expressions (described
below), both + operators in a+b+care binary inﬁx operators. In
this view, the ﬁrst + has operands aandb, and the second + has
operandsa+bandc.
•Ann-ary inﬁx operator is one with two or more operands that are
adjacent to some occurrence of the operator at the same parentheses
level. For example, in the simpliﬁed view of algebraic expression
structure (described below), both + and ∗are n-ary inﬁx operators.
Int h i sv i e w , a+b+c+dis an n-ary sum with four operands a,b,c,
andd.
86 3. Recursive Structure of Mathematical Expressions
Conventional Structure of Algebraic Expressions
Theconventional structure of an expression is similar to the structure as-
sumed in both mathematics and conventional programming languages, and,
in some computer algebra languages, corresponds to the structure before
automatic simpliﬁcation. The following structural assumptions (Deﬁni-tion3.10) and precedence rules (Deﬁnition 3.11) describe the conventional
structure of an expression.
Definition 3.10. (Structuralassumptionsforconventionalalgebraic
expressions.) Letube an algebraic expression. The algebraic operators
inusatisfy the following structural assumptions:
1. The operators +and−are either unary preﬁx or binary inﬁx opera-
tors.
2. The operators ∗,/,a n d ∧are binary inﬁx operators.
3. The operator !is a unary postﬁx operator.
The relationship between operators and operands is deﬁned by the fol-
lowing operator precedence rules.
Definition 3.11. (Conventional precedence rules.) Letube an alge-
braic expression.
1. The relative precedence of operators in uat the same parentheses level
is given by the precedence hierarchy4
(highest level)
functionnames
!
∧
∗,/
+,−
(lowest level).
If one operator is below another in the table, that operator has lower
precedence. If two al gebraic operators in uare at the same level in
the table, the relative precedence is determined by the following rules:
(a) If the operators are +or−operators, ∗or/operators, or !
operators, then the operator to the right has lower precedence.
4Some authors assign unary + and −higher precedence than ∗and/.W e d o n o t
make this distinction here.
3.2. Expression Structure and Trees 87
(b) If the operators are ∧operators, then the operator to the left has
lower precedence.
2. For two operators at diﬀerent parentheses levels, the operator outside
a pair of parentheses has lower precedence than the operator inside
the parentheses.
When an expression is adjacent to two operators, it is an operand of
the operator with highest precedence.
Example 3.12. Inm∗x+b, the operator + has lower precedence than ∗
which implies the expression is equivalent to ( m∗x)+b.
Ina∗b∗c, both operators operate in a binary fashion and the ∗on the
right has lower precedence than the ∗on the left. From the conventional
viewpoint, this expression is equivalent to ( a∗b)∗c.
In2∗sin(x+ 1), the operator ∗has lowest precedence, the function
name sin is next, and the operator + has highest precedence.
Finally, in a∗b∧c∧d∗e, the operators in order of lowest to highest
precedence are: the ∗on the right, the ∗on the left, the ∧on the left,
and the ∧on the right. From a conventional viewpoint, this expression is
equivalent to ( a∗b∧(c∧d))∗e. /square
Expression Trees
The structure of an expression comprises the relationships between its op-
erators and operands. An expression tree is a diagram that displays this
structure. For example, the expression
c+d∗x∧2 (3.6)
is represented by the expression tree in Figure 3.4.
Each operator and atom in an expression is represented by a position or
nodein the tree. The contents of the nodes and the relationships between
the nodes are determined by the operator precedence rules. The operator
with lowest precedence in an expression appears at the top of the tree.
This top node is called (oddly enough) the root node of the tree. According
to the precedence rules, the operator + has lowest precedence in c+d∗
x∧2, and so appears at the root. This root operator is also called the
main operator of the expression, a designation that emphasizes that c+
d∗x∧2 is viewed as a sum with two operands candd∗x∧2. The lines
that emanate below an operator node connect the operator to each of its
operands, and the part of the tree that represents an operand is called a
branch orsub-tree . In this case, the ﬁrst operand of + is the symbol c,
which is represented by the left branch with a node containing c.T h er i g h t
88 3. Recursive Structure of Mathematical Expressions
❅
❅
❅
❅ 
  
 
❅
❅
 
 
xd+
c ∗
∧
2
Figure 3.4. The conventional expression tree for c+d∗x∧2.
branch, which represents the expression d∗x∧2, is constructed by applying
the above process (recursively) to this sub-expression. The main operatorof this branch is ∗, and the two branches correspond to the operands dand
x∧2. Continuing in this fashion, we construct the tree that represents the
structure of the expression
5.
Example 3.13. Figure 3.5(a) contains the expression tree for −a∗(b+c).
Notice that the operator −has lower precedence than ∗and therefore
appears at the root node of the tree.
Figure 3.5(b) contains the expression tree for Integral (sin(x),x). The
operator Integral , which has lowest precedence, appears at the root node
of the tree, and the two operands sin( x)a n dxare branches that emanate
from this node. In a similar way, the function name sin appears at the root
of the branch for sin( x).
Figure 3.5(c) contains the expression tree for 1 /(a∗x∗y).In the con-
ventional view, both ∗operators act in a binary fashion. /square
5In Mathematica, the operator TreeForm[u] displays the tree structure of an expres-
sion. However, the displayed structure corresponds to the simpliﬁed structure described
in Deﬁnition 3.14 and Deﬁnition 3.16.
In MuPAD, the operator prog::exprtree displays the tree structure. The con-
ventional structure is obtained with prog::exprtree(hold(u)) , while the simpli-
ﬁed structure (described in Deﬁnition 3.14 and Deﬁnition 3.16) is obtained with
prog::exprtree(u) . In MuPAD, the conventional structure is similar to the structure
described here with two modiﬁcations. First, both + operators and ∗operators are
represented as n-ary operators. Next, numerical fractions have a special form with the
operator DOM
RATat the root.
The current release of Maple (7) does not have an operator to display the tree. How-
ever, the tree structure can be obtained using the structure operators (see Figure 3.18
on page 106).
3.2. Expression Structure and Trees 89
❅
❅ 
  
 
❅
❅
−
b∗
+
ca
(a) A conventional expression tree for −a∗(b+c).
❅❅
  
sinIntegral
x
x
(b) A conventional expression tree for Integral (sin(x),x).
❅❅
  ❅❅
    ❅❅
/
y
a x∗∗ 1
(c) A conventional expression tree for 1 /(a∗x∗y).
Figure 3.5. Conventional expression trees.
90 3. Recursive Structure of Mathematical Expressions
Simplified Structure of Algebraic Expressions
Since mathematical expressions encountered as data objects in computer
algebra programs are in automatically simpliﬁed form, the structure of
these expressions is particularly important to us. This simpliﬁed structure(described below) simpliﬁes the programming process by eliminating ex-
traneous operators from an expression and by providing easier access to
its operands. The following structural assumptions (Deﬁnition 3.14)a n d
precedence rules (Deﬁnition 3.16) describe some properties of simpliﬁed ex-
pressions.
Definition 3.14. (Structural assumptions for simpliﬁed algebraic
expressions) Letube an automatically simpliﬁed algebraic expression.
The operators in usatisfy the following structural assumptions:
1. The operator +is an n-ary inﬁx operator with two or more operands
and none of its operands is a sum. In addition, at most one operandof+is an integer or fraction.
In the simpliﬁed view, the expression a+b+cis viewed as a sum with three
operands a,b,a n dcrather than the conventional view as a binary sum
with operands a+bandc(see Figure 3.6(a)). Furthermore, the expression
a+(b+c) is not in automatically simpliﬁed form because one of the operands
of the main operator + is also a sum. Indeed, the automatically simpliﬁed
form of this expression is a+b+c. Finally, Rule (1) implies that the unary
sum +xis not automatically simpliﬁed because a sum must have at least
two operands. The simpliﬁed form of + xisx.
2. The operator ∗is an n-ary inﬁx operator with two or more operands
and none of its operands is a product. In addition, at most oneoperand of ∗is an integer or fraction, and when an integer or fraction
is an operand of a product, it is the ﬁrst operand
6.
This rule implies the simpliﬁed form of a∗2∗(b∗c) is the n-ary product
2∗a∗b∗c.
3. The unary operator −and the binary operator −do not appear in
simpliﬁed expressions.
6In both Maple and Mathematica, an integer or fraction operand in a product is the
ﬁrst operand.
In MuPAD, however, an integer or fraction operand in a product is represented inter-
nally as the last operand even though the displayed form indicates it is the ﬁrst operand.Since some algorithms in later chapters assume an integer or fraction in a product is theﬁrst operand, the MuPAD implementations are modiﬁed to account for this diﬀerence.
3.2. Expression Structure and Trees 91
  ❅❅
  ❅❅
✟✟✟✟
❍❍❍❍
b a+
c + a b c+
conventional simpliﬁed
(a) Conventional and simpliﬁed structures for a+b+c.
  
  ❅❅
❅❅  
  ❅❅
❅❅
2a−
b∗
b∗+
a
−2
conventional simpliﬁed
(b) Expression trees for a−2∗band its simpliﬁed form a+(−2)∗b.
❅❅
❅❅
    
❅❅
  
✟✟✟✟
❍❍❍❍
✟✟✟✟
❍❍❍❍−
∗
x/
y 33 −1y x∗
fraction
conventional simpliﬁed
(c) Expression trees for −x∗y/3 and its simpliﬁed form ( −1/3)∗x∗y.
Figure 3.6. Conventional and simpliﬁed expression trees.
92 3. Recursive Structure of Mathematical Expressions
This rule implies the expression −xis not automatically simpliﬁed. The
simpliﬁed form of this expression is the product ( −1)∗x,w h e r et h e −sign
in the parentheses is not considered a unary operator, but instead is part
of the integer negative one. In a similar way, the automatically simpliﬁedform of the expression a−2∗bisa+(−2)∗b(see Figure 3.6(b)).
4. The binary operator /does not appear in simpliﬁed expressions.
Simpliﬁed quotients are represented using products, powers, and special
forms for fractions (described below). For example, the simpliﬁed form for
1/cisc
−1and the simpliﬁed form for c/d2isc∗d−2.
5. Numerical fractions satisfy the following:
(a)A quotient that represents a fraction c/d,w h e r ec/negationslash=0andd/negationslash=0
are integers is represented by an expression tree with operator
the symbolfraction ,ﬁ r s to p e r a n d c, and second operand d.
(b)A negative fraction has a negative numerator and positive de-
nominator.
This rule implies that the expression 1 /2 is not viewed as a quotient but
instead as an expression with operator fraction and operands 1 and 2. In
addition, the expression −1/2 has the operator fraction and operands −1
and 2.
6. The operator ∧is a binary operator. In addition, if u=v∧n,w h e r e
nis an integer, then vcannot be an integer, fraction, product, or
power.
This rules implies the following: ( a∗b)∧2 has the simpliﬁed form ( a∧2)∗
(b∧2); (x∧2)∧3 has the simpliﬁed form x∧6; and 3−1has the simpliﬁed
form the fraction 1 /3.
7. The operator !is a unary postﬁx operator whose operand is not a
non-negative integer.
This rule implies that the simpliﬁed form of 3! is 6.
Example 3.15. Consider the conventional expression −x∗y/3. Figure 3.6(c)
shows the expression trees for the conventional and simpliﬁed forms ofthis expression. Using Rules (3) and (4), the unary minus and quotient
operators are removed. Therefore, using the Rules (2), (5), and (6), the
simpliﬁed structure is (( −1)/3)∗x∗y,w h e r e ∗is an n-ary operator with
three operands, the −is part of the integer −1, and the fraction ( −1)/3
has main operator fraction . /square
3.2. Expression Structure and Trees 93
Definition 3.16. (Simpliﬁed precedence rules) Letube an automati-
cally simpliﬁed algebraic expression.
1. The relative precedence of operators in uat the same parentheses level
is given by the precedence hierarchy
(highest level)
functionnames
fraction
!
∧
∗
+
(lowestlevel)
If two !operators are at the same parentheses level, then the one to
the right has lower precedence. If two ∧operators are at the same
parentheses level, then one to the left has lower pr ecedence.
2. For operators at diﬀerent parentheses levels, operators outside a pair
of parentheses have lower precedence than operators inside the paren-
theses.
Because of the structural assumptions, the precedence rules for simpli-
ﬁed expressions are simpler than those for conventional expressions. For
example, since multiple occurrences of the + operator at the same paren-
theses level coalesce to a single operator in an expression tree, there is noneed to account for this situation in the precedence rules. Notice that the
fraction operator has higher precedence than ∗,∧, and ! so that a frac-
tion is isolated as an operand relative to these operators. This point is
illustrated in Figure 3.6(c).
Using the structural assumptions in Deﬁnition 3.14and the precedence
rules in Deﬁnition 3.16, the deﬁnition of an algebraic expression can be
modiﬁed in the following way.
Definition 3.17. An expression uis anautomatically simpliﬁedalge-
braic expression (ASAE) if it satisﬁes one of the following rules:
1.uis an integer.
2.uis a fraction c/dwherec/negationslash=0,d/negationslash=0are integers.
3.uis a symbol.
94 3. Recursive Structure of Mathematical Expressions
4.uis a sum, product, power, factorial, or function form, where each
operand of uis also an automatically simpliﬁed algebraic expression.
Although the structural assumptions and precedence rules describe
some important properties of automatically simpliﬁed expressions, they
are not by any means a complete description of these expressions. For
example, the structural assumptions do not describe all the ordering prop-
erties of operands in sums and products, the properties of powers or the
special rules involving the integers 0 and 1. Since a complete descriptionof automatically simpliﬁed expressions is quite involved, it is not included
here
7. At this point our intent is to give a description that is suﬃcient to
begin computer algebra programming. Additional structural rules can befound by experimentation with computer algebra software (see Exercise 3).
Most computer algebra systems use an internal form for automatically
simpliﬁed algebraic expressions that is similar to the one described here,although the displayed form may disguise the actual structure. We illus-
trate this point in Figure 3.7, which shows a Mathematica session together
with the simpliﬁed structure of a/b+c−d. The command TreeForm at
In[2] displays a representation of the expression tree. Observe that the dis-
played form of the simpliﬁed expression at Out[1] includes the quotient and
diﬀerence operators, even though the Mathematica internal tree structure
does not.
Since the simpliﬁed structure of an expression may not be apparent
from its displayed form, an operator may transform an expression in an
unexpected way. To illustrate this point, consider the Maple dialogue in
Figure 3.8that obtains the derivative of f(x)/g(x). Since the simpliﬁed
form of this expression is f(x)∗g(x)
(−1), the derivative is obtained with
the diﬀerentiation product and power rules rather than the quotient rule.
Similar results are obtained with both Mathematica and MuPAD.
Functions Transformations for Exponential Functions
and Powers in Automatic Simplification
In ordinary mathematical notation, the expressions exand exp(x)a r et w o
forms that are used to represent the exponential function. Some computer
algebra systems allow both representations for input but may use only
one form in automatically simpliﬁed expressions. In a similar way, a CAS
may allow both√
x(or sqrt(x)) andx1/2for the square root function, but
7For this description, consult Cohen [ 24], Chapter 3, where a complete description
is needed for an algorithm that transforms an algebraic expression to automaticallysimpliﬁed form.
3.2. Expression Structure and Trees 95
In[1]:= a/b+c−d
Out[1]=a
b+c−d
In[2]:= TreeForm[a/b+c−d]
Out[2] //TreeForm =
Plus[ | ,c ,| ]
Times[a ,| ]T i m e s [ −1,d]
Power[b ,−1]
Times
 Times✟✟✟✟✟✟✟✟❍❍❍❍❍❍❍❍
 
  
❡
❡
❡❡ 
 
  ❅
❅❅
❅
❅❅
 
  Plus
Power
−1−1a
bc
d
Figure 3.7. A Mathematica session with the simpliﬁed structure for the expres-
siona/b+c−d.
choose one internal simpliﬁed form for both. In MPL, we represent the
exponential function with the function form exp( x)a n dt h es q u a r er o o t
function with the power x1/2.InF i g u r e 3.9,w eg i v et h er e p r e s e n t a t i o n so f
these functions in Maple, Mathematica, and MuPAD.
96 3. Recursive Structure of Mathematical Expressions
> u := f(x)/g(x);
u:=f(x)
g(x)
> diff(u, x);
∂
∂xf(x)
g(x)−f(x)(∂
∂xg(x))
g(x)2
Figure 3.8. A Maple dialogue that shows that the derivative of f(x)/g(x)i s
obtained with the product rule and power rule.
expression
 MPL
 Maple
 Mathematica
 MuPAD
exp(x)
exp(x)
exp(x)
 Ex
exp(x)
ex
exp(x)
exp(1)x
Ex
exp(x)
√
x
x1/2
x1/2
x1/2
x1/2
x1/2
x1/2
x1/2
x1/2
x1/2
Figure 3.9. Simpliﬁed structure of the exponential and power functions in MPL,
Maple, Mathematica, and MuPAD.
Simplified Structure for Non-Algebraic Expressions
We describe brieﬂy some issues related to the structure of expressions that
include relational operators, logical operators, lists, and sets. For these
expressions, the internal forms are more involved and, in some cases, varyfrom system to system.
Relationalexpressions. For expressions with one relational operator
(=,<, etc.), most systems use a binary structure with relative precedence
levels for relational operators below the levels for algebraic operators. Fig-
ure3.10gives the simpliﬁed structure for the expression for x+1<2∗x.
Maple, Mathematica, and MuPAD use a similar internal form for this ex-
pression.
Both the Mathematica and MuPAD systems provide for more involved
relational expressions that contain two or more relational operators. For ex-
ample, in Figure 3.11we show the internal form for the expression x<y<z
in these systems. Observe that Mathematica represents the expression us-
ing an n-ary form, while MuPAD uses a nested binary form.
3.2. Expression Structure and Trees 97
 
 
  ❅
❅
❅❅
❅
❅
 
 ❅
❅ 
 
2 x+
x∗<
1
Figure 3.10. The MPL simpliﬁed structure for the expression x+1<2∗x.
Figure 3.12gives the internal forms in Mathematica and MuPAD for
the expression x≤y<z , which has two diﬀerent relational operators.
Observe that Mathematica represents the expression using a form thatincludes relational operators as operands of the main operator Inequality ,
while MuPAD represents this expression using a nested binary form.
Finally, in both the Maple and MuPAD systems, expressions with >
and≥are converted by automatic simpliﬁcation to equivalent expressions
with<and≤. For example, in both of these systems, a>b is simpliﬁed
tob<a.
Logical expressions. The relative precedence levels of the logical
operators is
(lowest)
not
and
or
(highest),
and the logical operators have lower precedence than relational operators.
Although logical expressions are used primarily as Boolean tests in both
decision and looping structures, some computer algebra languages allow
logical expressions as program statements or data objects. For example,the expression
pornotqandr
is a mathematical expression with structure shown in Figure 3.13(a).
98 3. Recursive Structure of Mathematical Expressions
 
 
  ❅
❅
❅❅
Less
xyz
(a) Mathematica
❅
❅
❅❅ 
 
  
 
 
  ❚
❚
❚❚
less
less
xyz
(b) MuPAD
Figure 3.11. The internal form for x<y<z in Mathematica and MuPAD.
(Implementation: Mathematica (nb),MuPAD(mnb).)
InF i g u r e 3.13(b), we show the structure of an expression with logical,
relational, and algebraic operators. Maple, Mathematica, and MuPADallow expressions to be used in this way
8.
In Mathematica and MuPAD, logical expressions have simpliﬁed forms
in which both the andandoroperators are n-ary inﬁx operators with
8In Maple, there is one curious exception to this statement. Suppose x,y,a n d
zare unassigned symbols. Although, in this system, the expression x<y and y<z
is not changed by automatic simpliﬁcation, the similar expression x<y and y =zis
transformed to false . This occurs since, in this context, y=zevaluates to false because
yand zare distinct symbols. On the other hand, the expression y=zby itself remains
unchanged by automatic simpliﬁcation.
3.2. Expression Structure and Trees 99
✁
✁
✁✁❜❜❜❜❜❜L
L
LL❅
❅
❅❅✧✧✧✧✧✧
Inequality
LessEqual Lessxy z
(a) Mathematica
❅
❅
❅❅ 
 
  
 
 
  
❚
❚
❚❚
leequal
less
xyz
(b) MuPAD
Figure 3.12. The internal form for the expression x≤y<zin Mathematica and
MuPAD. (Implementation: Mathematica (nb),MuPAD(mnb).)
operands of a diﬀerent type. (For example, the operator andcannot have
an operand that is also an and.) In Figure 3.14(a),(b), we give Mathemat-
ica and MuPAD representations of the simpliﬁed form of the expression
worxandyornotz (3.7)
which has two oroperators at the same level.
On the other hand, in the Maple system, the simpliﬁed forms for and
andorremain as binary operators. The internal form for Expression ( 3.7)
in this system is shown in Figure 3.14(c).
100 3. Recursive Structure of Mathematical Expressions
. 
  
 
  
❅
❅❅
❅
❅❅and
notp
qror
(a) The MPL simpliﬁed structure for the expression pornotqandr.
 
  
 
❅
❅
❅
❅
❅
❅
❅❅
❅
❅
 
 
 
 
  
and
<
x + y
xy1<
(b) The MPL simpliﬁed structure for the expression x<yandx+y<1.
Figure 3.13. MPL structures for logical expressions.
Sets and Lists. In MPL, both sets and lists are viewed as expressions
with main operator setorlistalong with operands that are the expressions
in the set or the list. In addition, the expression tree for the empty set ∅or
empty list [ ] is the tree with a single node setorlist.F i g u r e s 3.15(a),(b)
illustrate the tree structures for expressions with sets and lists. Both Maple
and MuPAD represent sets and lists in this way. Mathematica, which uses
the brace notation {and}f o rb o t hs e t sa n dl i s t s ,u s e st h es y m b o l Listas
the main operator for these expressions
3.2. Expression Structure and Trees 101
Or
✔
✔✔L
LL
◗◗◗◗◗◗
##
###
Not And
zy xw
(a) Mathematica
y
❚
❚❚
✡
✡✡
◗◗◗◗◗◗
 ✚✚✚✚✚
and
xnot
zor
w
(b) MuPAD
or
or✪
✪✪❅
❅❅

✜
✜✜
❚
❚❚
✡
✡✡
xand
ynot
w z
(c) Maple
Figure 3.14. The simpliﬁed structure of the expression worxandyor not z
in Mathematica, MuPAD, and Maple.
102 3. Recursive Structure of Mathematical Expressions
✏✏✏✏✏
✁✁❆❆PPPPPset
ab c d
(a) The MPL simpliﬁed structure for the set {a,b,c,d }.
 
 ❅
❅
❅
❅ 
 list
b ac +
(b) The MPL simpliﬁed structure for the list[ a+b,c].
Figure 3.15. Expression tress for a set and a list.
In some CAS languages, the set operators ( ∪,∩,∼), can have symbols
(instead of sets) as operands and these expressions can act as data objects.When used in this way, these expressions have a simpliﬁed form where
∪and∩are n-ary operators with operands of a diﬀerent type, and ∼is
a binary operator. (For example, in simpliﬁed form, ∪cannot have an
operand that is also a ∪.) Both Maple and MuPAD allow set expressions
to be used in this way, although the operator precedence levels are not
the same. In Figure 3.16, we give the relative precedence levels of these
MPL
∩
∼
∪Maple
intersect
union,minusMuPAD
intersect
minus
union
Figure 3.16. The relative precedence of set operations in MPL, Maple, and
MuPAD.
3.2. Expression Structure and Trees 103
operators in MPL, Maple, and MuPAD. Observe that in both MPL and
MuPAD the operators are at three diﬀerent levels, while in Maple union
andminus are at the same level.
InF i g u r e 3.17, we give the simpliﬁed representations in Maple and Mu-
PAD for the expression
A∪B∪C∩D∼E.
C
 D✪
✪✪❅
❅❅
✜
✜✜
❧
❧❧
✪✪❡❡E∼
A∪
∩B
(a) Maple
C
 D✜
✜✜
❧
❧❧
❡❡
✔✔❏❏✪✪AB
E ∩∪
∼
(b) MuPAD
Figure 3.17. The structure of the expression A∪B∪C∩D∼Ein Maple and
MuPAD.
104 3. Recursive Structure of Mathematical Expressions
Observe that the meaning of the expression in Maple is
(A∪B∪(C∩D))∼E,
while the meaning in MuPAD is
A∪B∪((C∩D)∼E).
Primitive Operations on Simplified Mathematical Expressions
In order to analyze and manipulate a mathematical expression, we must
access its operators and operands. MPL uses three primitive operators toperform these tasks.
Definition 3.18. The operator
Kind(u)
is deﬁned by the following rules:
1. Ifuis an atomic expression, Kind (u)returns the type of expression
(e.g.,integer ,real,o rsymbol ).
2. Ifui sac o m p o u n de x p r e s s i o n ,K i n d (u)returns the operator at the
root of the expression tree.
Example 3.19.
Kind(x)→symbol,
Kind(3)→integer,
Kind(2.1)→real,
Kind(π)→symbol,
Kind(m∗x+b)→+,
Kind((a+b)∗sin(x∧2))→∗,
Kind((a/b)→∗,
Kind(2/3)→fraction,
Kind(sin(x))→sin,
Kind(a=b)→=,
Kind({a,b,c,d })→set,
Kind(xandy)→and,
Kind(x−x+2 ) →integer.
3.2. Expression Structure and Trees 105
In the last example, the operand is simpliﬁed by automatic simpliﬁcation to
the integer 2. (Implementation: Maple (mws), Mathematica (nb),MuPAD
(mnb).) /square
Definition 3.20. Ifuis a compound expression, the operator
Number
 of
operands (u)
returns the number of operands of the main operator of u.I fuis not a
compound expression, then Number
 of
operands returns the global symbol
Undeﬁned .
Example 3.21.
Number
 of
operands (m∗x+b)→2,
Number
 of
operands (f(x,y))→2,
Number
 of
operands ({a,b,c,d })→4,
Number
 of
operands (n!)→1,
Number
 of
operands (x)→Undeﬁned .
In the last example, the input expression xis not a compound expression.
(Implementation: Maple (mws), Mathematica (nb),MuPAD (mnb).) /square
Definition 3.22. Ifuis a compound expression, the operator
Operand (u,i)
returns the ithoperand of u.I fuis not a compound expression or u
does not have an ithoperand, then Operand returns the global symbol
Undeﬁned .
Example 3.23.
Operand (m∗x+b,2)→b,
Operand (x∧2,1)→x,
Operand (Operand (m∗x+b,1),2)→x,
Operand ({a,b,c,d },2)→b,
Operand (x−x,1)→Undeﬁned ,
Operand (2/(−3),2)→3.
The last two examples are based on the simpliﬁed form of the expression.
(Implementation: Maple (mws), Mathematica (nb),MuPAD (mnb).)
106 3. Recursive Structure of Mathematical Expressions
MPL
 Maple
 Mathematica
 MuPAD
Kind (u)
 whattype(u)
 Head(u)
 type(u)
and
 and
op(0,u)
 op(u,0)
for function
 for undeﬁned
names
 function names
Operand (u,i)
 op(i,u)
 Part[u,i]
 op(u,i)
and Numerator[u]
and Denominator[u]
for fractions
Number
 of
operands (u)
 nops(u)
 Length[u]
 nops(u)
Construct (f,L)
 see Figure 3.19
 Apply[f,L]
 see Figure 3.20
Figure 3.18. The primitive MPL structural operators in Maple, Mathematica,
and MuPAD.
Keep in mind, because automatic simpliﬁcation in a computer algebra
system may apply the commutative law to reorder the operands in a sumor product, the Operand operator may obtain an unexpected result. For
example, if b+ais reordered to a+b,w eo b t a i n
Operand (b+a,2)→b./square
The operators Kind,Number
of
operands ,a n d Operand are the three
basic operations that are used to analyze and manipulate mathematical
expressions, and most computer algebra systems have versions of these
operators (see Figure 3.18).
Construction of Expressions
In some instances, we need to construct an expression with a given operator
and list of operands. The MPL operator Construct is used for this purpose.
Definition 3.24. Letfbe an operator ( +,∗,=, etc.) or a symbol, and let
L=[a,b,...,c ]be a list of expressions. The operator
Construct (f,L)
returns an expression with main operator fand operands a,b,...,c .
Example 3.25.
Construct (” + ”,[a,b,c])→a+b+c,
Construct (”∗”,[a+b,c+d,e+f])→(a+b)∗(c+d)∗(e+f),
Construct (g,[a,b,c])→g(a,b,c),
(Implementation: Maple (mws), Mathematica (nb),MuPAD (mnb).) /square
3.2. Expression Structure and Trees 107
Construct := proc(f,L)
local g,s;
if f = ‘!‘ then RETURN(op(L)!);elif member(f,{‘and‘,‘or‘}) then RETURN(convert(L,f))
elif f = ‘not‘ then RETURN(not op(L))
elif f = set then RETURN({op(L)})elif f = list then RETURN(L)
else s := subsop(0=f,g(op(L))); RETURN(eval(s))
fi
end:
Figure 3.19. A Maple procedure to implement MPL’s Construct operator. (Im-
plementation: Maple(txt).)
Construct := proc(f,L)
begin
if f = _divide then return(op(L,1)/op(L,2))
elif f = _subtract of f = _negate then return(op(L,1)-op(L,2))elif f = DOM_SET then return({op(L)})
elif f = DOM_LIST then return(L)
else return(f(op(L)))end_if
end_proc:
Figure 3.20. A MuPAD procedure to implement MPL’s Construct operator.
(Implementation: MuPAD(txt).)
While Mathematica has an operator that constructs expressions (see
Figure 3.18), Maple and MuPAD do not. However, in both of these lan-
guages, the operation can be simulated with a procedure (see Figures 3.19
and3.20).
Exercises
1. Experiment with a CAS to determine the simpliﬁed structure of the ex-
pressions in Figure 3.6. Are the structures the same as those shown in the
ﬁgure?
108 3. Recursive Structure of Mathematical Expressions
2. For each of the following, give the conventional and simpliﬁed structures
of the expression. In addition, for each of the expressions, compare the
simpliﬁed structure based on the rules in thetext to the simpliﬁed internal
structure in a CAS.
(a)a/b−c/d.
(b) (x∧a)∧3.
(c) (x∧2)∧(1/2).
(d)3
2∗a∗(x−1).
(e) (−2∗x)∧(−3).
(f) ((x−y)+z)+w.
(g) ((x−y)∗y/2)∧2.
(h)x∧2−1
x−1.
(i)1
x∧y.
(j)−x∗(a/b)
c.
(k)2
a+b∗3
c+d.
(l)x∧2+cos(1 /x−2).
(m)x=−b+(b∧2−4∗a∗c)∧(1/2)
2∗a.
3. Experimentwith a CASto determinesome additional structuralrules that
describe automatically simpliﬁed algebraic expressions. For example:
(a) Can a sum or product have two identical operands?
(b) How are operands in sums and products combined?
(c) Can the ﬁrst operand of the power operator ∧also be a power?
(d) What are the special rules that involve 0 and 1? For example, can a
0 or 1 be an operand of a sum, product, power, or factorial?
Exercise1on page55is helpful for this exercise. For further discussion of
structural assumptions for automatically simpliﬁed algebraic expressions,
see Cohen [ 24], Chapter 3.
3.3 Structure-Based Operators
In this section we describe four operators for which the operations are based
only on the simpliﬁed structure of an expression. First, we introduce the
terminology that is used in the deﬁnitions of these operators.
3.3. Structure-Based Operators 109
 
 
❍❍❍❍
✟✟✟✟
❍❍❍❍
 
 ❅
❅
sin
2 c∧ b 1+
a∗
Figure 3.21. A simpliﬁed expression tree for sin( a)∗(1+b+c∧2).
Complete Sub-Expressions
Definition 3.26. Letube an automatically simpliﬁed expression. A com-
plete sub-expression ofuis either the expression uitself or an operand
of some operator in u.
In terms of expression trees, the complete sub-expressions of uare either
the expression tree for uor one of its sub-trees.
Example 3.27. Consider the expression
sin(a)∗(1 +b+c∧2), (3.8)
which has the expression tree shown Figure 3.21. This expression contains
the following complete sub-expressions:
sin(a)∗(1 +b+c∧2),sin(a),a ,
1+b+c∧2,1,b ,c ∧2,c ,2.
There are some parts of an expression that are sub-expressions in a math-
ematical sense but are not complete sub-expressions. For example in Ex-
pression ( 3.8), 1 +bis not a complete sub-expression since it is not the
operand of an operator. /square
110 3. Recursive Structure of Mathematical Expressions
TheFree
 ofOperator
TheFree
ofoperator determines if an expression uis free of an expression t
(or does not contain t).
Definition 3.28. Letuandt(for target) be mathematical expressions. The
operator
Free
of(u,t)
returnsfalse whentis identical to some complete sub-expression of uand
otherwise returns true.
Example 3.29.
Free
of(a+b, b)→false,
Free
of(a+b, c)→true,
Free
of((a+b)∗c, a+b)→false,
Free
of(sin(x)+2∗x,sin(x))→false,
Free
of((a+b+c)∗d, a+b)→true, (3.9)
Free
of((y+2∗x−y)/x, x)→true, (3.10)
Free
of((x∗y)2,x∗y)→true. (3.11)
In Statement ( 3.9),a+bis not a complete sub-expression of ( a+b+c)∗dand
so the operator returns true. In Statement ( 3.10), automatic simpliﬁcation
simpliﬁes the ﬁrst operand to 2 and so the expression no longer contains anx. In a similar way, in Statement ( 3.11) automatic simpliﬁcation transforms
(x∗y)
2tox2∗y2which gives the output true. (Implementation: Maple
(mws), Mathematica (nb),MuPAD (mnb).) /square
To perform Free
of(u,t), each complete sub-expression of uis checked
to determine if it is structurally identical to the target t. This is easily done
using a recursive search through the expression tree. Brieﬂy, the process
goes as follows: ﬁrst compare utot,a n di fu=tthe search is done and
falseis returned. If u/negationslash=tanduis an atom, there is nowhere else to
search and so trueis returned. On the other hand, if u/negationslash=tanduis
a compound expression, the search continues by recursively applying theprocess just described to each of the (simpler) operands of u.C o n t i n u i n g
in this fashion, we compare tto each of the complete sub-expressions of u.
For example, if u=3∗x+y∗(z+ 2), the scheme compares a target tto
the complete sub-expressions of uin the following order:
3∗x+y∗(z+2 ),3∗x,3,x ,y ∗(z+2 ),y ,z +2,z ,2.
3.3. Structure-Based Operators 111
MPL
 Maple
 Mathematica
 MuPAD
Free
of(u,t)
 not(has(u,t))
 FreeQ[u,x]
 not(has(u,t))
Substitute (u,t=r)
 subs(t=r,u)
 ReplaceAll [u,t->r]
 subs(u,t=r)
or
u /.t ->r
Sequential
 substitute
(u,[t1=r1,t2=r2])
subs(t1=r1,
t2=r2,u)
u/ .t 1->r1
/. t 2->r2
subs(u,t1=r1,
t2=r2)
Concurrent
 substitute
(u,{t1=r1,t2=r2})
subs([t1=r1,
t2=r2],u)
u/ .{t1->r1,
t2->r2}
subs(u,[t1=r1,
t2=r2])
Figure 3.22. Structural operators in Maple, Mathematica, and MuPAD that
correspond most closely to MPL’s structural operators.
An MPL procedure for the Free
ofoperator is given in Section 5.2.A n
operator similar to Free
ofis available in most computer algebra systems
(see Figure 3.22).
TheSubstitute Operator
Substitution is one of the essential operations used to manipulate and sim-
plify mathematical expressions. The Substitute operator performs a par-
ticularly simple form of substitution, called structural substitution ,t h a ti s
based solely on the tree structure of an expression.
Definition 3.30. Letu,t,a n drbe mathematical expressions. The struc-
tural substitution operator has the form
Substitute (u, t=r).
It forms a new expression with each occurrence of the target expression
tinureplaced by the replacement expression r. The substitution occurs
whenever tis structurally identical to a complete sub-expression of u.
Keep in mind that Substitute does not change u, but instead creates
an entirely new expression. Some examples of the use of the operator are
given in the MPL dialogue in Figure 3.23.
The statements at <1>,<2>,a n d<3>illustrate that uis not changed
by the substitution operation. In <6>, the substitution does not occur
sincea+bis not a complete sub-expression of a+b+c. However, in <7>,
we obtain the substitution intended in <6>by modifying the form of the
substitution.
Like the Free
ofoperator, the Substitute operator searches an expres-
sionuin a recursive manner and compares each complete sub-expression
112 3. Recursive Structure of Mathematical Expressions
<1>u:=a+b;
→ u:=a+b
<2>v:=Substitute (u, b=x);
→ v:=a+x
<3>u / v;
→a+b
a+x
<4>Substitute (1/a+a, a=x);
→1
x+x
<5>Substitute ((a+b)2+1,a+b=x);
→ x2+1
<6>Substitute (a+b+c, a+b=x);
→ a+b+c
<7>Substitute (a+b+c, a=x−b);
→ x+c
Figure 3.23. AnMPLdialoguethatillustratestheuseofthe Substitute operator.
(Implementation: Maple(mws),Mathematica (nb),MuPAD(mnb).)
ofuto the target t.( S e e E x e r c i s e 10on page 195for an MPL proce-
dure for the operator.) Most computer algebra systems have a form of the
Substitute operator (see Figure 3.22).
Substitution and Evaluation
In both the Maple and MuPAD systems, structural substitution may re-
turn an expression with an operator in unevaluated form. This point isillustrated in the Maple dialogue in Figure 3.24, which gives a sequence of
statements to verify the solution of a diﬀerential equation. At the ﬁrst
prompt, we assign a diﬀerential equation to w, and at the second prompt,
substitute a speciﬁc function for y(x). Notice that the diﬀerentiation op-
erator in the second display has not been evaluated. At the third prompt,
we force this evaluation by applying Maple’s evaloperator to the out-
put of the subsoperator. The MuPAD system also requires this forced
evaluation.
3.3. Structure-Based Operators 113
> w := diff(y(x),x) + 2*y(x)=5*sin(x);
w:=W∂
∂xy(x)}
+2y(x)=5sin( x)
> subs(y(x) = -cos(x)+2*sin(x)+exp(-2*x),w);
W∂
∂x(−cos(x)+2sin( x)+e(−2x))}
−2cos(x)+4sin( x)+2e(−2x)=5s i n( x)
> eval(subs(y(x) = -cos(x)+2*sin(x)+exp(-2*x),w));
5sin(x)=5s i n( x)
Figure 3.24. AMapledialoguethatveriﬁesthesolutionofadiﬀerentialequation.
(Implementation: Maple(mws),MuPAD(mnb).)
Although the Mathematica system does not, in general, require a forced
evaluation after substitution, the substitution of a speciﬁc function for an
undeﬁned function in a derivative requires a special form. This point is
illustrated in the Mathematica dialogue in Figure 3.25.A t In[1],w ea s -
sign a diﬀerential equation to w,a n da t In[2],u s et h e ReplaceAll op-
erator to substitute a speciﬁc function in the diﬀerential equation. No-tice that the substitution has not occurred in the derivative term y
/prime[x].
The issue here is that Mathematica represents y[x]with the internal form
Derivative[1][y][x] which does not contain the function form y[x].T o
obtain the substitution, it is necessary to represent the speciﬁc function in
a form that Mathematica calls a pure function :
Function [x,−Cos[x]+2∗Sin[x]+Exp[−2∗x]],
and substitute this expression for the function name y. We have performed
this substitution at In[3],a n dt h e na t In[4], veriﬁed the solution of the
diﬀerential equation by using the Expand operator to simplify the left side
of the previous equation9.
9The Expand operator in In[4] is not required in either Maple or MuPAD. In both
of these systems, automatic simpliﬁcation obtains the distributive transformation
2( e x p ( −2x)−cos(x)+2s i n ( x))→2e x p ( −2x)−2c o s (x)+4s i n ( x).
This transformation is not obtained by automatic simpliﬁcation in Mathematica.
114 3. Recursive Structure of Mathematical Expressions
In[1]:= w=D[y[x],x]+2∗y[x]= = 5∗Sin[x]
Out[1]=2y[x]+y/prime[x]==5Sin[x]
In[2]:= ReplaceAll [w,y[x]→− Cos[x]+2∗Sin[x]+Exp[−2∗x]]
Out[2]=2(e−2x−Cos[x]+2 ∗Sin[x])+y/prime[x]==5Sin[x]
In[3]:= z=ReplaceAll [w,y→Function[x,−Cos[x]+2∗Sin[x]+Exp[−2∗x]]]
Out[3]= −2e−2x+2Cos[x]+Sin[x]+2(e−2x−Cos[x]+2 ∗Sin[x])==5Sin[x]
In[4]:= Expand[Part[z,1]]
Out[4]=5Sin[x]
Figure 3.25. A Mathematica dialogue that veriﬁes the solution of a diﬀerential
equation. (Implementation: Mathematica (nb).)
Multiple Substitution
Amultiple structural substitution is one in which a collection of structural
substitutions is applied to an expression with a single operation. Since
the individual substitutions may not be independent (i.e., one substitution
may aﬀect the action of another one), both the order of the substitutionsand the mechanics of the process may aﬀect the result. We describe below
two models for multiple substitution, sequential substitution andconcurrent
substitution .
Definition 3.31. Letube an expression and let Lbe a list of equations
L=[t1=r1,t2=r2,...,t n=rn]
where the targets tiare distinct. The sequentialstructuralsubstitution
operator has the form
Sequential
 substitute (u,L).
The operator returns the expression unthat is deﬁned by the sequence of
structural substitutions
u1:=Substitute (u, t1=r1);
3.3. Structure-Based Operators 115
u2:=Substitute (u1,t2=r2);
...
un:=Substitute (un−1,tn=rn);
Example 3.32.
Sequential
 substitute (x+y,[x=a+1,y=b+2 ] ) →a+b+3,
Sequential
 substitute (x+y,[x=a+1,a=b+2 ] ) →b+3+y,
Sequential
 substitute (f(x)=a∗x+b,[f(x)=2,x=3 ] )
→2=3 ∗a+b, (3.12)
Sequential
 substitute (f(x)=a∗x+b,[x=3,f(x)=2 ] )
→f(3) = 3 ∗a+b. (3.13)
The operations ( 3.12)a n d( 3.13) show that sequential substitution is de-
pendent on the order of the substitutions. (Implementation: Maple (mws),
Mathematica (nb),MuPAD (mnb).) /square
Example 3.33. Consider the three polynomials
u(x)=x2+x+2,v(x)=x2+3∗x−7,w (x)=x2−5∗x+4.
InF i g u r e 3.26we give an MPL dialogue that obtains the functional com-
positionsu(v(w(x))) andu(w(v(x))). Since the composition operation is a
not commutative, we use sequential substitution to determine the order of
the compositions. /square
Definition 3.34. Letube an expression and let Sbe the set of equations
S={t1=r1,t2=r2,...,t n=rn},
where the targets t1,t2,...,t nare distinct. The concurrent structural sub-
stitution operator has the form
Concurrent
 substitute (u,S).
The operator returns a new expression deﬁned in the following way: recur-
sively search through the expression tree of uand compare each complete
sub-expression vto each of the (distinct) targets t1,t2,...,t n.I fvis iden-
tical to some ti, substitute the corresponding replacement riforv.
Since each complete sub-expression of uis identical to at most one
target, the order of the substitutions is not signiﬁcant, and so concurrent
substitution is deﬁned in terms of a set Srather than a list.
116 3. Recursive Structure of Mathematical Expressions
<1>u:=x2+x+2;
→ u:=x2+x+2
<2>v:=x2+3∗x−7;
→ v:=x2+3∗x−7;
<3>w:=x2−5∗x+4;
→ w:=x2−5x+4
<4>Algebraic
expand(Sequential
substitute(u,[x=v,x=w]));
→ x8−20x7+172x6−830x5+2439 x4−4390x3+4573 x2−2365x+464
<5>Algebraic
expand(Sequential
substitute(u,[x=w,x=v]));
→ x8+12x7+16x6−234x5−407x4+2202 x3+1479 x2−10089x+7834
Figure 3.26. An MPL dialogue that obtains a composition of polynomials us-
ing sequential substitution. (Implementation: Maple(mws),Mathematica (nb),
MuPAD(mnb).)
Example 3.35.
Concurrent
 substitute ((a+b)∗x,{a+b=x+c, x=d})→(x+c)∗d.
In this case, the complete sub-expression a+bis replaced by x+cand the
complete sub-expression xis replaced by d. Notice since the replacement
x+cis not part of the original expression, its xis not replaced by d.If
this additional substitution is intended, it is obtained with
Sequential
 substitute ((a+b)∗x,[a+b=x+c, x=d])→(d+c)∗d.
Another example is
Concurrent
 substitute (f(x)=a∗x+b,{x=3,f(x)=2})→2=3 ∗a+b.
In this case, the substitution x= 3 does not aﬀect the substitution f(x)=2
as it does with sequential substitution. (Compare this with Expression
(3.13) where the order of the substitutions aﬀects the result). (Implemen-
tation: Maple (mws), Mathematica (nb),MuPAD (mnb).) /square
3.3. Structure-Based Operators 117
Most computer algebra systems allow some form of multiple structural
substitution (see Figure 3.22). In Exercise 10on page 195we describe MPL
procedures for these operators.
Since structural substitution is obtained by simply comparing a tar-
get expression to the complete sub-expressions of an expression, it cannot
obtain all substitutions which occur in symbolic calculations. For more
information about algorithms for general substitution operations basedon polynomial division, the reader may consult Cohen [ 24], Sections 4.1
and 6.2.
Exercises
1. For each of the following, give the set of complete sub-expressions of the
automatically simpliﬁed form of the expression:
(a)a∗b/c.
(b) (a+b)+(c−d).
(c) 1/(2∗x).
(d) ((x−y)∗y/2)2.
(e)x=−b+(b2−4∗a∗c)1/2
2∗a.
2. (a) Explain why the operation Free
of(a∗(b/c),b / c)r e t ur n s true.
(b) Explore the capacity of the Free
ofoperator in a CAS (see Fig-
ure3.22). Does the operator have the same capacity as the Free
of
operator in the text?
(c) One extension of the Free
ofoperator is to allow a target to be a
function name or an algebraic operator. Experiment with a CAS tosee if theFree
ofoperator in that system has this capability.
3. (a) Explore the capacity of the substitution operator in a CAS (see Fig-
ure3.22). Does the operator have the same capacity as the Substitute
operator in the text?
(b) One extension of the Substitute operator is to allow a target to be an
algebraic operator or a function name. For example, in this case
Substitute (a+b,”+”=” ∗”)→a∗b.
Can a CAS do this with its substitution operator?
(c) Perform each of the following substitutions with a single application
of theSubstitute operator. (In each case, it is necessary to ﬁnd a
“clever” substitution.)
i. Replace a∗bbyxina∗b∗cto get x∗c.
ii. Replace u+1by xin (u+1)2+u+1toget x2+x.
iii. Replace a+bby 1 in a∗(a+b)+bto get 1.
118 3. Recursive Structure of Mathematical Expressions
(d) Is it possible to replace all occurrences of the tan function in an
expression with its representation in terms of sin and cos with a sin-
gle application of the Substitute operator? For example, is it possi-
ble to obtain the transformation tan( x)+tan( y)→sin(x)/cos(x)+
sin(y)/cos(y) with a single substitution? (Don’t use a multiple sub-
stitution here.)
4. Can theSolveoperator in a CAS solve an equation for a complete sub-
expression? Canthe Solveoperatorsolveanequationforanexpressionthat
is not acomplete sub-expression? InMaple use solve, inMathematica use
Solve,a n di nM uP A Dus e solve.
5. Evaluate each of the following:
(a)Sequential
substitute(x∗(x+y),[x=2,x+y=3 ] ).
(b)Concurrent
substitute(x∗(x+y),{x=2,x+y=3}).
(c)Sequential
substitute(x+y2,[x=y, y=x]).
(d)Concurrent
substitute(x+y2,{x=y, y=x}).
(e)Sequential
substitute(a+b+c,[a=b,b=c,c=a]).
(f)Concurrent
substitute(a+b+c,{a=b,b=c, c=a}).
6. (a) Let ube an algebraic expression. Give a sequence of statements
that gives a new expression with each occurrence of xreplaced by y
and each occurrence of yreplaced by x. For example, x2+2∗yis
transformed to y2+2∗x. (Don’t use a multiple substitution here.)
(b) Is it possible to do the operation in part (a) with a single statement
that involves a multiple substitution?
7. Let ube a mathematical expression and suppose t1,r1,t2,r2are distinct
symbols. Prove or disprove:
Sequential
substitute(u,[t1=r1,t2=r2]) =
Sequential
substitute(u,[t2=r2,t1=r1]).
Further Reading
3.1Recursive Deﬁnitions and Algorithms. Recursion for algorithms is
discussedinMaurerandRalston[ 65]. Aninterestingpopularaccountofrecursion
is found in Hofstadter [ 48].
3.2Expression Trees and Primitive Operations. Expression trees in a
conventionalprogrammingcontextarediscussedinmostbooksondatastructures
andalgorithms. Forexample,seeWeiss[ 98]. ExpressiontreesintheMathematica
system are discussed in Wolfram [ 102].
4
Elementary Mathematical
Algorithms
In this chapter we extend the concept of a mathematical algorithm to in-
clude function and procedure deﬁnitions, decision structures, and iterationstructures. In Section 4.1we discuss the general concept of a mathematical
algorithm and examine some properties of mathematical operators that are
used in an algorithm. In Section 4.2we describe the basic programming
structures that are used in MPL and give examples of procedures that
use these structures. Finally, in the case study in Section 4.3we describe a
more involved algorithm that ﬁnds the solution of some ﬁrst order ordinary
diﬀerential equations.
4.1 Mathematical Algorithms
Broadly speaking, a mathematical algorithm is a step by step process for
solving a mathematical problem that is suitable for computer implemen-tation. Although this deﬁnition includes much of what is found in math-
ematics texts, it is too broad to be useful in practice. We are primarily
interested in those algorithms that can be expressed in terms of a computer
program using the operators and programming structures available in CAS
languages.
119
120 4. Elementary Mathematical Algorithms
Properties of an Algorithm
Computer scientists are quite explicit about the properties a process must
have to be called an algorithm. Ideally, a mathematical algorithm should
have the following properties.
1.Each step in the algorithm is precisely deﬁned.
2.Each step in the algorithm is eﬀective which means it is suﬃciently
basic so that it can be performed with ﬁnite computational resources(time and memory).
For example, the operation of multiplying two rational numbers is
eﬀective while the operation of multiplying two (mathematical) real
numbers that are represented by inﬁnite decimals is not.
3.The algorithm terminates in a ﬁnite number of steps for an appro-
priate class of input expressions.
Computer algebra programming diﬀers from conventional programming
because the programs contain statements that mimic the symbolic manip-
ulations that are done with pencil and paper calculations. While many
of these operations are conceptually well-deﬁned, they are not always al-gorithmically well-deﬁned in either a theoretical or practical sense. For
example, suppose that an algorithm requires the solution of an equation
f(x) = 0. The algorithm may fail because it is impossible to ﬁnd a solution
forf(x) = 0 in terms of a speciﬁc class of functions or simply because of
the limitations of a CAS’s operator for solving equations. One way to re-
solve the problem is to restrict the algorithm’s input to expressions where
all operations in the algorithm are well-deﬁned and produce meaningful
results. In many cases, however, this is not practical because a descriptionof the valid input would be too involved to be useful.
In some instances, subtle diﬀerences in the evaluation process or the
actions of operators may cause implementations of an algorithm to per-form diﬀerently in various computer algebra systems. For example, in Sec-
tion7.2we give a procedure Simplify
trig(u) that can verify a large class
of trigonometric identities. Implementations of the algorithm in Maple,
Mathematica, and MuPAD obtain the simpliﬁcation
(cos(x)+s i n (x))4+( c o s (x)−sin(x))4+c o s ( 4x)−3→0.
On the other hand, while the Maple and Mathematica implementations
obtain the simpliﬁcation
sin3(x)+c o s3/parenleftBig
x+π
6/parenrightBig
−sin3/parenleftBig
x+π
3/parenrightBig
+3s i n ( 3x)
4→0,
4.1. Mathematical Algorithms 121
the MuPAD implementation obtains
→−sin(x−y)
2−sin(−x+y)
2. (4.1)
This discrepancy is explained by the observation that in both Maple and
Mathematica the automatic simpliﬁcation process transforms
sin(−x+y)→−sin(x−y), (4.2)
which simpliﬁes the expression ( 4.1) to zero, while the automatic simpliﬁ-
cation process in MuPAD does not obtain the transformation ( 4.2).
If we were to strictly adhere to the formal requirements for an algorithm,
we would severely restrict the range of problems that would be attempted
in a computer algebra context. Therefore, in describing mathematical al-
gorithms, we take a middle ground between the computer scientist’s needfor precision and the mathematical scientist’s need for practical approaches
for solving a problem. In this spirit, we try as much as possible to adhere
to the guidelines set down by computer scientists, but also accept that forsome input, the theoretical or practical limitations of an operation may
cause the algorithm to return an inappropriate result in some instances.
Mathematical Operators in Algorithms
Large computer algebra systems contain more than a thousand mathemat-
ical operators in a wide variety of areas. For the algorithms and exercises
in this book, we use only a small subset of these operators that perform
the basic operations from arithmetic, algebra, trigonometry, calculus, ele-mentary logic, and set theory.
The mathematical operators that are utilized in MPL algorithms are
listed below. Some of these operators have been deﬁned informally inprevious chapters, and some additional ones are described below.
Algebraic Operators .T h e s ea r e+ , −,∗,/,∧,a n d! .
Relational and Logical Operators . The relational operators are =, <,≤,
>,≥,a n d /negationslash=, and the logical operators are and,or,a n dnot. (See Section
2.1and Figure 2.6on page 37.)
Set Operators .T h e s e a r e ∪,∩,∼,a n d ∈. (See Section 2.4and Fig-
ure2.20on page 70.)
List Operators .T h e s e a r e First,Rest,Adjoin ,Join,Reverse ,Delete ,
and∈. (See page 72and Figure 2.23on page 73.)
122 4. Elementary Mathematical Algorithms
Primitive Structure Operators . These include the structural operators
Kind,Operand ,Number
 of
operands ,a n d Construct . (See pages 104-106
and Figure 3.18on page 106.)
Structure-based Operators . These include the structure-based operators
Free
of,Substitute ,Sequential
 substitute ,a n d Concurrent
 substitute which
are based on the tree structure of an expression. (See pages 110-115and
Figure 3.22on page 111.)
Integer Operators . These operators perform the basic operations on
integers. For integers aandb/negationslash= 0, using integer division, we obtain a unique
quotientqand remainder rwith 0 ≤r≤|b|−1, such that a=q·b+r.
The following operators obtain qandr:
Iquot(a,b)→q, Irem(a,b)→r.
In addition, the operator Integer
 gcd(a,b) obtains the greatest common di-
visor ofaandb. For further discussion of these operators, see Cohen [ 24],
Section 2.1. The corresponding operators in Maple, Mathematica, and Mu-
PAD are given in Figure 4.1. (Implementation: Maple (mws), Mathematica
(nb),MuPAD (mnb).)
Calculus Operators . These include the operators Limit,Derivative ,a n d
Integral . (See page 34and Figure 2.4on page 35.)
Solution Operators. These are the operator Solvethat obtains the so-
lutions to some polynomial equations, some systems of polynomial equa-
tions, and some algebraic and trigonometric equations, and the operator
Solve
 odethat obtains the solutions to some ordinary diﬀerential equations.
(See page 34and Figure 2.4on page 35.)
Structure Operators for Polynomials. These are the operators Degree
andCoeﬃcient . (See page 63and Figure 2.4on page 35.)
Algebraic Manipulation Operators for Polynomials . These include the
operators Factor andAlgebraic
 expand . (See page 34and Figure 2.4on
page35.)
Structure Operators for Rational Expressions. A rational expression
is deﬁned as a quotient u=p/qwherepandqare polynomials. Two
important structural operators for rational expressions are
Numerator (u)→p,Denominator (u)→q.
4.1. Mathematical Algorithms 123
For example,
Numerator (x/(x+1 ) ) →x,Denominator (x2+4x)→1.
The last expression shows that a polynomial is considered a rational expres-
sion with denominator 1. The Numerator andDenominator operators are
described in greater detail on page 260, and the corresponding operators
in Maple, Mathematica, and MuPAD are given in Figure 4.1. (Implemen-
tation: Maple (mws), Mathematica (nb),MuPAD (mnb).)
Simpliﬁcation Operators . Simpliﬁcation is such an involved process that
it cannot be adequately described in a brief space. For now we utilize two
simpliﬁcation operators. The ﬁrst one is automatic simpliﬁcation which is
part of the evaluation process described in Sections 2.2and3.2. The second
one is Rational
 simplify which transforms an algebraic expression to the
form of a rational expression with no common factors in the numerator and
denominator.
Example 4.1.
Rational
 simplify (1/a+1/b)→a+b
ab,
Rational
 simplify/parenleftbiggx2−1
x−1/parenrightbigg
→x+1,
Rational
 simplify/parenleftBigg
1
1/a+c/(ab)+abc+ac2
(b+c)2/parenrightBigg
→a.
(Implementation: Maple (mws), Mathematica (nb),MuPAD (mnb).) /square
The corresponding operators in Maple, Mathematica, and MuPAD are
given in Figure 4.1. For more detail on the Rational
 simplify operator,
consult Cohen [ 24], Section 6.3.
Numerical Operators. The operator Absolute
 value(u) obtains the ab-
solute value of u. The operator Decimal (u) transforms numerical sub-
expressions of an expression to a decimal format. For example, Decimal (x+
1/2)→x+.5. (See page 34and Figure 2.4on page 35.)
Most of these operators and many others are described in greater detail
in later chapters.
124 4. Elementary Mathematical Algorithms
MPL
 Maple
 Mathematica
 MuPAD
Iquot(a,b)
 iquo(a,b)
 Quotient[a,b]
 iquo(a,b)
Irem(a,b)
 irem(a,b)
 Mod[a,b]
 irem(a,b)
Integer
gcd(a,b)
 igcd(a,b)
 GCD[a,b]
 igcd(a,b)
Numerator (u)
 numer(u)
 Numerator (u)
 numer(u)
Denominator (u)
 denom(u)
 Denominator (u)
 denom(u)
Rational
simplify(u)
normal(u)
 Together(u)
 normal(u)
Figure 4.1. The operators in Maple, Mathematica, and MuPAD that correspond
most closely to the MPL operators that are introduced in this section.
Operator Selection
It often happens that a CAS has a number of mathematical operators that
can perform a mathematical operation. For example, suppose that a step
in a program requires simpliﬁcations similar to
x2−1−(x+1 )(x−1)→0. (4.3)
InF i g u r e 4.2we give a Mathematica dialogue that shows three commands
that can obtain this simpliﬁcation. First, the Expand operator, which
In[1]: = u=xˆ2−1−(x+1)∗(x−1)
Out[1]=−1+x2−(−1+x)(1+x)
In[2]: = Expand[u]
Out[2]= 0
In[3]: = Together[u]
Out[3]= 0
In[4]: = Simplify[u]
Out[4]= 0
Figure 4.2. A Mathematica dialogue that shows a numberof mathematical oper-
ators that perform an algebraic simpliﬁcation. (Implementation: Maple(mws),
Mathematica (nb),MuPAD(mnb).)
4.1. Mathematical Algorithms 125
is Mathematica’s version of MPL’s Algebraic
 expand operator, applies the
distributive law to products and positive integer powers in an algebraic
expression. Next, the Together operator, which is similar to MPL’s
Rational
 simplify operator, performs algebraic expansion as well as more
involved operations such as the cancellation of common factors in the nu-
merator and denominator of a rational expression. Finally, the Simplify
operator is a general purpose simpliﬁcation operator that applies a largenumber of algebraic and trigonometric simpliﬁcation rules to an expression.
Similar choices are available in both Maple and MuPAD.
When selecting mathematical operators, to obtain simpler and more
eﬃcient programs, we subscribe to the following minimal power principle :
Always use the least powerful mathematical operator that per-
forms a given mathematical operation.
For example, if we know that our program will only encounter simpliﬁca-
tions similar to Expression ( 4.3), the CAS’s version of the Algebraic
expand
operator is the most appropriate one to use.
Finally, there are situations where it is clearly inappropriate to use a
particular operator in a program. For example, in Section 4.3we describe
a program that ﬁnds the solutions to some ﬁrst order diﬀerential equations.
It goes with out saying that a CAS’s analogue of the Solve
 odeoperator
should not be used in this program.
Semantic Capacity of Mathematical Operators
The capability of a mathematical operator can vary from system to sys-tem (sometimes dramatically) and may change signiﬁcantly when a newversion of a system is introduced. For example, most computer algebra
systems have the capability to compute the limit of a function or an inﬁ-
nite sequence. In mathematics, the limit operation is used in many diﬀerentcontexts, some very concrete and some very abstract. For example:
lim
x→∞x2
ex=0, (4.4)
lim
x→∞xn
ex=0,(nan unassigned symbol) , (4.5)
lim
∆x→0f(x+∆x)−f(x)
∆x=df
dx, (4.6)
lim
n→∞n/summationdisplay
j=1f(j/n)
n=/integraldisplay1
0f(x)dx, (4.7)
126 4. Elementary Mathematical Algorithms
lim
n→∞rn=

0 −1<r< 1,
1 r=1,
∞ r>1,
undeﬁned r<−1.(4.8)
For which limit operations should we expect a CAS to obtain a correct re-
sult? (Implementation: Maple (mws), Mathematica (nb),MuPAD (mnb).)
To create programs in a CAS language, we must have a clear idea about
the capabilities of its mathematical operators. We use the term semantic
capacity (or just capacity ) to refer to the mathematical capabilities of an
operator. Since the algorithms for mathematical operations can be quite
involved, it is often diﬃcult to describe semantic capacity in a simple way.
Nevertheless, the concept is an important one even if it cannot be describedprecisely in some instances. In practice, a useful approach is simply to
experiment with a CAS to see what an operator can do. (See Exercise 1
on page 22,E x e r c i s e 2on page 22, and the exercises at the end of this
section.)
The following two concepts, properly posed operations andsimpliﬁca-
tion context , describe some aspects of operator capacity that are useful for
understanding the capacity of an operator.
Properly Posed Operations
Informally speaking, a mathematical operation is properly posed if all the
information needed to perform the operation in an unambiguous manner
is available. If an operation is not properly posed, a CAS may not perform
the operation, may request additional information, or may return a result
that is only correct in some contexts.
InF i g u r e 4.3, we give a Maple dialogue that illustrates three examples
of operations that are not properly posed and show how they are handled
by this system. At the ﬁrst prompt, Maple evaluates the indeﬁnite integral
/integraldisplay
xndx
wherenis a symbol. This statement is improperly posed because the result
depends on whether or not n/negationslash=−1 which is unknown at this point. Notice
that Maple assumes that n/negationslash=−1 and returns the form of the integral for
this case.
At the next prompt, we assign to ua second order diﬀerential equa-
tion with the unassigned symbols a,b,a n dc, and at the third prompt
ask Maple to solve the diﬀerential equation. This statement is improperly
posed because the form of the solution depends on the value of b2−4ac.
4.1. Mathematical Algorithms 127
> int(x^n, x);
x(n+1)
n+1
> u := a*diff(y(x),x,x) + b*diff(y(x),x) + c*y(x) = 0;
u:=aW∂2
∂x2y(x)}
+bW∂
∂xy(x)}
+cy(x)=0
> dsolve(u, y(x));
y(x)=
C1e~
−1/2(b−√
b2−4ac)x
a^
+
C2e~
−1/2(b+√
b2−4ac)x
a^
> w := exp(-s*t)*sin(t);
w:=e(−st)sin(t)
> int(w, t = 0..infinity);
Deﬁnite integration: Can’t determine if the integral is convergent.
Need to know the sign of −−>s
Will now try indeﬁnite integration and then take limits.
lim
t→∞−e(−st)cos(t)+se(−st)cos(t)−1
s2+1
> assume(s>0);
> normal(int(w, t = 0..infinity));
1
s2
˜+1
Figure 4.3. A Maple interactive dialogue that demonstrates statements that are
improperly posed. (Implementation: Maple(mws),Mathematica (nb),MuPAD
(mnb).)
In this case, Maple returns the form of the solution when b2−4ac>0,
although when b2−4ac= 0, the correct form is
y(x)=c1e−b/2ax+c2xe−b/2ax.
128 4. Elementary Mathematical Algorithms
At the next two prompts, we ask Maple to evaluate the improper
integral/integraldisplay∞
0exp(−st)s i n (t)dt.
This integral is not properly posed because the convergence of the integral
depends on the sign of s.W h e ns>0, the integral converges, and otherwise
it diverges. Observe that following the ﬁfth prompt, Maple displays amessage indicating that it can’t evaluate the integral because it doesn’t
know the sign of sand then returns an unevaluated limit. At the next
prompt, we use Maple’s assume command to assign the positive property
to the symbol s, and at the last prompt we reevaluate the integral and
simplify the result with Maple’s normal command
1.
Similar results are obtained with Mathematica and MuPAD for all three
examples.
The question of when an operation is properly posed is an important
aspect of operator capacity. A CAS will often make assumptions about thenature of variables in an expression, which means the result returned by
an operator may not be correct in all contexts. This can be particularly
troubling in an involved program when one of these exceptional situations
occurs early in the calculations, remains undetected, and contaminates later
calculations. Unfortunately, many mathematical operations that involvegeneral expressions with arbitrary symbols are not properly posed (Exercise
1), and if we try to avoid these situations at all costs our programs will be
unnecessarily complicated.
Simplification Context
For eﬃciency reasons, it is unreasonable to expect a CAS to apply all its
simpliﬁcation rules during the course of a computation. The designer of
a CAS must choose which simpliﬁcation rules are appropriate for a par-
ticular operator. We use the term simpliﬁcation context to refer to those
simpliﬁcation rules that are applied during the evaluation of a mathemat-ical operator. The simpliﬁcation context often determines the form of the
output of an operator and in some cases determines whether or not a CAS
can even correctly perform an operation.
For example, consider the Maple interactive dialogue in Figure 4.4.A t
the ﬁrst prompt, uis assigned a polynomial in xin factored form, and
at the second prompt, we ask Maple to obtain the degree of uinx.In
this case algebraic expansion (with respect to the symbol x)i sp a r to ft h e
1Observe that the symbol sin the output of the normal command is followed by a
tilde ( ˜). The Maple system includes this symbol to indicate that shas been given a
property.
4.1. Mathematical Algorithms 129
> u := (x+1)*(x+2);
u:= (x+1)(x+2)
> degree(u,x);
2
> v := (y^2-1-(y+1)*(y-1))*x^2+x+1;
v:= (y2−1−(y+1)(y−1))x2+x+1
> degree(v,x);
2
Figure 4.4. A Maple interactive dialogue that demonstrates a simpliﬁcation
context. (Implementation: Maple(mws),Mathematica (nb)MuPAD(mnb).)
simpliﬁcation context of the degree operator which returns the value 2.
At the third prompt, vis assigned a polynomial in xwith one coeﬃcient
that is a polynomial in y(in unexpanded form), and at the next prompt,
we ask Maple to obtain the degree of vinx. Notice that the value 2 is
returned even though the coeﬃcient of x2simpliﬁes to 0. For this system,
expansion with respect to the auxiliary symbol yis apparently not part of
the simpliﬁcation context of the degree operator. On the other hand, both
Mathematica’s Exponent operator and MuPAD’s degree operator evaluate
the degree of vto 1.
Figure 4.5shows how the simpliﬁcation context of the numerator oper-
ator can vary from system to system. First, for the expression ( ax+bx)/c,
Maple returns the numerator in a factored form, while Mathematica returnsan expanded form. Next, consider the expression 1 /a+1/b.InM a p l et h e
terms in the sum are combined over a common denominator, and a+bis
returned as the numerator. On the other hand, in Mathematica the terms
in the sum are not combined, and the entire expression is returned as the
numerator.
Simpliﬁcation context is a rather loosely deﬁned concept. For exam-
ple, does it refer to the simpliﬁcation rules that are applied before, during,
or after an operation? In addition for some operators a simpliﬁcation rule
130 4. Elementary Mathematical Algorithms
> u := (a*x+b*x)/c;
u:=ax+bx
c
> numer(u);
(a+b)x
> u := 1/a+1/b;
‘ u:=1
a+1
b
> numer(u);
a+b
(a) Maple.
In[1]: = u=(a∗x+b∗x)/c
Out[1]=ax+bx
c
In[2]: = Numerator [u]
Out[2]= ax+bx
In[3]: = u=1/a+1/b
Out[3]=1
a+1
b
In[4]: = Numerator [u]
Out[4]=1
a+1
b
(b) Mathematica.
Figure 4.5. Interactive dialogues in Maple and Mathematica that show diﬀerent
simpliﬁcation contexts of the numerator operation. (Implementation: Maple
(mws),Mathematica (nb),MuPAD(mnb).)
4.1. Mathematical Algorithms 131
may be applied in some situations while not in others or may even depend
on other options or settings used in a session. Nevertheless, the concept
is an important aspect of operator capacity and serves as a warning that
unwarranted assumptions about the actions of an operator may cause aprogram to fail.
Exercises.
1. Explain why thefollowing operations are not properly posed without addi-
tional information about the arbitrary symbols that appear in the expres-sions. Implement each operation in a CAS.Isthesolution obtained correct
for all values of the arbitrary symbols?
(a)dx
x2+2ax+1.
(b)
sin(nx)s i n (mx)dx.
(c) Solve the diﬀerential equationdy2
dx2−y=e xp ( ax).
(d)1
01
xndx.
Useintanddsolvein Maple, Integrate andDSolveinMathematica, and
intand ode(with solve)i nM uP A D .
2. Experiment with a CAS to determine the simpliﬁcation context of the
following operators.
(a) TheCoeﬃcient operator. For example, can the operator obtain co-
eﬃcients if the input polynomial is not in expanded form? Is the
result returned in expanded form? Is rational simpliﬁcation part of
the simpliﬁcation context? (Use coeffin Maple and MuPAD and
Coefficient in Mathematica.)
(b) TheSolveoperator. For example, can this operator determine that
thequadratic equation ( a2−1−(a+1)(a−1))x2+x−1= 0 is really
a linear equation and return the solution x= 1? How about the
equation(sin2(a)+cos2(a)−1)x2+x−1= 0? Isrationalsimpliﬁcation
applied before and/or after a solution to the equation is found? (Usesolvein Maple and MuPAD and Solvein Mathematica.)
3. Is rational simpliﬁcation part of the simpliﬁcation context of the diﬀer-
entiation operator in a CAS? (Use diffin Maple and MuPAD and Din
Mathematica.)
4. Describe the semantic capacity of the factor operation in a CAS. The ex-
amples in Exercise 1, page22are useful for this exercise. (Use factorin
Maple and MuPAD and Factorin Mathematica.)
132 4. Elementary Mathematical Algorithms
5. SomeCASsoftwarehasthecapabilitytodiﬀerentiateandintegrateexpres-
sions with undeﬁned functions. In this exercise we ask you to explore the
capacity of diﬀerentiation and integration operators in a CAS to handle
undeﬁned functions.
(a) Apply the diﬀerentiation operator to the following expressions:
u(x),du(x)
dxu(x)v(x),u(x)/v(x), (4.9)
sin(u(x)),u(v(x)),x3du(x)
dx−3x2u(x)+x2/2.
Does the CAS obtain the results you expect? (Use diffin Maple
and MuPAD and DMathematica.)
(b) Suppose that you are given the derivatives of the expressions in
(4.9). Can a CAS integrate these derivatives to obtain the expres-
sions in ( 4.9) (up to a constant)? (Use intin Maple and MuPAD
and Integrate in Mathematica.)
6. Animportant aspect ofsemanticcapacity iswhatan operatordoeswhen it
is unable to perform the operation. Experiment with a CAS to determine
what each of the of the following operators does in this situation.
(a)Degree.
(b)Solve.
(c)Integral.
(d)Solve
ode.
For example, what does Degree(u,x) operator return when the input ex-
pression uis not a polynomial in x?( I n M a p l e us e degree, solve,
int,a n d dsolve; in Mathematica use Exponent, Solve, Integrate ,a n d
DSolve;a n di nM uP A Dus e degree, solve, int ,a n d ode(with solve).)
4.2 MPL’s Algorithmic Language
In this section we describe the basic language structures that are used in
MPL to control the ﬂow in an algorithm.
Function Definitions
In ordinary mathematical discourse, the statement, “let f(x)=x2+4,”
deﬁnes a computational scheme and does not perform a computation. A
computation occurs when the function is invoked with a statement such as
f(2)→8. In MPL, a function deﬁnition is used to mimic this operation.
4.2 MPL’s Algorithmic Language 133
InM P L ,a function deﬁnition has the form
f(x1,...,x l)function:=u,
wherefis the function name ,x1,...,x lis a sequence of symbols called the
formal parameters ,a n duis a mathematical expression. As with ordinary
mathematical notation, a function is invoked with an expression of the form
f(a1,...,a l), (4.10)
wherea1,...,a lis a sequence of mathematical expressions called the actual
parameters . When this expression is evaluated, each aiis evaluated and
substituted for the corresponding xiinu,a n dt h e n uis evaluated, and the
resulting expression is returned as the evaluated form of ( 4.10).
Example 4.2. Consider the function deﬁnition
f(x)function:=x2+4.
The function is invoked with an expression such as f(2). When this state-
ment is evaluated, the actual parameter 2 replaces formal parameter xin
x2+4 ,a n df(2)→8. /square
Example 4.3. Consider the function deﬁnition
T(y,x)function:=Derivative (y,x)+y.
The function is invoked with an expression such as T(sin(t)+t2,t). When
this statement is evaluated, the actual parameters sin( t)+t2andtare
substituted for the formal parameters yandx,a n dw eo b t a i n
T(sin(t)+t2,t)→cos(t)+2t+s i n (t)+t2. /square
InF i g u r e 4.6we give function deﬁnitions in Maple, Mathematica, and
MuPAD that implement the MPL deﬁnitions in Examples 4.2and4.3.
Procedure Definitions
MPL procedures extend the function concept to mathematical operators
that are deﬁned by a sequence of statements. The general form of a pro-
cedure is given in Figure 4.7. The ﬁrst line of the procedure gives the
procedure name and a sequence of formal parameters. The Input section
contains each of the formal parameters xialong with a brief description
134 4. Elementary Mathematical Algorithms
f := x -> x^2+4;
T := (y,x) -> diff(y,x)+y;
(a) Maple.
f[x_] := x^2 + 4
T[y_, x_] := D[y, x] + y
(b) Mathematica.
f := x -> x^2+4;
T := (y,x) -> diff(y,x)+y;
(c) MuPAD.
Figure 4.6. FunctiondeﬁnitionsinMaple, Mathematica, andMuPADthatcorre-
spond to the MPL deﬁnitions in Examples 4.2and4.3. (Implementation: Maple
(mws),Mathematica (nb),MuPAD(mnb).)
of the type of expression that replaces it when the procedure is invoked.
MPL procedures always return a mathematical expression as output, and
theOutput section contains a brief description of this expression.
TheLocalVariables section contains a sequence of local variables that
are known and used only by the procedure. The formal parameters and
the local variables make up the local environment of a procedure. In a real
CAS, each time a procedure is invoked, the variables in this environment are
given storage locations in the computer’s memory, and when the procedureterminates, these locations are released back to the system.
The statements between the delimiters Begin andEndrepresent the
bodyor the executable statements of the procedure. Each statement S
jis
either a mathematical expression, an assignment statement, or a decision
or iteration structure both of which are deﬁned later in this section.
A procedure is invoked like a function with an expression of the form
(4.10). When the procedure is invoked, each actual parameter aiis evalu-
ated and then substituted for the corresponding formal parameter xi,a f t e r
4.2 MPL’s Algorithmic Language 135
Procedure f(x1,...,x l);
Input
x1: description of input to x1;
...
xl: description of input to xl;
Output
description of output;
Local Variables
v1,...,v m;
Begin
S1;
S2;
...
Sn−1;
Sn
End
Figure 4.7. The general form of an MPL procedure.
which each statement Sjin the body is evaluated. In most cases, at least
one of the Sjincludes a return statement that has the form
Return (u),
whereuis a mathematical expression. When this statement is encountered,
three actions occur: ﬁrst, the procedure immediately terminates; second,
the evaluated form of uis returned as the evaluated form of Expression
(4.10); and ﬁnally, control is transferred back to the statement that invoked
the procedure. If a Return statement is not included, the actions are similar,
but now the evaluated form of the last statement Snis returned by the
procedure. We always include a Return statement to emphasize what is
returned by the procedure.
Example 4.4. We illustrate this concept by deﬁning a procedure that ob-
tains the equation of a tangent line to a function f(x)a tt h ep o i n t x=a.
Recall that the expression for the tangent line is given by
df
dx(a)(x−a)+f(a). (4.11)
The procedure deﬁnition in Figure 4.8is an algorithmic view of what is
done to obtain this expression in expanded form. We invoke the procedure
136 4. Elementary Mathematical Algorithms
Procedure Tangent
line(f,x,a);
Input
f:a nalgebraic expression (formula for a mathematical function);
x: a symbol (independent variable);
a:a nalgebraic expression (point of tangency);
Output
an algebraic expression that is the formula for the tangent line;
Local Variables
deriv,m,line;
Begin
1deriv:=Derivative (f,x);
2m:=Substitute (deriv,x=a);
3line:=Algebraic
expand(m∗(x−a)+Substitute (f,x=a));
4Return(line)
End
Figure 4.8. An MPL procedure that obtains the formula for a tangent line.
with an expression such as
Tangent
 line(1/z,z,3). (4.12)
When this expression is evaluated, the three actual parameters 1 /z,z,a n d
3 are substituted for the corresponding formal parameters f,x,a n da,a n d
then the statements in the procedure are evaluated:
deriv:=Derivative (1/z, z)→−1/z2,
m:=Substitute (−1/z2,z=3 )→−1/9,
line:=Algebraic
 expand/parenleftbig
(−1/9)∗(z−3) +Substitute (1/z, z=3 )/parenrightbig
→(−1/9)z+2/3.
Therefore
Tangent
 line(1/z,z,3)→(−1/9)z+2/3.
When we invoked the procedure in Expression ( 4.12), for clarity we
intentionally chose names for mathematical symbols that were diﬀerentfrom the formal parameter names of the procedure. There is no reason,
however, to restrict the actual parameters in this way. For example, the
procedure can also be invoked with
Tangent
line(1/x,x,3)→(−1/9)x+2/3. (4.13)
4.2 MPL’s Algorithmic Language 137
Keep in mind, however, that the actual parameter xin Statement ( 4.13)
and the formal parameter xin the procedure declaration
Procedure Tangent
 line(f,x,a) (4.14)
are diﬀerent symbols even though they have the same name. When State-
ment ( 4.13) is evaluated, each actual parameter is substituted for the cor-
responding formal parameter which means that fis replaced by 1 /x,t h e
formal parameter xin (4.14) by the actual parameter xin (4.13), anda
by 3. Therefore, the diﬀerentiation at line 1 is
Derivative (1/x,x)→−1/x2,
where the xthat appears here is the one in ( 4.13). Similar comments apply
to the other statements in the procedure. /square
Maple, Mathematica, and MuPAD provide procedures that operate
as described above. In Figures 4.9and4.10we give implementations of
Tangent
 linein these languages.
Global Symbols. A symbol that appears in a function or a procedure that
is not a formal parameter or a local variable is called a global symbol .
Global symbols, which are accessible to both the interactive mode and other
functions and procedures, provide another way to pass data to and from a
procedure without using the formal parameters or a Return statement.
For a simple example, consider a modiﬁcation of the Tangent
 linepro-
cedure in which the variable derivhas been removed from the local section
and therefore is considered global. In this case, after evaluating Statement
(4.12) the global variable derivhas the value −1/z2which can now be used
by other functions, procedures, or the interactive mode.
In our MPL procedures, global symbols are used primarily to return
information about the status of an operation. For example, in Figure 4.14
on page 144we give a procedure that tries to determine if a mathematical
function is even or odd. The procedure returns one of the global symbols
EvenorOddwhen the input expression is even or odd, or the global symbol
Unknown when the procedure cannot determine the property.
Use of Local Variables in MPL. Procedures provide a way to isolate part of
a computation so that programming variables in the local environment do
not conﬂict with variables with the same name in other functions, proce-
dures, or the interactive mode. However, in some systems local variables
138 4. Elementary Mathematical Algorithms
Tangent_line := proc(f,x,a)
#Input
# f: an algebraic expression (formula for a mathematical function)
# x: a symbol (independent variable)# a: an algebraic expression (point of tangency)
#Output
# an algebraic expression that is the formula for the tangent linelocal
deriv,m,line;
deriv := diff(f,x);m := subs(x=a,deriv);
line := expand(m*(x-a)+subs(x=a,f));
RETURN(line)end:
(a) Maple.
TangentLine[f_,x_,a_] := Module[
(*Input
f: an algebraic expression (formula for a mathematical function)x: a symbol (independent variable)a: an algebraic expression (point of tangency)
Output
an algebraic expression that is the formula for the tangent line
Local*)
{deriv,m,line},
deriv = D[f,x];m = ReplaceAll[deriv,x->a];
line = Expand[m*(x-a)+ ReplaceAll[f,x->a]];
Return[line]]
(b) Mathematica.
Figure 4.9. Implementations of the MPL procedure in Figure 4.8in Maple and
Mathematica. (Implementation: Maple(txt),Mathematica (txt).)
4.2 MPL’s Algorithmic Language 139
Tangent_line := proc(f,x,a)
/*Input
f: an algebraic expression (formula for a mathematical function)
x: a symbol (independent variable)
a: an algebraic expression (point of tangency)
Output
an algebraic expression that is the formula for the tangent line
*/local
deriv,m,line;
beginderiv := diff(f,x);
m := subs(deriv,x=a);
line := expand(m*(x-a)+subs(f,x=a));return(line)
end_proc:
Figure 4.10. A MuPAD implementation of the MPL procedure in Figure 4.8.
(Implementation: MuPAD(txt).)
can also act as mathematical symbols in an expression, and when this hap-
pens, name conﬂicts can occur that are not encountered with conventional
programming languages.
For example, suppose that a symbol xis declared local in a procedure,
and suppose that it is used as a mathematical symbol in an expression
that is returned by a procedure. When this happens, does xlose some
of its local characteristics? For example, when this xis returned to the
interactive mode, is it the same as a mathematical symbol xused elsewhere
in the interactive mode?
InF i g u r e 4.11we show how this situation is handled by the Maple
system. At the ﬁrst prompt, we deﬁne a procedure F(a) that returns the
expression a∗x2with the local x. At the second prompt, we call on the
procedure and assign the output to u. At the third prompt, we diﬀerentiate
uwith respect to xand obtain what appears to be an incorrect result. The
problem here is the local xin the procedure and the xin the diffcommand
are diﬀerent symbols even though they have the same displayed name inthe interactive mode.
In Mathematica, local variables in a procedure can act as mathemati-
cal symbols, although a procedure similar to the Maple procedure in Fig-
ure4.11returns the expression ax
2with the symbol name xreplaced by
another system-generated name.
140 4. Elementary Mathematical Algorithms
> F := proc(a)
local x;
RETURN(a*x^2)end:
> u := F(3);
u:= 3x
2
> diff(u,x);
0
Figure 4.11. A Maple dialogue in which a local mathematical symbol is returned
from a procedure. (Implementation: Maple(mws),Mathematica (nb),MuPAD
(mnb).)
The MuPAD system avoids this situation altogether by not permitting
unassigned local variables in a procedure to act as mathematical symbols.
To avoid conﬂicts of this sort and to provide a system-independent pro-gramming style, we follow MuPAD’s lead and adopt the following conven-
tion:
In MPL procedures, an unassigned local variable cannot appear
as a symbol in a mathematical expression.
In other words, in MPL procedures local variables can only act as program-
ming variables and must be assigned before they appear in a mathematicalexpression. In situations where a procedure requires a local mathemati-
cal symbol, we either pass the symbol through the parameter list or use a
global symbol.
Use of Formal Parameters in MPL. In conventional programming languages,
a procedure’s formal parameters can be used both to transmit data to and
from a procedure and as local variables. The situation with CAS languagesis more involved, however, because the actual parameters in a procedure
call can be mathematical expressions as well as variables. Because of this,
the language mechanism that is used to bind the formal parameters withthe actual parameters can be rather involved and can vary from system
to system. For this reason, the use of formal parameters for anything but
the transmission of data into a procedure is system dependent. Since our
goal is to present a system-independent programming style, we adopt the
following convention:
4.2 MPL’s Algorithmic Language 141
Formal parameters in MPL procedures are used only to transmit
data into a procedure and not as local variables or to return data
from a procedure.
When we need to return more than one expression from a procedure, we
return a list of expressions.
Decision Structures
Decision structures provide a way to control the ﬂow in an algorithm.MPL provides three decision structures. The simplest one is the ifstruc-
ture which has the general form shown in Figure 4.12-(a). The expression
ifcondition then
T1;
T2;
...
Tm;
(a) Theifstructure.
ifcondition then
T1;
T2;
...
Tm
else
F1;
F2;
...
Fn;
(b) Theif-else structure.
Figure 4.12. The general form of the MPL ifandif-elsedecision structures.
142 4. Elementary Mathematical Algorithms
condition is a logical (or relational) expression that evaluates to one of the
logical constants trueorfalse.E a c hTiis either a mathematical expres-
sion, an assignment statement, another decision structure, or an iteration
structure (described below).
Theifstructure usually operates in the following way: when condition
evaluates to true, the indented2statements T1,T2,...,T mare evaluated,
and when condition evaluates to falsethese statements are skipped. The
exception to this scheme arises when the ifstatement is included in a
procedure, and one of the indented statements includes a Return .In t h i s
case, when condition istrue, the statements controlled by the ifare
evaluated until the Return is encountered, at which point the procedure
terminates, and the evaluated form of the argument to Return is returned
by the procedure. This exception also applies to the other decision anditeration structures described below.
A more general decision structure is the if-else structure which al-
lows for two alternatives. It has the general form
3shown in Figure 4.12-
(b). When the expression condition evaluates to true, the statements
T1,T2,...,T mare evaluated, and when condition evaluates to false,t h e
statements F1,F2,...,F nare evaluated.
Example 4.5. Here is a simple example of an if-else structure:
if0≤xandx≤1then
f:=x2+ 4 (4.15)
else
f:=x2−1;
(Implementation: Maple (mws), Mathematica (nb),MuPAD (mnb).) /square
The most general MPL decision structure is the multi-branch decision
structure which allows for a sequence of conditions. It has the general
form shown in Figure 4.13. In this generality, the structure contains zero
or moreelseif sections and an optional elsesection. Upon evaluation, the
logical expressions condition 1,condition 2,...are evaluated in sequence. If
condition iis the ﬁrst one that evaluates to true, then the statements in
that section Si1,...,S im iare evaluated while all the other statements are
2Some computer algebra languages require a termination symbol (such as end
if,fi,
or]) to indicate the extent of statements controlled by the ifstructure. In MPL, these
statements are indicated by indentation without a termination symbol.
3As is common practice in some programming languages, in MPL we omit the
semicolon at the end of a statement that precedes an else,a n elseif (deﬁned below),
and an End.
4.2 MPL’s Algorithmic Language 143
ifcondition 1then
S11;
S12;
...
S1m1
elseifcondition 2then
S21;
S22;
...
S2m2
...
elseifconditionnthen
Sn1;
Sn2;
...
Snm n
else
F1;
F2;
...
Fr;
Figure 4.13. The MPL multi-branch structure that provides for a sequence of
alternatives.
s k i p p e d .Ifn o n eo ft h et e s t se v a l u a t et o true, the statements in the else
section (if included) are evaluated.
All computer algebra languages provide ifstructures and if-else struc-
tures, and some languages provide a version of the multi-branch decision
structure4.
The procedure in the next example utilizes a multi-branch structure.
4In Maple and MuPAD, use the ifstatement to implement MPL’s if,if-else ,a n d
multi-branch structures. In Mathematica, use the Ifstatement to implement MPL’s
ifand if-else structures and the Which statement to implement MPL’s multi-branch
structure.
144 4. Elementary Mathematical Algorithms
Example 4.6. Recall that a mathematical function u(x)i se v e ni f
u(x)−u(−x)=0
and odd if
u(x)+u(−x)=0.
For example, u(x)=x2−1i se v e n ,u(x)=x3is odd, while u(x)=x2+x3
is neither even nor odd.
A procedure that tries to determine if an algebraic expression uis even
or odd is given in Figure 4.14. The procedure is interesting for both what
it can do and what it cannot do. Observe that the procedure operates inthe simpliﬁcation context of automatic simpliﬁcation, and in this context
it can determine the nature (even or odd) of the ﬁrst two examples given
above.
Notice that when the procedure is unable to determine that uis even
or odd, it returns the symbol Unknown , rather than a symbol indicating
that the expression is neither even nor odd. We do this because automatic
simpliﬁcation applied at lines 2 and 4 may not simplify an expression to
zero even though the expression simpliﬁes to zero in a mathematical sense.For example, suppose that uis the even expression ( x+1 )(x−1), and
Procedure Even
 odd(u,x);
Input
u:a nalgebraic expression ;
x:as y m b o l ;
Output
one of the global symbols Even,Odd,o rUnknown;
Local Variables
v;
Begin
1 v:=Substitute (u, x=−x);
2 ifu−v=0then
3Return(Even)
4 elseif u+v=0then
5Return(Odd)
6 else
7Return(Unknown)
End
Figure 4.14. An MPL procedure that attempts to determine if uis even or odd.
(Implementation: Maple(txt),Mathematica (txt),MuPAD(txt).)
4.2 MPL’s Algorithmic Language 145
let’s assume that algebraic expansion is not included in automatic simpli-
ﬁcation5.In t h i s c a s e , vis the expression ( −x+1 )( −x−1), andu−v
is the expression ( x+1 )(x−1)−(−x+1 )( −x−1), which does not sim-
plify to 0 with automatic simpliﬁcation. Although we can remedy this byapplying the Algebraic
expand operator at lines 2 and 4, there are other
expressions that are not handled in this simpliﬁcation context. For ex-
ample, 1/(x−1)−1/(x+ 1) is even, but this cannot be determined by
algebraic expansion and automatic simpliﬁcation. In this case, rational
simpliﬁcation (with Rational
 simplify ) is required at lines 2 and 4. But
then, sin(x/(x+1 ) )+s i n ( x/(x−1)) is even, but this is not handled by
rational simpliﬁcation.
While it is possible to increase the simpliﬁcation power at lines 2 and
4 to handle all of the above expressions, it is theoretically impossible to
increase the simpliﬁcation power to a level that the procedure can always
determine if an algebraic expression is even or odd6. /square
Iteration Structures
MPL contains two iteration structures that allow for repeated evaluation
of a sequence of statements. The ﬁrst iteration structure is the while
structure which has the general form
while conditiondo
S1; (4.16)
S2;
...
Sn;
where condition is a logical (or relational) expression. This structure is
evaluated by ﬁrst evaluating condition , and if it is to true, the indented
statements S1,S2,...,S mare evaluated. Once this is done, the process
repeats, and again if the logical condition istrue, the indented statements
are evaluated. The process continues in this way checking if condition is
trueand if so, evaluating the indented statements. On the other hand once
5In Maple, Mathematica, and MuPAD, algebraic expansion is not part of automatic
simpliﬁcation.
6The problem to determine if an expression simpliﬁes to 0 is known as the zero
equivalence problem . D. Richardson has shown that for the class of algebraic expres-
sions constructed with rational numbers, the symbol x,t h er e a ln u m b e r s πand ln(2),
the sin, exp, and absolute value functions, and sums, products, and powers with in-teger exponents, it is impossible to give an algorithm that can always determine if anexpression simpliﬁes to 0 (see Richardson [ 84]).
146 4. Elementary Mathematical Algorithms
condition evaluates to false, the indented statements are not evaluated, and
the structure terminates.
Example 4.7. The sum of the ﬁrst n+ 1 terms of a Taylor series for a
functionu(x)a b o u tx=ais given by
n/summationdisplay
i=0u(i)(a)
i!(x−a)i(4.17)
whereu(i)is theith derivative of u(x), andu(0)=u(x). When nis a
non-negative integer, the sum ( 4.17) is obtained with the following MPL
statements:
1i:= 1;
2s:=Substitute (u,x=a);
3whilei≤ndo
4u:=Derivative (u,x);
5s:=s+Substitute (u,x=a)/i!∗(x−a)i;
6i:=i+1 ;
The substitution in line 2 initializes stou(0)(a)=u(a), and each traversal
through the while loop adds one additional term of the Taylor series to s
and increases the counter iby 1. Eventually i=n+1, and so the condition
i≤nisfalse,a n dt h ewhile structure terminates.
For example, if u=s i n (x),n=3 ,a n da= 0, after executing the loop
we obtain s=x−x3/6. (Implementation: Maple (mws), Mathematica
(nb),MuPAD (mnb).) /square
The second iteration structure is the forstructure which has the general
form
fori:=starttoﬁnishdo
S1; (4.18)
S2;
...
Sn;
whereiis a variable and startandﬁnish are expressions that evaluate to
integer values. When start≤ﬁnish, the indented statements are evaluated
4.2 MPL’s Algorithmic Language 147
for each integer value of i=start,start +1,...,finish .Ifstart>finish ,
the indented statements are not evaluated7
Example 4.8. T h es u mo ft h eﬁ r s t n+1 terms of the Taylor series can also
be obtained using a forstructure:
1s:=Substitute (u,x=a);
2fori:= 1tondo
3u:=Derivative (u,x);
4s:=s+Substitute (u,x=a)/i!∗(x−a)i;
(Implementation: Maple (mws), Mathematica (nb),MuPAD (mnb).) /square
All computer algebra languages provide iteration structures similar to
while andfor8.
Evaluation of Logical Expressions. InM P L ,t h ev a l u e( trueorfalse)o fa
logical expression with main operator andor main operator oris obtained
by evaluating each of the operators in a left to right manner until thevalue of the entire expression is determined. In some cases this value is
obtained without evaluating all the operands of the logical expression. For
example, consider the following decision structure which tests if nis a
positive integer:
ifKind(n)=integerand n>0then (4.19)
...
Observe that the second relational expression only evaluates to trueor
falsewhennhas a numerical value. When nis not an integer, however,
the value of the entire logical expression ( false) is determined by the test
Kind(n)=integer , and there is no need to evaluate the expression n>0.
Most computer algebra systems evaluate logical expressions in decision
and iteration structures in a similar way
9.
7Some of our procedures contain Fo rloops that include a Return statement. (For
example, see lines 5-6 in the procedure Polynomial
 svin Figure 6.2on page 218.) In
this case, we intend that both the loop and the current procedure terminate when the
Return is encountered, and that the value returned by the procedure is the value of the
operand of the Return statement. The forstatements in both Maple and MuPAD work
in this way. However, in Mathematica, a Return in a Forstatement will only work in
this way if the upper limit contains a relational operator (e.g., i<=N). (Implementation:
Mathematica (nb).)
8In Maple and MuPAD, use the while and forstatements. In Mathematica, use the
While and Forstatements.
9Maple, Mathematica, and MuPAD use this approach to evaluate logical expressions
in decision and iteration structures.
148 4. Elementary Mathematical Algorithms
The procedure in the next example uses the concepts described in this
section.
Example 4.9. It is often necessary to separate the operands of a product
into two classes, those that depend on an expression (say x)a n dt h o s e
that do not. For example, this operation is needed when we use the linear
property of the integral to move the factors of a product that do not dependon the integration variable xoutside of the integral sign:
/integraldisplaycxsin(x)
2dx=c
2/integraldisplay
xsin(x)dx. (4.20)
A procedure Separate
 factors that performs the separation operation
is given in Figure 4.15. The procedure takes two algebraic expressions u
Procedure Separate
factors(u,x);
Input
u,x:algebraic expressions ;
Output
a list with two algebraic expressions ;
Local Variables
f,free
of
part,dependent
part,i;
Begin
1 ifKind(u)=” ∗”then
2free
of
part:= 1;
3dependent
part:= 1;
4 fori:= 1toNumber
of
operands(u)do
5 f:=Operand(u,i);
6 ifFree
of(f,x)then
7 free
of
part:=f∗free
of
part
8 else
9 dependent
part:=f∗dependent
part;
10Return([free
of
part,dependent
part])
11 else
12 ifFree
of(u,x)then
13 Return([u,1])
14 else
15 Return([1,u])
End
Figure 4.15. AnMPL procedurethatseparates factors ina productthatdepend
onxfrom those that do not. (Implementation: Maple(txt),Mathematica (txt),
MuPAD(txt).)
4.2 MPL’s Algorithmic Language 149
andxas input and returns a two-element list. The ﬁrst member of the
list contains the product of the factors of uthat are free of x, while the
second member contains the product of the remaining factors. If there are
no factors in a category, the integer 1 is returned for that category.
The procedure can be applied to both products and non-products.
Whenuis a product, the Free
ofoperator is applied to each factor which
is then placed in the appropriate category (lines 6-9). When uis not a
product, it is reasonable to apply Free
ofto the entire expression which
is then placed in the appropriate category (lines 12-15). The procedure is
invoked with an expression such as
Separate
 factors/parenleftbiggcxsin(x)
2,x/parenrightbigg
→[c/2,xsin(x)]. /square
Comparison of the MPL and CAS Languages
In Chapters 2,3, and this chapter we have introduced the main elements
of the MPL algorithmic language. The description includes the following
elements.
1.The MPL mathematical operators. A summary of these operators is
given on pages 121-123of this chapter. In later chapters many of
these operators are described in greater detail and many others are
introduced.
2.A description of the evaluation process including automatic simpli-
ﬁcation. All calculations in our programs are done in the context
of automatic simpliﬁcation. Automatic simpliﬁcation is described in
Chapters 2and3. For a more detailed discussion of automatic sim-
pliﬁcation consult Cohen [ 24], Chapter 3.
3.The structure of mathematical expressions. Mathematical expres-
sions are the data objects of computer algebra. The form of these
expressions in the context of automatic simpliﬁcation is described in
Chapter 3.
4.The MPL algorithmic structures. Functions, procedures, decision
structures, and iteration structures are described in this section, and
a few additional ones are described in later chapters.
Although MPL is similar to real CAS languages, it models only a small
subset of these languages. Large CAS languages contain over 1000 mathe-
matical operators and other language features that provide greater mathe-
matical power, facilitate the programming process, and enhance the com-
putational eﬃciency of programs.
150 4. Elementary Mathematical Algorithms
There is, however, much to be gained from MPL’s simplicity. MPL’s
algorithms can be implemented (usually with only minor modiﬁcations)
in many real CAS languages using only the basic operations of these lan-
guages. In fact, many mathematical operations can be formulated in termsof the analogues of MPL’s primitive operators ( Kind,Operand ,e t c . ) o r
in terms of other operators that are deﬁned in terms of these primitive
operators.
Exercises
Unless otherwise noted, each of the functions and procedures in the exercises
should be expressed in terms of a CAS’s version of the mathematical operators
given on pages 121-123.
1. Consider the function f(x)=1
1−x.
(a) Show that f(f(f(x)))=xwith pencil and paper.
(b) Deﬁne this function using a function deﬁnition in a CAS language.
(c) Use a CAS to show that f(f(f(x)))=x.
2. (a) The curvature of a function f(x)i sg i v e nb y
k(x)=|f/prime/prime(x)|
(1+(f/prime(x))2)3/2.
Give a procedure Curvature (f,x) that computes the curvature of an
algebraic expression fatx.
(b) Apply the Curvature operator to the function
f(x)=
4−x2.
Since this function represents the positive semicircle of radius 2, the
curvature result simpliﬁes to the value 1 /2. Can youobtain this
simpliﬁcation with a CAS?
3. Let ube an equation that represents a straight line in xandy,a n dl e t p
be a two-element list of rational numbers that represents the coordinates
of a point.
(a) Give a procedure Perpendicular
 line(u,x,y,p)that returnstheequa-
tion of a line perpendicular to uthat passes through the point p.
Be sure to include the cases for horizontal and vertical lines. For
example,
Perpendicular
 line(2x+3y=4,x ,y ,[1,2])→y−2=(3 /2)(x−1).
4.2 MPL’s Algorithmic Language 151
(b) Give a procedure
Distance
point
line(u,x,y,p)
that returns the shortest distance from the point pto the line u.F o r
example,
Distance
point
line(2x+3y=4,x ,y ,[1,2])→(4/13)√
13.
4. Let ubeamathematical expression . Giveaprocedure Operand
list(u)that
returns the operands of a compound expression in a list. (The operands
in the list should be in the same order as the operands in u.) Ifuis not a
compound expression, return the global symbol Undeﬁned .I fuis a list,
return u. For example,
Operand
list(a+b+c)→[a,b,c].
5. Let ube an equation of the form f=gwhere fandgare polynomials in
xwith coeﬃcients that are rational numbers such that f−ghas degree
≤2. Give a procedure Solve
quadratic(u,x) that ﬁnds the roots of the
equation f=g.B es ur et oc h e c ki f f−gis a constant, linear, or quadratic
polynomial. Do not use a CAS’s solve operator in this problem.
6. Let Sbe a set of polynomials in x. Give a procedure Find
min
deg(S,x)
that returns a polynomial of smallest degree in S.I fS=∅,r e t ur nt h e
global symbol Undeﬁned .
7. Theset product of sets AandBis the set of all lists [ x,y]w h e r e x∈A
andy∈B. This set is represented by A×B.I fe i t h e r A=∅orB=∅,
then, by deﬁnition, A×B=∅. Give a procedure Set
product(A,B)t h a t
returns A×B. For example,
Set
product({a,b},{c,d})→{[a,c],[a,d],[b,c],[b,d]}.
8. Let xbe a symbol, and let ube a polynomial in xwith rational number
coeﬃcients. Giveaprocedure Linear
factors(u,x)thatreturnstheproduct
of thelinear factors of u.I fuhasnolinear factors, return1. Use thefactor
operator in a CAS to obtain the factorization of u. For example,
Linear
factors(x2+x,x)→x(x+1),Linear
factors(x3+1,x)→x+1,
Linear
factors(x2+1,x)→1,Linear
factors(x2+2x+1,x)→(x+1)2.
9. Let ube a polynomial in xandywith rational number coeﬃcients. A
polynomial uissymmetric if it is not changed when the variables xand
yare interchanged. For example, the polynomial u=x2+2xy+y2is
symmetric. Give a procedure Symmetric (u,x,y) that returns trueifuis
symmetric and falseotherwise.
10. Let Lbe a list. Givea procedure Remove
duplicates (L) thatreturnsanew
list with all members that are identical to a previous member of the list
removed from u. For example, Remove
duplicates ([a,b,c,a,c])→[a,b,c].
152 4. Elementary Mathematical Algorithms
11. Let ube analgebraic expression .T h enumerical coeﬃcient part ofuis
deﬁned in the following way:
(a) If uis a rational number, the numerical coeﬃcient part of uisu.
(b) If uis a product, the numerical coeﬃcient part is the operand of u
that is a rational number. If this operand does not exist, then the
numerical coeﬃcient part is 1.
(c) If uis any other type of expression, then the numerical coeﬃcient
part is 1.
Letnbe the numerical coeﬃcient part of an expression. Give a proce-
dureNumerical
coeﬃcient (u) that returns a two-element list [ n, u/n]. For
example,Numerical
coeﬃcient (2/3xsin(x))→[2/3,xsin(x)].
12. Let ube analgebraic expression . Give a procedure Separate
sin
cos(u)
that returns a two-element list [ r, s] that is deﬁned using the following
rules.
(a) If uis a product, then sis the product of the operands of uthat are
sines, cosines, or positive integer powers of sines and cosines, and ris
theproductoftheremaining operandsof u. (Iftherearenooperands
in a category, return 1 for that category.)
(b) If uis a sine, cosine, or a positive integer power of a sine or cosine,
thens=uandr=1 .
(c) In all other cases, r=uands=1 .
For example,
Separate
sin
cos(3 sin( x)c o s (y))→[3,sin(x)c o s (y)],
Separate
sin
cos(1+sin( x))→[1+sin( x),1].
This procedure is used in the procedure Contract
trig
rulesin Figure 7.7,
page297.
13. Let ube analgebraic expression ,a n dl e t xandybe symbols. Give a
procedure
Separate
variables(u,x,y)
that determines if an expression uc a nb ef a c t o r e di nt h ef o r m u=p·q,
where pis free of y,a n dqis free of x. Use the factor operator in a CAS
to obtain the factorization of u.I fucan be factored in this form, return a
list [p,q], otherwise return false. For example,
Separate
variables(3xy+3x, x, y)→[3x, y+1],
Separate
variables(x+y, x, y)→false.
Thisprocedureisusedintheprocedure Separable
odedescribedinExercise
5on page168.
4.2 MPL’s Algorithmic Language 153
14. Let P=[ [x1,y1],...,[xr+1,yr+1]] be a list of 2 element lists, where xi
andyiare rational numbers. The Lagrange interpolation polynomial that
passes through these points is given by
L(x)=r+1
i=1yiLi(x).
where
Li(x)=(x−x1)···(x−xi−1)(x−xi+1)···(x−xr+1)
(xi−x1)···(xi−xi−1)(xi−xi+1)···(xi−xr+1).
Give a procedure Lagrange
polynomial (P,x) that returns the polynomial
L(x). For example,
Lagrange
polynomial ([[1,1],[2,−1]],x)→−2x+3.
15. Let ube an equation that involves xandy, and suppose that it is possible
to solve the equation for yas a linear expression in xusing algebraic op-
erations such as rational simpliﬁcation and expansion. Give a procedure
Line(u,x,y) that solves the equation for yand returns the result in the
formy=mx+b. Do not use the solve operator in a CAS in this exercise.
For example, your procedure should obtain the following transformations:
LineQx
2+y
3=1,x ,yw
→y=(−3/2)x+3,
LineQx
a=x+y
b,x ,yw
→y=b−a
ax,
LineWy/x−2
1−3/x=6,x ,y}
→y=8x−18.
16. A Taylor series for a function u(x,y) about the point ( a,b)i sg i v e nb y
T(x,y)=∞
i=0ui(x,y)/i!, (4.21)
where
ui(x,y)=i
j=0i!
(i−j)!j!∂iu(a,b)
∂xi−jyj(x−a)i−j(y−b)j.
For example, for u=e xp ( x)cos(y)a n d( a,b)=(0,0), the Taylor series is
T(x,y)=1+ x+(1/2)(x2−y2)+(1/6)(x3−xy2)−(1/3)xy2+···
Letu,a,a n dbbealgebraic expressions ,xandybe symbols, and nan o n -
negative integer. Give a procedure Taylor
2(u,x,y,a,b,n ) that obtains
the sum of the ﬁrst n+1 terms of the series ( 4.21).Note: A more eﬃcient
procedure is obtained byusing the expression ui−1(x,y)toobtain thenext
expression ui(x,y).
154 4. Elementary Mathematical Algorithms
17. Consider the diﬀerential equation and initial condition
dy(x)
dx=f(x,y(x)),y(a)=b. (4.22)
A Taylor series solution to this equation, which has the form
y(a)+dy(x)
dx(a)(x−a)+d2y(x)
dx2(a)(x−a)2
2!+···,
is found in the following way. The constant term in the series is given by
the initial condition in ( 4.22), and the second term is obtained using the
diﬀerential equation in ( 4.22)
dy(x)
dx(a)(x−a)=f(a,y(a))(x−a).
The third term is obtained by diﬀerentiating both sides of the diﬀerential
equation
d2y(x)
dx2=df(x,y(x))
dx,
and which gives
d2y(x)
dx2(a)(x−a)2
2!=df(x,y(x))
dxEEEE
x=a(x−a)2
2!.
The next term in the series is obtained in a similar way with the second
derivative of f(x,y(x)). For example, for the diﬀerential equation and
initial condition
dy(x)
dx=f(x,y(x))=x3+1
y(x)+3,y(0)=2 ,
the ﬁrstterm is y(0) = 2, and thesecond term is f(0,y(0))(x−0) = 7 /2x.
To obtain the third term, we ﬁrst obtain an expression for the secondderivative using the diﬀerential equation
d
2y(x)
dx2=df(x,y(x))
dx=3x2−dy(x)
dx
y(x)2=3x2−x3+1/y(x)+3
y(x)2,
and then using the substitutions y(x)=2and x=0 to obtain
d2y(x)
dx2(0)(x−0)2/2! =−7/16x2.
In a similar way the fourth term of the series is 35 /64x3.
Letwbe a diﬀerential equation in the form ( 4.22),xandybe symbols,
aandbbe algebraic expressions, and nbe a non-negative integer. Give a
procedure
Taylor
ode(w,x,y,a,b,n )
4.2 MPL’s Algorithmic Language 155
that obtains the sum of the ﬁrst n+1 terms of the Taylor series solution
to the diﬀerential equation. Note: Undersuitable conditions on f(x,y)the
Taylor series converges to y(x)f o rxin an interval about x=a.I nt h i s
case the polynomial obtained by Taylor
odeis an approximation to the
true solution to the diﬀerential equation.
18. Consider the two inﬁnite series
F=∞
n=0fn(t−t0)
n!,G=∞
n=0gn(t−t0)
n!, (4.23)
where the functions fn=fn(t)a n dgn=gn(t) are deﬁned by the relations
fn=dfn−1
dt−µ(t)gn−1, (4.24)
gn=fn−1+dgn−1
dt, (4.25)
with the initial functions given by
f0=1, (4.26)
g0=0. (4.27)
The two series in 4.23) are known in astronomy as the FandGseries
where they are used for orbit calculations.
The computation in this problem is one of the early (1965) applications of
computer algebra thatused theFORMAC computeralgebra system devel-oped at IBM(Bond et al.[ 11]). In thisproblem werestrict ourattention to
the symbolic computation problem associated with the computation of the
functions f
nandgn. Observe that Equation ( 4.24) contains an undeﬁned
function µ(t), which implies that fnandgnalsodependon t, and therefore
the diﬀerentiations in Equations ( 4.24)a n d(4.25) make sense. Using the
relations in ( 4.24)a n d(4.25) and the initial terms ( 4.26)a n d(4.27), the
next two terms of each sequence are given by
f1=0,g 1=1,f 2=−µ(t),g 2=0. (4.28)
Forlargervaluesof n, it iscustomaryin astronomical calculations todeﬁne
two additional functions σ(t)a n dλepsilonN(t) and to make the substitutions
dµ(t)
dt=−3µ(t)σ(t),dσ(t)
dt=λepsilonN(t)−2σ(t)2,dλepsilonN(t)
dt=−σ(t)(µ(t)+2λepsilonN(t)),
(4.29)
whenever these derivatives appear in the calculations. For example, tocompute f
3, we use Equations ( 4.24), (4.28), and (4.29)t oo b t a i n
f3=df2
dt−µ(t)g2=d(−µ(t))
dt−µ(t)·0=3µ(t)σ(t).
156 4. Elementary Mathematical Algorithms
In a similar way, we have
g3=−µ(t),f 4=−15µ(t)σ(t)2+3µ(t)λepsilonN(t)+µ(t)2,g 4=6µ(t)σ(t).
For larger values of n, the algebra becomes much more involved, and so
this is a good candidate for computer algebra.
(a) Using Equations ( 4.24), (4.25), (4.26), (4.27), and (4.28), show that
f5= 105 σ(t)3µ(t)−45µ(t)λepsilonN(t)σ(t)−15σ(t)µ(t)2,
g5=−45σ(t)2µ(t)+9λepsilonN(t)µ(t)+µ(t)2.
(b) Let nbe a positive integer, and let tbe a symbol. Give a procedure
FG(n,t) that returns the list [ fn,gn], where fnandgnare expressed
in terms of µ(t),σ(t), and λepsilonN(t).
4.3 Case Study: First Order Ordinary Differential
Equations
In this section we describe an algorithm that ﬁnds a solution to some
ﬁrst order diﬀerential equations using techniques similar to those found
in an elementary diﬀerential equations textbook. A ﬁrst order ordinary
diﬀerential equation is one in which the highest order derivative is a ﬁrstderivative. For example,
xdy
dx+y2=x−1
is a ﬁrst order diﬀerential equations, while
d2y
dx2+y=s i n (x)
is not. Although ﬁrst order diﬀerential equations are very diﬃcult to solve
in general, there are some speciﬁc forms that are solvable.
The solution technique we use involves the method of separation of
variables and the method of exact equations using integrating factors. In
the next few pages we describe these approaches in enough detail to allowus to formulate our procedures. Additional theory and examples can be
found in most diﬀerential equations textbooks
10.
10For example, see Simmons [ 87], Chapters 1 and 2, Boyce and DiPrima [ 12], Chapter
2, or Derrick and Grossman [ 32], Chapter 2.
4.3 Case Study: First Order Ordinary Differential Equations 157
Separation of Variables
A diﬀerential equation that can be expressed in the form
dy
dx=f(x)g(y) (4.30)
is called a separable diﬀerential equation. In this case, the notation implies
that the expression to the right of the equal sign can be factored as a
product of an expression that is free of yand one that is free of x.T os o l v e
the equation, divide both sides by g(y) and integrate with respect to x
/integraldisplay1
g(y)dy
dxdx=/integraldisplay
f(x)dx.
By the chain rule, this is equivalent to
/integraldisplaydy
g(y)=/integraldisplay
f(x)dx.
By integrating both sides of this equation, we obtain an implicit solution
to the diﬀerential equation.
Example 4.10. Consider the diﬀerential equation,dy
dx=2xy2. An implicit
solution is given by
/integraldisplaydy
y2=/integraldisplay
2xd x ,
−1
y=x2+C.
In this case, by solving for ywe obtain an explicit solution
y=−1
x2+C. (4.31)
In most cases, however, it is diﬃcult (or impossible) to express the solution
in explicit form. For this reason, our algorithm returns the result in implicit
form. /square
Exact Differential Equations and Integrating Factors
This technique applies to diﬀerential equations that can be transformed to
the form
M(x,y)+N(x,y)dy
dx=0. (4.32)
158 4. Elementary Mathematical Algorithms
Our goal is to ﬁnd an implicit solution to this equation that has the form
g(x,y)=C, (4.33)
whereCis an arbitrary constant. To obtain a solution algorithm, let’s
suppose this expression is a solution to Equation ( 4.32). Considering yas
a function of x, diﬀerentiating Equation ( 4.33) with the chain rule gives
dg
dx=∂g
∂x+∂g
∂ydy
dx=0. (4.34)
Comparing this equation to Equation ( 4.32), we obtain
∂g
∂x=M(x,y),∂g
∂y=N(x,y), (4.35)
and ﬁnd the solution to Equation ( 4.32) by solving these two equations for
g(x,y).
Example 4.11. Consider the diﬀerential equation
2x+3y2+( 6xy+y2)dy
dx=0. (4.36)
We ﬁnd a solution by solving the equations
∂g
∂x=2x+3y2,∂g
∂y=6xy+y2. (4.37)
Integrating the ﬁrst of these equations with respect to x,w eo b t a i n
g(x,y)=/integraldisplay∂g
∂xdx=/integraldisplay
2x+3y2dx=x2+3xy2+h(y).(4.38)
Since this operation inverts the partial diﬀerentiation operation, we assume
thatyis ﬁxed during the integration and obtain a constant of integration
h(y) that may depend on y, but is free of x. To ﬁndh(y), using Equation
(4.38) we diﬀerentiate g(x,y) with respect to y,
∂g(x,y)
∂y=∂(x2+3xy2+h(y))
∂y=6xy+h/prime(y),
and compare this result with the second equation in ( 4.37). Therefore,
6xy+h/prime(y)=6xy+y2,
4.3 Case Study: First Order Ordinary Differential Equations 159
which implies h/prime(y)=y2.Integrating with respect to y,w eo b t a i n h(y)=
y3/3, and therefore an implicit solution to the diﬀerential equation is
g(x,y)=x2+3xy2+y3/3=C. (4.39)
We can also start the process by integrating the second equation in ( 4.37)
with respect to y:
g(x,y)=/integraldisplay∂g
∂ydy=/integraldisplay
6xy+y2dy=3xy2+y3/3+k(x),
where now the constant of integration depends on x. Diﬀerentiating this
expression with respect to xand comparing the result with the ﬁrst ex-
pression in ( 4.37), we obtain k(x)=x2, which gives again the solution in
Equation ( 4.39). /square
The next example shows that the method does not always work.
Example 4.12. Consider the diﬀerential equation
2+3y/x+( 3+3y2/x)dy
dx=0,x > 0. (4.40)
We try to ﬁnd a solution by solving the equations
∂g
∂x=2+3y/x,∂g
∂y=3+3y2/x. (4.41)
Integrating the ﬁrst equation with respect to x,w eo b t a i n
g(x,y)=/integraldisplay∂g
∂xdx=/integraldisplay
(2 + 3y/x)dx=2x+3yln(x)+h(y).(4.42)
To ﬁndh(y), we diﬀerentiate this expression with respect to y
∂(2x+3yln(x)+h(y))
∂y=3l n (x)+h/prime(y)
and compare this result with the second equation in ( 4.41). We obtain
3l n (x)+h/prime(y)=3+3 y2/x, which implies h(y) is not free of xand so
the technique does not work. In addition, if we start the process by ﬁrst
integrating
∂g
∂y=3+3y2/x
with respect to yand then diﬀerentiating g(x,y) with respect to x,w e
ﬁnd that the constant of integration k(x) is not free of yand so again the
technique does not work. /square
160 4. Elementary Mathematical Algorithms
As we saw in the last example, for the technique to work the constants
of integration ( h(y)o rk(x)) must be free of the other variable ( xory).
Equations for which this happens are called exactdiﬀerential equations.
There is a simple test that determines if an equation is exact. It can beshown
11that an equation is exact if and only if
∂M
∂y=∂N
∂x. (4.43)
Using this relation, we can easily check that Equation ( 4.36) is exact, while
Equation ( 4.40)i sn o t .
When the equation is not exact, it may be possible to transform the
equation to one that is exact. We illustrate this in the next example.
Example 4.13. Consider again the diﬀerential equation from the last ex-
ample
2+3y/x+( 3+3y2/x)dy
dx=0,
wherex>0. If we multiply both sides of the equation by u(x,y)=x,w e
obtain a new diﬀerential equation
2x+3y+( 3x+3y2)dy
dx=0. (4.44)
Since∂M
∂y=3=∂N
∂x,
Equation ( 4.44) is exact, and the solution technique for exact equations
gives the implicit solution x2+3xy+y3=C. /square
The expression u(x,y) in the previous example is called an integrating
factor for the diﬀerential equation. Although an integrating factor always
exists in theory, it may be very diﬃcult to ﬁnd in practice12.T w o c a s e s
where simple integrating factors can be found are described in the followingtheorem.
Theorem 4.14. Consider the diﬀerential equation
M(x,y)+N(x,y)dy
dx=0.
11See Simmons [ 87], pp. 51-52, Boyce and DiPrima [ 12], page 84, Derrick and Gross-
man [ 32], page 41.
12For example, see Boyce and DiPrima [ 12], page 87, where it is shown that the
integrating factor is a solution to a partial diﬀerential equation. Unfortunately, it maybe very diﬃcult to solve the partial diﬀerential equation.
4.3 Case Study: First Order Ordinary Differential Equations 161
1. Let
F=∂M
∂y−∂N
∂x
N. (4.45)
IfFis free ofy, then an integrating factor is u=e x p/parenleftbig/integraltext
Fd x/parenrightbig
.
2. Let
G=∂N
∂x−∂M
∂y
M. (4.46)
IfGis free ofx, then an integrating factor is u=e x p/parenleftbig/integraltext
Gd y/parenrightbig
.
In either case, uM+uNdy
dx=0is an exact diﬀerential equation.
Example 4.15. Consider again the inexact equation
2+3y/x+( 3+3y2/x)dy
dx=0,x > 0.
We have
F=/parenleftBig
∂M
∂y−∂N
∂x/parenrightBig
N=3/x+3y2/x2
3+3y2/x=1/x, (4.47)
where the expression on the right is obtained with rational simpliﬁcation.
Since this expression is free of y,u=e x p (/integraltext
1/x dx)=xis an integrating
factor and we obtain the exact form of Equation ( 4.44).
On the other hand, since
G=/parenleftBig
∂N
∂x−∂M
∂y/parenrightBig
M=−3y2/x2−3/x
2+3y/x=−3x−3y2
2x2+3xy
is not free of x, this approach does not obtain an integrating factor that is
free ofx. /square
TheSolve
 ode Algorithm
An MPL algorithm that attempts to solve a ﬁrst order diﬀerential equation
is given in Figures 4.16and4.17. The algorithm returns either an implicit
solution to the diﬀerential equation, which may include some unevaluated
integrals, or the global symbol Failif it cannot ﬁnd a solution using the
methods described in this section. The main procedure of the algorithm is
162 4. Elementary Mathematical Algorithms
Procedure Solve
ode(w,x,y);
Input
w: a diﬀerential equation that can be transformed by
rational simpliﬁcation to the form M+Ndy
dx=0,
where the derivativedy
dxis represented by the function form d(y,x);
x,y:s y m b o l s ;
Output
An implicit solution to the diﬀerential equation or the global symbol Fail;
Local Variables
p,M,N,F ;
Begin
1 p:=Transform
ode(w,x,y);
2 M:=Operand(p,1);
3 N:=Operand(p,2);
4 F:=Separable
ode(M,N,x,y );
5 ifF=Fail then
6 F:=Solve
exact(M,N,x,y )
7Return(F)
End
Procedure Transform
ode(w,x,y);
Input
same asSolve
ode;
Output;
the list [ M,N];
Local Variables
v,n,M,N ;
Begin
1 v:=Rational
simplify(Operand(w,1)−Operand(w,2));
2 n:=Numerator (v);
3 M:=Coeﬃcient (n, d(y,x),0);
4 N:=Coeﬃcient (n,d(y,x),1);
5Return([M,N])
End
Figure 4.16. The MPL procedures Solve
odeandTransform
ode. (Implementa-
tion:Maple(txt),Mathematica (txt),MuPAD(txt).)
4.3 Case Study: First Order Ordinary Differential Equations 163
Procedure Solve
exact(M,N,x,y );
Input
M,N:algebraic expressions ;
x,y:s y m b o l s ;
Output
An implicit solution to the diﬀerential equation or the global symbol Fail;
Local Variables
My,Nx,d,u,F,G,g,h, hp;
Begin
1 ifN=0then
2Return(Fail)
3 elseif M=0then
4Return(y=C);
5My:=Derivative (M,y);
6Nx:=Derivative (N,x);
7 d:=My−Nx;
8 ifd=0then
9 u:= 1
10 else
11 F:=Rational
simplify(d/N);
12 ifFree
of(F,y)then
13 u:=exp(Integral(F,x));
14 d:= 0
15 else
16 G:=Rational
simplify(−d/M);
17 ifFree
of(G,x)then
18 u:= exp(Integral(G,y));
19 d:= 0;
20 ifd=0then
21 g:=Integral(u∗M,x);
22hp:=u∗N−Derivative (g,y);
23 h:=Integral(hp,y);
24Return(g+h=C)
25 else
26Return(Fail)
End
Figure 4.17. The MPLSolve
exactprocedure. (Implementation: Maple(txt),
Mathematica (txt),MuPAD(txt).)
164 4. Elementary Mathematical Algorithms
Solve
 ode(w,x,y ), wherewis the diﬀerential equation with the derivative
symbol
dy
dx
represented by the function form13d(y,x).
A tl i n e1 ,w ei n v o k et h e Transform
 odeprocedure which does some
preliminary manipulation of the equation and returns the list [ M,N]w i t h
the expressions M(x,y)a n dN(x,y)i n(4.32). This procedure, which is
shown in the bottom of Figure 4.16, permits some ﬂexibility in the form of
the input equation. For example, by preprocessing the equation with this
procedure we can handle equations with forms like
1−(2x+1 )d(y,x)=0,1−2xd(y,x)=−d(y,x),
or even
1/d(y,x)=2x+1. (4.48)
At line 1 of Transform
 odewe subtract the right side of the equation from
the left side and then simplify this expression using the Rational
 simplify
operator. Next, line 2 selects the numerator of v. For example, if wis given
by Equation ( 4.48), then after executing lines 1 and 2 we have
n:= 1−2xd(y,x)−d(y,x). (4.49)
In lines 3 and 4 we view nas a polynomial in d(y,x)a n dr e t r i e v e Mand
Nby selecting coeﬃcients of this polynomial. For example, for Equation
(4.48) the procedure returns [1 ,−2x−1].
At this point, control is returned to Solve
 odewhich obtains MandN
and then calls on Separable
 odeto ﬁnd a solution (lines 2, 3, and 4). This
procedure attempts to solve
dy
dx=−M/N
using the separation of variables technique. (The Separable
 odeprocedure
i sd e s c r i b e di nE x e r c i s e 5.) If this method fails, the Solve
 exactprocedure,
which attempts to solve the diﬀerential equation using the method of exact
equations, is invoked at line 6.
TheSolve
 exactprocedure is shown in Figure 4.17. To begin, two simple
cases are considered in lines 1-4. First, if N= 0, there is no ﬁrst derivative
13I nM a p l ea n dM u P A Dw er e p r e s e n tt h ed e r i v a t i v ew i t h d(y,x), while in Mathematica
we use d[y,x]. We use this notation instead of the derivative operator in a CAS because
the details of the Solve
odealgorithm are somewhat simpler with this representation.
This representation for the derivative is also used in Exercise 15on page 197and Exercise
15on page 240.
4.3 Case Study: First Order Ordinary Differential Equations 165
term in the equation, and so the procedure returns the global symbol Fail.
Next, ifN/negationslash=0a n dM= 0, the diﬀerential equation is equivalent to
dy
dx=0,
and so the constant solution is returned. Lines 5 and 6 compute the partial
derivatives in Expression ( 4.45) and line 7 evaluates the diﬀerence of these
derivatives so we can test if the equation is exact14. At line 8, if d=0
the equation is exact and an integrating factor is not required. Therefore,
uis assigned the expression 1 at line 9, and control is transferred to line
20. On the other hand, if at line 8 d/negationslash= 0, we assume the equation is not
exact and compute and test Fto determine if there is an integrating factor
that is free of y. Notice we apply the Rational
 simplify operator in line
11 since automatic simpliﬁcation may not remove the symbol yfromF
(see Example 4.15above). The free-of test is done in line 12, and if it is
successful we compute the integrating factor in line 13. The assignment inline 14 allows the procedure to proceed with the solution technique in line
20. If the test in line 12 fails we compute and test Gto determine if there
is an integrating factor that is free of x(lines 18 - 19).
In line 20, if d= 0, we apply the method of exact equations (lines 21-23)
and return an implicit solution at line 24. If at line 20, d/negationslash= 0 an integrating
factor has not been found, and so we return the symbol Failin line 26.
Theory versus Practice
In a theoretical sense, a separable equation can be solved using the method
of exact equations by expressing Equation ( 4.30) in the exact form
−f(x)+1
g(y)dy
dx=0.
In practice, however, the manipulations in the procedure Transform
 ode
may transform a separable equation in exact form to a non-exact equation
that cannot be solved by Solve
 exact. This point is illustrated in the next
example.
Example 4.16. Consider the separable equation
−x
x+2+y
y+1dy
dx=0.
14Observe that dis computed in the context of automatic simpliﬁcation. Although
this context is suﬃcient when MandNare polynomials in xandy,i ti sp o s s i b l et o
construct equations where additional simpliﬁcation power is needed.
166 4. Elementary Mathematical Algorithms
For this equation, the manipulations in Transform
 odeobtainM=−yx−x
andN=xy+2ywhich gives a diﬀerential equation in non-exact form. In
addition, at lines 11 and 16 in Solve
 exact,w eo b t a i n F=−(x+y)/(xy+
2y) which is not free of yandG=−(x+y)/(xy+x) which is not free of
x. Therefore, Solve
 exactcannot ﬁnd an integrating factor and so it cannot
ﬁnd a solution to the equation. /square
Unfortunately, there are other (non-separable) exact equations that
loose their exactness in Transform
 odeand cannot be solved with
Solve
 exact(see Exercise 3).
Appraisal of the Algorithm
Given appropriate input, the Solve
 odealgorithm ﬁnds the general solution
to many ﬁrst order diﬀerential equations found in textbooks on ordinary dif-
ferential equations. In addition, another approach for the integrating factor
and special techniques for homogeneous equations and Bernoulli equationsthat extend the capacity of the algorithm are described in Exercises 4,6,
and Exercise 16on page 241. However, compared to the diﬀerential equa-
tion solver found in a CAS, the algorithm is quite limited. The operators
in these systems include additional techniques for many special forms and
other general techniques
15.
In some cases the implicit solution that is found by our algorithm does
not describe all solutions to the diﬀerential equation.
Example 4.17. Consider the diﬀerential equation
dy
dx=2xy2(4.50)
given in Example 4.10. Our algorithm ﬁnds the solution in the form −x2−
1/y=Cwhich has the explicit form y=−1/(x2+C). Observe that y=0
is also a solution of the diﬀerential equation, but does not ﬁt the generalpattern. This solution, which is not found by our algorithm, is called a
singular solution of the diﬀerential equation. /square
In order for the MPL algorithm to produce an appropriate result, the
input diﬀerential equation must have a form that can be analyzed correctly
15In the Maple system, to see the methods used by the dsolve command, assign
infolevel[dsolve] := 3 . Try this for the diﬀerential equation
dy
dx=x+y+4
x−y−6
that cannot be solved by the algorithm in this section (including the additional tech-
niques in the exercises), but which can be solved by Maple.
4.3 Case Study: First Order Ordinary Differential Equations 167
by the Transform
 odeprocedure. A suitable form is one that can be trans-
formed by the operations in lines 1 and 2 of this procedure to a form where
the actions of the Coeﬃcient operator in lines 3 and 4 are well-deﬁned and
able to obtain the entire structure of the equation. If this is not so, theoutput of the algorithm may be meaningless. For example, for the equation
/parenleftbiggdy
dx/parenrightbigg1/2
+x=y,
the expression n=(d(y,x))∧(1/2)+x−yat line 2 is not a polynomial in
d(y,x) and so the coeﬃcient operations in lines 3 and 4 are undeﬁned. In
addition, for diﬀerential equations that contain higher order derivatives oran integer power of a derivative, the coeﬃcient operations may be deﬁned
but the output is meaningless since the algorithm does not apply to equa-
tions that include these forms. It is possible to modify Transform
odeso
that is does a more thorough analysis of the input equation to determine
if the equation has an appropriate form (see Exercise 14on page 240).
Exercises
1. Consider the diﬀerential equation
(2y−x2)+(2x−y2)dy
dx=0.
Solve the equation using the algorithm in the text.
2. Consider the diﬀerential equation ( y−1/x)dy
dx+y/x2=0 .
(a) Show that the equation is exact.
(b) Show that the manipulations in the Transform
odeprocedure trans-
form the equation to a non-exact equation.
(c) Show that the Solve
exactprocedure can ﬁndthe solution to the new
equation obtained in part (b) by ﬁnding an integrating factor.
3. Consider the diﬀerential equation1
x3y2+W1
x2y3+3y}dy
dx=0.
(a) Show that the equation is exact.
(b) Show that the manipulations in the Transform
odeprocedure trans-
form the equation to a non-exact equation.
(c) Show that the Solve
odeprocedure is unable to solve this equation
because it is unable to ﬁnd an integrating factor for the equation inpart (b). (However, see Exercise 4.)
168 4. Elementary Mathematical Algorithms
4. Let R=(∂M/∂y −∂N/∂x)/(N·y−M·x)andsupposethat Ris afunction
of the product xy. In this case, it can be shown that for z=xy,
u(x,y)=e xpW
R(z)dz}
is an integrating factor16. For example, for the diﬀerential equation
y+(x+3x3y4)dy
dx=0,x >0,y >0,
we have R=−3/(xy)=−3/zandu=1/(xy)3.E x t e n dt h e Solve
exact
procedure so that it determines when this integrating factor is appropriateand when this is so, uses it to ﬁnd a solution. Test the procedure on the
above equation. Hint:LetS=Substitute (R, x=z/y).IfRhas the proper
form, then Sis free of y.
5. Give a procedure Separable
ode(M,N,x,y ) that tries to determine if a
diﬀerential equation ( 4.32) can be transformed to the form of Equation
(4.30),and,whenthisisso, obtainsanimplicit solutionusingtheseparable
approach. If this technique does not apply, return the global symbol Fail.
Hint:TheSeparate
variables procedure described in Exercise 13on page
152is useful in this exercise.
6. A diﬀerential equation that can be transformed to the form
dy
dx=f(y/x) (4.51)
is called ahomogeneous17diﬀerential equation. For example, the equation
dy
dx=e x p ( y/x)+y/x
is homogeneous. A homogeneous diﬀerential equation can be solved by
deﬁning a new variable z=y/xand transforming the diﬀerential equation
to one in terms of z.U s i n gt h er e l a t i o n y=xz,w eh a v e
dy
dx=xdz
dx+z
and Equation ( 4.51) becomes
dz
dx=(f(z)−z)/x. (4.52)
This equation can be solved by separating the variables xandz. Then,
we obtain the solution to Equation ( 4.51) by substituting z=y/xinto the
solution to Equation ( 4.52). Give a procedure Homogeneous (M,N,x,y )
16See Simmons [ 87], Exercise 1 on page 59.
17The term homogeneous has a number of meanings with regard to diﬀerential equa-
tions. For example, two diﬀerent meanings are given in Exercises 6and7.
4.3 Case Study: First Order Ordinary Differential Equations 169
that determines if a ﬁrst order diﬀerential equation ( 4.32) is homogeneous
and, if so, solves the equation using the approach outlined above. If the
equation is not homogeneous, return the global symbol Fail.Hint:First,
represent the diﬀerential equation in the form
dy
dx=−M/N,
and let r=Substitute (f, y=zx). Ifris free-of x, the original equation is
homogeneous. Note that the equation
dy
dx=x+y
x−y
is homogeneous (dividethenumerator anddenominator by x). Inthis case
r=(x+xz)/(x−xz), and so we must apply a Rational
simplifyoperator
torto remove the x.
7. Consider the second order linear diﬀerential equation
ad2y
dx2+bdy
dx+cy=f, (4.53)
where a,b,a n d care rational numbers and fis analgebraic expression
that is free of y.
(a) If f= 0, the equation is called a homogeneous17equation and two
linearly independent solutions to the diﬀerential equation y1andy2
are obtained as follows: let D=b2−4ac.I fD>0, then
y1=e xp (( −b+√
D)/(2a)x),y 2=e xp(( −b−√
D)/(2a)x).
IfD=0 ,the n
y1=e xp ( −b/(2a)x),y 2=xexp(−b/(2a)x).
IfD<0, then
y1=e x p ( −b/(2a)x)s i n (√
−D/(2a)x),
y2=e x p ( −b/(2a)x)cos(√
−D/(2a)x).
Give a procedure
Homogeneous
 2(a,b,c,x)
that returns the list [ y1,y2].
(b) A particular solution ypto Equation ( 4.53) is obtained using the
methodvariation of parameters . Using this technique, yp=v1y1+
v2y2where y1andy2are the two linearly independent solutions to
the homogeneous equation (described above) and the derivatives v/prime
1
andv/prime
2satisfy the linear system
v/prime
1y1+v/prime
2y2=0,v/prime
1y/prime
1+v/prime
2y/prime
2=f/a.
170 4. Elementary Mathematical Algorithms
The expressions v1andv2are obtained from their derivatives by
integration. Giveaprocedure Variation
of
param(y1,y2,f,a,x)that
obtains yp.
(c) The general solution to the diﬀerential equation is given by
y=dy1+ey2+yp, (4.54)
where dandeare symbols that represent arbitrary constants. Give a
procedureSolve
ode
2(a,b,c,f,x,y )thatobtainsthegeneralsolution
toEquation( 4.53). Youshouldreturntheresultasanequation y=u
where uis the expression on the right side of Equation ( 4.54). A
related operator is considered in Exercise 15on page240.
8. See Exercise 14on page240and Exercise 16on page241.
Further Reading
4.2MPL’s Algorithmic Language. TheTaylorseriessolutiontoadiﬀerential
equation described in Exercise 17on page154is discussed in Zwillinger [ 109],
Section140. SeeSconzoetal. [ 86]foradiscussionoftheclassicalhandcalculation
ofFandGseries (see Exercise 18on page155) and a summary of the results
obtained with a CAS.
4.3Case Study: Solution ofFirst Order Ordinary Diﬀerential Equa-
tions.The techniques used in this section are described in Simmons [ 87], Boyce
and DiPrima [ 12], and Derrick and Grossman [ 32]. Zwillinger [ 109]a n dM ur p h y
[72] describe manytechniquesfor ﬁndinganalytical solutions todiﬀerentialequa-
tions. PostelandZimmermann[ 81]summarizestechniquesforsolvingdiﬀerential
equations in a computer algebra context.
5
Recursive Algorithms
In this chapter we examine how recursion is used to implement algorithms
in computer algebra. We begin, in Section 5.1, by describing how a sim-
ple recursive procedure is implemented by a CAS. In Section 5.2,w eg i v e
recursive procedures for a number of operators and describe an approach
using transformation rules that provides a simple way to implement some
recursive operations. Finally, in Section 5.3we describe a recursive algo-
rithm for a simple version of the Integral operator that utilizes some basic
integration rules together with the substitution method.
5.1 A Computational View of Recursion
In Chapter 3we gave the following recursive deﬁnition for the factorial
operation:
n!=/braceleftbigg1, ifn=0 ,
n·(n−1)!,ifn>0.(5.1)
Forn= 4, the computation based on this deﬁnition ( 5.1) proceeds as
follows:
4! = 4(3!) = 4(3(2!)) = 4(3(2(1!))) = 4(3(2(1(0!))))
= 4(3(2(1(1)))) (5.2)
=2 4.
To perform the calculation, we repeatedly apply ( 5.1)u n t i ln=0i se n -
countered. Once this point is reached, 0! is replaced by the value 1, and
the numerical computation proceeds as indicated by the parentheses in the
second line of Equations ( 5.2).
171
172 5. Recursive Algorithms
Procedure Rec
fact(n);
Input
n: non-negative integer;
Output
n!;
Local Variables
f;
Begin
1 ifn=0then
2 f:= 1
3 else
4 f:=n∗Rec
fact(n−1)
5Return(f)
End
Figure 5.1. An MPL recursive procedure for n!. (Implementation: Maple(txt),
Mathematica (txt),MuPAD(txt).)
Figure 5.1shows an MPL recursive procedure that performs this calcu-
lation. For the case n>0, the procedure calls on itself (line 4) to perform
a “simpler” version of the calculation. A procedure that calls on itself di-
rectly (as in this example) or indirectly through a sequence of proceduresis called a recursive procedure .T h ec a s e n= 0 (lines 1, 2) is called a ter-
mination condition for the procedure, since it is deﬁned directly and does
not require further calls on Rec
fact. For each positive integer n,t h ec a l -
culation is eventually reduced to the termination condition which stops the
recursion. Each recursive procedure must have one or more terminationconditions.
Let’s trace the execution of the procedure in response to the evaluation
ofRec
fact(4) from the interactive mode. When the procedure is invoked,
a CAS allocates a block of computer memory that includes storage loca-tions for the local variable f, the input variable n, and the next statement
executed by the system once Rec
factis done. The storage allocation for
Rec
fact(4) (before the calculation in line 4) is shown in Figure 5.2(a). At
this point, the local variable fhas not been assigned, and the “next state-
ment executed” refers to the interactive mode that invoked the procedure
and will display the result once the operation is done.
The actual calculation is done in line 4. But before this can be done, we
need the value for Rec
fact(3), and this requires another call on the pro-
cedure. To invoke Rec
fact(3), a CAS again allocates a block of memory
5.1. A Computational View of Recursion 173
n
f
next statement
executed
4
 interactive
mode
(a) The storage allocation stack for Rec
fact(4)
before calculation on line 4.
n
f
next statement
executed
3
 Rec
fact, line 4
(n=4c a s e )
4
 interactive
mode
(b) The storage allocation stack for Rec
fact(3)
andRec
fact(4). The local variable fhas not
been assigned a value in either block.
n
f
next statement
executed
0
1
Rec
fact, line 4
(n=1c a s e )
1
 Rec
fact, line 4
(n=2c a s e )
2
 Rec
fact, line 4
(n=3c a s e )
3
 Rec
fact, line 4
(n=4c a s e )
4
 interactive
mode
(c) The storage allocation stack for
the sequence of Rec
factprocedure
calls before the recursion unwinds.
Figure 5.2. The storage allocation stack for the procedure Rec
factat various
points in the computation of 4!.
to store the information associated with this procedure call. Figure 5.2(b)
illustrates the memory allocation for Rec
factat this point in the calcula-
tion. There are now two separate blocks of memory, one for the current
casen= 3 and one for the previous case n= 4 which is not yet done and
remains in memory. Notice that each block has its own storage locations
for the input variable nand the local variable f. In the computer’s mem-
ory, these two blocks reside in an internal data structure known as a stack.
174 5. Recursive Algorithms
Brieﬂy, a stack is a data structure for which data (or blocks of data) can
only be inserted or removed from the top of the stack1.In t h i s c a s e , t h e
top of the stack ( n= 3) contains the active version of Rec
fact,a n dl o w e r
levels of the stack contain previous versions of Rec
fact, which have been
invoked but are not yet done. For n=3 ,t h el o c a lv a r i a b l e fhas not been
assigned, and “next statement executed” refers to line 4 in the previous
version Rec
fact(4) which invoked Rec
fact(3).
Now, to compute Rec
fact(3), we need the value of Rec
fact(2), which
means we again invoke Rec
factand assign yet another block of memory
to the procedure. To complete the calculation, we continue invoking the
procedure for successively smaller integer values until the termination con-
ditionn= 0 is reached. The memory allocation stack at this point is shown
in Figure 5.2(c). Observe that the currently active version ( n=0 )i sa tt h e
top of the stack, and the other levels of the stack represent the previous
procedure calls that led to this place in the calculation. At this point, thevariablef(for then= 0 case) is assigned the value 1 (with lines 1, 2),
and this value is returned as the value of Rec
fact(0). Once this is done,
the block of memory allocated for Rec
fact(0) is no longer needed and is
removed from the top of the stack. Control is now transferred back to line
4i nRec
fact(1) which performs the multiplication and assignment:
f:= 1∗Rec
fact(0)→1∗1→1 (calculation in Rec
fact(1)).
This value is returned to Rec
fact(2) which invoked Rec
fact(1), and the
memory allocated for Rec
fact(1) is removed from the top of the stack.
The recursive process continues to unwind in this fashion, performing the
multiplication and assignment in line 4 for the diﬀerent versions of Rec
fact:
f:= 2 ∗Rec
fact(1)→2∗1→2 (calculation in Rec
fact(2)),
f:= 3 ∗Rec
fact(2)→3∗2→6 (calculation in Rec
fact(3)),
f:= 4 ∗Rec
fact(3)→4∗6→24 (calculation in Rec
fact(4)).
In each case, once an expression has been returned by Rec
fact(n−1) to
the calling procedure Rec
fact(n) (or the interactive mode), the block of
memory associated with Rec
fact(n−1) is removed from the top of the
stack. After the last calculation, the expression 24 is returned as the value
ofRec
fact(4).
TheRec
factprocedure is presented to illustrate simply what is meant
by a recursive procedure and to show how it is evaluated by a CAS. In
practice, the recursive procedure for n!i sl e s se ﬃ c i e n ti nt e r m so fc o m p u t e r
time and memory than a non-recursive iterative procedure.
1A useful metaphor for a stack data structure is a stack of food trays. For safety’s
sake, we always remove a tray from the top of the stack and add a tray to the stack byplacing it on the top.
5.1. A Computational View of Recursion 175
Infinite Recursive Loops
Ac a l lt o Rec
fact(n)t e r m i n a t e sa sl o n ga s nis a non-negative integer.
However, if nis a negative integer (or any expression that does not evaluate
to a positive integer), the termination condition in line 1 is never satisﬁed,
and so the process does not terminate. For example, when n=−1, we
obtain the inﬁnite sequence of procedure calls:
Rec
fact(−1),Rec
fact(−2),Rec
fact(−3),....
Since this problem is similar to the inﬁnite loops that can arise with itera-
tion structures, it is called an inﬁnite recursive loop .
Exercises
1. Let nbe a positive integer. The harmonic number H(n) is deﬁned by the
sum:
H(n)=1+1 /2+···+1/n.
Give a recursive procedure for H(n). The procedure should not use a for
structure or a whilestructure.
2. TheFibonacci numbersequence f0,f1,f2,...is deﬁnedusingtherecursive
deﬁnition:
fn=k1, whenn=0o r n=1 ,
fn−1+fn−2,whenn>1.(5.3)
(a) Compute f4.
(b) HereisarecursiveMPLprocedurethatcomputestheFibonaccinum-
bers:
Procedure Fibonacci (n);
Input
n: non-negative integer;
Output
fn;
Local Variables
f,g,r;
Begin
1 ifn=0orn=1then
2 r=1
3 else
4 f:=Fibonacci (n−1);
5 g:=Fibonacci (n−2);
6 r:=f+g;
7 Return(r)
End
176 5. Recursive Algorithms
Trace the ﬂow of the Fibonacci procedure for n= 4 showing all
changes in the storage allocation stack during the course of the com-
putation.
(c) Give a non-recursive procedure that uses iteration to compute fn.
(d) TheFibonaccicomputationisnotaparticularlygooduseofrecursion
since the non-recursive approach requires fewer additions than the
recursive approach. Explain why this is so.
3. Let Sbe a non-empty set that contains nexpressions, and for 0 ≤k≤n
letC(n,k) be the number of distinct subsets of size kofS. We can obtain
C(n, k) using the familiar combination formula
C(n, k)=n!
k!(n−k)!.
C(n, k) can also be obtained recursively using the recurrence relation
C(n, k)=k1, ifk=0o r k=n,
C(n−1,k−1)+C(n−1,k),otherwise.(5.4)
Give a procedure for C(n,k) that is based on Expression ( 5.4). Do not use
the factorial operation in this procedure.
5.2 Recursive Procedures
In this section we give a number of examples that illustrate the possibili-
ties and limitations of recursion as an algorithmic approach for computeralgebra.
TheComplete
 sub
expressions Operator
In this example we describe a procedure that obtains the set of complete
sub-expressions of an expression u. Since the solution of this problem
involves a systematic traversal of the expression tree for u, a recursive
procedure is the natural choice.
An MPL procedure that performs this operation is given in Figure 5.3.
Lines 1-2, which apply to atomic expressions, provide the termination con-dition for the recursion. For compound expressions, the statements in lines
4-7 obtain the set of sub-expressions by forming the set union of {u}and
the sets of sub-expressions of the operands of u.
Let’s see how the procedure works for u=a∗(x+1 )+3 ∗cos(y),
which is represented by the expression tree in Figure 5.4. The ﬂow of the
computation in response to the statement
Complete
sub
expressions (a∗(x+1 )+3 ∗cos(y)) (5.5)
5.2. Recursive Procedures 177
Procedure Complete
 sub
expressions (u);
Input
u:amathematical expression ;
Output
the set of complete sub-expressions of u;
Local Variables
s,i;
Begin
1 ifKind(u)∈{integer ,symbol ,real}then
2Return({u})
3 else
4 s:={u};
5 fori:= 1toNumber
of
operands(u)do
6 s:=s∪Complete
 sub
expressions (Operand(u,i));
7Return(s)
End
Figure 5.3. An MPL procedure that ﬁnds the set of complete sub-expressions of
u. (Implementation: Maple(txt),Mathematica (txt),MuPAD(txt).)
 
 
  ❅
❅
❅❅
❅
❅
❅
❅ 
 
 
 
❅
❅ 
 
x ycos 3 +
1a+
∗∗
Figure 5.4. An expression tree for a∗(x+1)+3 ∗cos(y).
i ss h o w ni nF i g u r e 5.5. The arrows that point downward on solid lines
represent a recursive call to a procedure, and those that point upward on
dashed lines represent a return to the calling procedure. The expressions at
the nodes represent the input expression uon various calls of the procedure,
178 5. Recursive Algorithms
a{a∗(x+1 ),a ,
{1}
1{x}x+1a∗(x+1 )
{x+1,x , 1}{a∗(x+1 )+3 ∗cos(y),a∗(x+1 ),
x+1,x , 1}cos(y),y}a, x +1,x , 1,3∗cos(y),3,Interactive Mode
a∗(x+1 )+3 ∗cos(y)
x{3∗cos(y),3,cos(y),y}
3∗cos(y)
{3}
3{cos(y),y}{a}
ycos(y)
{y}
Figure 5.5. The sequence of recursive calls that obtains the set of complete
sub-expressions of a∗(x+1)+3 ∗cos(y).
and the sets of expressions to the right of the dashed lines above the nodes
represent the output of that call.
By tracing the path along the solid and dashed lines, we observe the
entire path of the computation. For example, to evaluate Expression ( 5.5),
the procedure must ﬁrst evaluate
Complete
 sub
expressions (a∗(x+1 ) ), (5.6)
Complete
 sub
expressions (3∗cos(y)). (5.7)
Observe that the entire computation associated with ( 5.6) is done before
(5.7) is invoked, and to obtain ( 5.6), the procedure must evaluate
5.2. Recursive Procedures 179
Complete
 sub
expressions (a),
Complete
 sub
expressions (x+1 ).
Continuing in this fashion, we systematically build up the set of sub-
expressions of a∗(x+1 )+3 ∗cos(y)t oo b t a i n
{a∗(x+1 )+3 ∗cos(y),a∗(x+1 ),a,x+1,x,1,3∗cos(y),3,cos(y),y}.
TheFree
 ofOperator
The procedure for the Free
of(u,t) operator (see Deﬁnition 3.28, page 110)
is another example that utilizes the recursive tree structure of an expres-
sion. Recall that the operator returns falsewhentis syntactically equal
to a complete sub-expression of u, and otherwise returns true.
An MPL procedure for the Free
ofoperator is given in Figure 5.6.L i n e s
1 and 3 serve as terminating conditions for the procedure. If the condition
in line 3 istrue, the procedure returns truebecause the condition in line
1i sfalseandudoes not have any operands. The loop (lines 7-10) applies
Procedure Free
of(u,t);
Input
u,t:mathematical expressions ;
Output
trueorfalse;
Local Variables
i;
Begin
1 ifu=tthen
2Return(false)
3 elseifKind(u)∈{symbol ,integer ,real}then
4Return(true)
5 else
6 i:= 1;
7 while i≤Number
of
operands(u)do
8 ifnotFree
ofOperand(u,i),t)then
9 Return(false);
10 i:=i+1;
11Return(true)
End
Figure 5.6. An MPL procedure for the Free
ofoperator. (Implementation:
Maple(txt),Mathematica (txt),MuPAD(txt).)
180 5. Recursive Algorithms
the procedure recursively to each operand of u. Notice when a recursive
call on some operand returns false, there is no need to check the remaining
operands and so the value falseis returned immediately. If all operands of
ua r ef r e eo f t, the procedure returns true(line 11).
In the current form, the Free
ofoperator cannot determine if an expres-
sion is free of an algebraic operator or function name. A modiﬁcation ofthe procedure that handles these cases is described in Exercise 1(b).
A useful extension of the Free
ofoperation is to check if uis free of
each expression in a set (or list) Sof expressions. The procedure for
Set
free
of(u,S) that performs this operation is a simple modiﬁcation of
the one for Free
of(u,t). The details of this extension are left to the reader
(Exercise 1(c)).
Pattern Matching, the Linear
 form Operator
Many operations in mathematics depend on recognizing that an expression
has a particular form. In this example we describe Linear
 form(u,x), a
simple pattern-matching procedure that checks if an algebraic expression
uhas the form ax+b, where the expressions aandbare free of x.W h e n
this is so, the procedure returns the list [ a,b], and otherwise returns the
global symbol Fail. We interpret this form in a broad sense to include
more involved sums (e.g., ax+2x+b+3 )a sw e l la se x p r e s s i o n st h a ta r e
not sums (e.g., 3, x,2x,x/a).
An MPL procedure for this operation is shown in Figure 5.7.L i n e s1 - 4
handle two simple cases that have the required form. Lines 5-11 check theform of a product, where lines 8-9 check if the symbol xis an operand of
the product. In lines 12-21, recursion is used to check if the operands of a
sum have the proper form. To do this, we apply the operator to the ﬁrst
operand of the sum (line 13) and the remaining operands (line 17), and
then combine the results (line 21). If some operand of the sum does nothave the proper form, the symbol Failis returned (lines 15, 19). Lines 22-
25 handle other expression types (e.g., powers, function forms, factorials),
which only have the proper form when they are free of x.
There are two places in this procedure where recursion is used, lines 13
and 17. We can eliminate this recursion by using an iteration structure tocheck the operands of a sum and by repeating the statements for the tests
in lines 1-11 and 22-25. Although recursion can be eliminated here, it is
used as a matter of convenience to obtain a shorter procedure.
Pattern-matching procedures are given for quadratic polynomials in
Exercise 8, and for more general polynomials in Chapter 6.
5.2. Recursive Procedures 181
Procedure Linear
form(u,x);
Input
u:a nalgebraic expression ;
x:as y m b o l ;
Output
the list [ a,b], where aandbarealgebraic expressions , or the global
symbol Fail;
Local Variables
f,r;
Begin
1 ifu=xthen
2Return([1,0])
3 elseifKind(u)∈{symbol ,integer ,fraction }then
4Return([0,u])
5 elseifKind(u)=” ∗”then
6 ifFree
of(u,x)then
7 Return([0,u])
8 elseifFree
of(u/x, x)then
9 Return([u/x,0])
10 else
11 Return(Fail)
12 elseifKind(u)=”+” then
13 f:=Linear
 form(Operand(u,1),x);
14 iff=Fail then
15 Return(Fail)
16 else
17 r:=Linear
 form(u−Operand(u,1),x);
18 ifr=Fail then
19 Return(Fail)
20 else
21 Return([Operand(f,1)+Operand(r,1),
Operand(f,2)+Operand(r,2)])
22 elseifFree
of(u,x)then
23Return([0,u])
24 else
25Return(Fail)
End
Figure 5.7. An MPL procedure that determines if uis a linear expression in x.
(Implementation: Maple(txt),Mathematica (txt),MuPAD(txt).)
182 5. Recursive Algorithms
Transformation Rule Sequences, the Derivative Operator
In this example we describe an algorithm that computes the derivative of
a function. Since the diﬀerentiation rules for sums, products, powers, and
composite functions obtain the derivative of an expression in terms of thederivatives of its operands, the algorithm is recursive.
For this example, we describe the algorithm using a transformation
rule sequence rather than an MPL procedure. The description is somewhat
simpler in this format, and the transformation rules can be easily trans-
lated into an MPL procedure. In addition, some CAS languages have the
capability to implement transformation rules directly as a program.
Letube an algebraic expression and let xbe a symbol. The operator
Derivative (u,x), which evaluates the derivative of uwith respect to x,i s
deﬁned by the following transformation rules:
DERIV-1. Ifu=x,t h e n Derivative (u,x)→1.
DERIV-2. Ifu=v
w,t h e n
Derivative (u,x)→ (5.8)
w∗vw−1∗Derivative (v,x)+Derivative (w,x)∗vw∗ln(v).
This rule applies to expressions that are powers and accounts for expres-
sions where either vorwmay depend on x. ( T h er u l ei sd e r i v e du s i n g
logarithmic diﬀerentiation (Exercise 12).) Since the Derivative operator
appears on the right side of the rule, DERIV-2 is recursive. When wis free
ofx, the rule reduces (with automatic simpliﬁcation) to the familiar power
rule
d(vw)
dx=w·vw−1d(v)
dx.
DERIV-3. Supposeuis a sum and let v=Operand (u,1) andw=u−v.
Then
Derivative (u,x)→Derivative (v,x)+Derivative (w,x).
DERIV-4. Supposeuis a product and let v=Operand (u,1) andw=
u/v.T h e n
Derivative (u,x)→Derivative (v,x)∗w+v∗Derivative (w,x).
Rules DERIV-3 and DERIV-4 are the sum and product diﬀerentiation
rules. Again, the rules are recursive because the right side of each rule
refers to the Derivative operator. Notice that we obtain the derivative of
5.2. Recursive Procedures 183
a sum by diﬀerentiating both the ﬁrst operand and the remaining part of
the sum, which is obtained by subtracting the ﬁrst operand from uwith
automatic simpliﬁcation. A similar approach is used for a product.
A typical rule for a known function looks like the following:
DERIV-5. Ifu=s i n (v), then Derivative (u,x)→cos(v)∗Derivative (v,x).
Again, the chain rule implies the rule is recursive.DERIV-6. IfFree
of(u,x)=true,t h e n Derivative (u,x)→0.
This rule applies to integers, fractions, symbols, and compound expressions
(such asf(a)o rn!) that are free of the diﬀerentiation variable x.N o t i c e
that powers, sums, and products are not checked by this rule because they
are handled by one of the earlier rules DERIV-2, DERIV-3, or DERIV-4.For example, if bandeare symbols ( /negationslash=x), then
Derivative (b
e,x)→0
is obtained by ﬁrst applying DERIV-2, which applies DERIV-6 (recur-
sively) to both bande.
We have placed DERIV-6 at this point in the rule sequence to avoid
redundant calls on the Free
ofoperator. The reason for this has to do
with the recursive nature of Free
of. If DERIV-6 were at the beginning
of the rule sequence, then to compute the derivative (with respect to x)o f
u=( 1+a)2+x2,
the algorithm would ﬁrst check if uwere free of x, which involves the
comparison of each complete sub-expression of utoxuntil the symbol x
is found. Since this step would return false, we would next apply the sum
rule which obtains the derivative in terms of the derivatives of the two
operands (1 + a)2andx2. To ﬁnd the derivative of (1 + a)2,w ew o u l d
check (for the second time) if this expression were free of x.B y p l a c i n g
theFree
ofoperation later in the rule sequence, we avoid this redundant
calculation.
The ﬁnal transformation rule applies to any expression that is not cov-
ered by the earlier rules:
DERIV-7. Derivative (u,x)→”Derivative ”(u,x).
In other words, if none of the earlier rules apply to u, the expression is re-
turned in the unevaluated form Derivative (u,x). The Derivative operator
on the right is quoted to prevent a recursive evaluation of the operator be-
cause, without the quotes, the transformation leads to an inﬁnite sequence
184 5. Recursive Algorithms
of recursions. By including this rule, we obtain a representation for the
derivative of expressions that include undeﬁned functions such as
Derivative (f(x)∗g(x),x)→Derivative (f(x),x)∗g(x) (5.9)
+f(x)∗Derivative (g(x),x),
where the derivatives of f(x)a n dg(x) remain in unevaluated form. (See
Exercise 13(c) for an extension of this situation.)
Notice that the diﬀerentiation quotient rule is not included in our rule
sequence because we assume that automatic simpliﬁcation transforms quo-
tients to products or powers. In some instances, however, the quotient rule
returns the derivative of a quotient in a more useful form. Since it is notdiﬃcult to check when a product is a quotient, this is a useful extension of
the algorithm (Exercise 13(b)).
The DERIV rules are an example of a transformation rule sequence.
When describing an algorithm in this way, we assume that a rule is checked
only when all earlier rules do not apply. This approach simpliﬁes the pre-sentation because conditions that are handled by earlier rules need not be
repeated (in a negative sense) in a later rule.
It is a simple matter to express the DERIV rule sequence as an MPL
procedure. We leave the details of the procedure to the reader (Exercise 13).
Rule-Based Programming
Some CAS languages have the capability to implement a transformation
rule sequence directly.
Mathematica. Figure 5.8shows an implementation of the DERIV rules in
the Mathematica pattern matching language. Since Derivative is a pre-
deﬁned operator in this system, we have used the name Deriv instead.
Deriv[x_, x_ ] := 1;
Deriv[ v_^w_, x_] := w*v^(w-1)*Deriv[v,x] + Deriv[w,x]*v^w*Log[v];
Deriv[ u_ + v_, x_ ] := Deriv[u,x] + Deriv[v,x];Deriv[ u_ * v_, x_ ] := Deriv[u,x]*v + Deriv[v,x]*u;
Deriv[Sin[u_], x_ ] := Cos[u]*Deriv[u,x];
Deriv[u_,x_] := 0 /; FreeQ[u,x] === True;
Figure 5.8. Arule-basedprogramforthe Derivative operatorintheMathematica
pattern matching language. Since Derivative is a predeﬁned operator in the
Mathematica language, we have used the name Derivinstead. (Implementation:
Mathematica (nb).)
5.2. Recursive Procedures 185
In Mathematica, an underscore character (
 ) after a variable name
means the variable can stand for an arbitrary expression. The symbol
/;(in the last line) stands for the word “whenever,” and so the free of
condition following this symbol must hold for the rule to apply. Mathe-matica keeps re-applying the rules to an expression until changes do not
occur. For this reason, even though the sum and product rules are listed
with only two operands, the operator can diﬀerentiate sums or productswith more than two operands as well. Notice that we have omitted the
last rule DERIV-7 because if udoes not satisfy one of the input patterns,
Mathematica returns the operator in the unevaluated form Deriv[u,x] .
Once the transformation rules have been entered in a Mathematica
session, they are applied during evaluation whenever the Deriv operator
appears in an expression. In Mathematica, the execution order for rules
does not depend on the order in which they are listed. Rather, the system
applies more speciﬁc rules before it applies more general rules. For thisexample, however, the rule that involves the FreeQ operator is checked
after the other rules.
Maple. Figure 5.9shows an implementation of the DERIV rules in the
Maple pattern matching language. Notice that each symbol ( x,u,v,a n d
w) is followed by two colons ( ::) and one of the designations
name,algebraic ,nonunit(algebraic)
which deﬁnes the class of expressions that can replace the variable. The
form nonunit(algebraic) is included so that an expression is not matched
define(Derivative,
Derivative(x::name,x::name)=1,
Derivative(v::nonunit(algebraic)^w::nonunit(algebraic),x::name)
=w*v^(w-1)*Derivative(v,x)+Derivative(w,x)*v^w*ln(v),
Derivative(u::nonunit(algebraic)+v::nonunit(algebraic),x::name)
=Derivative(u,x)+Derivative(v,x),
Derivative(u::nonunit(algebraic)*v::nonunit(algebraic),x::name)
=Derivative(u,x)*v+Derivative(v,x)*u,
Derivative(sin(u::algebraic),x::name)=cos(u)*Derivative(u,x),
conditional(Derivative(u::algebraic,x::name)
=0,_type(u,freeof(x)))
);
Figure 5.9. A rule-based program for the Derivative operator in the Maple
pattern-matching language. (Implementation: Maple(mws).)
186 5. Recursive Algorithms
by an inappropriate rule. For example, this form is included in the product
rule so that the Maple’s pattern matching algorithm does not consider the
expression sin( x) to be a product 1 ∗sin(x). (Without this designation, the
execution of Derivative (sin(x),x) results in an inﬁnite recursive loop.)
The nonunit designation also permits sums and products in rules 3 and 4
to have more than two operands. The conditional statement in the last
rule implements the Free
oftest in DERIV-6 .N o t i c et h a t DERIV-7 is not
needed because when udoes not match any of the rules, Derivative (u,x)
is returned in unevaluated form.
In Maple, the transformation rules are checked in the order they are
listed, and once the rules have been entered in a session, the system createsa recursive procedure with the name Derivative .
Rule-based programming usually gives smaller programs because much
of the program logic is handled by the CAS’s pattern matching program.
On the other hand, because program logic is handled by the system, we give
up some control of the process. In addition, the approach requires a goodunderstanding of the workings (and limitations) of the pattern matching
program, and, in some cases, it can be diﬃcult (or even impossible) to
express a transformation in the required form.
TheTrig
 substitute Operator
Letube an algebraic expression. The operator Trig
substitute (u)f o r m sa
new expression, with all instances of the functions tan, cot, sec, and csc in
ureplaced by the equivalent representations in terms of sin and cos.
The operator utilizes the four transformation rules:
TRIGSUB-1. tan(v)→sin(v)
cos(v).
TRIGSUB-2. cot(v)→cos(v)
sin(v).
TRIGSUB-3. sec(v)→1
cos(v).
TRIGSUB-4. csc(v)→1
sin(v).
The easiest way to obtain these transformations is with the rule-based
operations that are available in some CAS languages. It is instructive,
however, to obtain the transformations with MPL procedures. We describe
two approaches, one based on the Construct operator described in Section
3.2and the other based on the Mapoperator described below.
5.2. Recursive Procedures 187
Procedure Trig
substitute (u);
Input
u:a nalgebraic expression ;
Output
a new expression, with all instances of the functions
tan, cot, sec, and csc replaced by the representationsusing sin and cos;
Local Variables
s,i,L;
Begin
1 ifKind(u)∈{integer ,fraction ,symbol }then
2Return(u)
3 else
4 L:= [ ];
5 fori:= 1toNumber
of
operands(u)do
6 L:=Join(L,[Trig
substitute (Operand(u,i))]);
7 ifKind(u)∈{tan,cot,sec,csc}then
8 s:=Operand(L,1);
9 ifKind(u)=ta n then
10 Return(sin(s)/cos(s));
11 ifKind(u)=c o t then
12 Return(cos(s)/sin(s));
13 ifKind(u)=s e c then
14 Return(1/cos(s));
15 ifKind(u)=c s c then
16 Return(1/sin(s))
17 else
18 Return(Construct (Kind(u),L))
End
Figure 5.10. An MPL procedure for Trig
substitute that uses the Construct
operator. (Implementation: Maple(txt),Mathematica (txt),MuPAD(txt).)
ATrig
substitute procedure2that uses the Construct operator is given
in Figure 5.10. Lines 1-2 provide a termination condition for the recursion.
In lines 4-6, we construct a list Lthat contains the expressions obtained
2This procedure will not work in the Mathematica system using this system’s trigono-
metric functions ( Sin[x], Cos[x], Tan[x], etc.) because the automatic simpliﬁcation
rules cancel the operations of the procedure. For example, in this system, automatic
simpliﬁcation obtains the inverse transformation replacing Sin[x]/Cos[x] with Tan[x] .
To implement the procedure, it is necessary to override the automatic simpliﬁcationrules by using diﬀerent names for these functions. One possibility is to use functionnames that begin with lower case characters. (Implementation: Mathematica (nb).)
188 5. Recursive Algorithms
by applying Trig
substitute to each operand of u. Lines 7-16 apply the
TRIGSUB transformations where, for these cases, the operand list Lhas
only one operand. For all other compound expressions, we construct (line
18) a new expression using the same main operator as uand the operands
ofL.
For expressions whose main operator is an algebraic operator (+, ∗,∧,
or !), it is not necessary to use the Construct operator and the iteration
structure in lines 5-6. For example, for sums we obtain the same result by
returning the expression
Trig
substitute (Operand (u,1)) + Trig
substitute (u−Operand (u,1)).
However, we have used the Construct operator because each operator re-
quires its own statement similar to this one. In addition, we must use
Construct for function forms (such as f(tan(x),sec(x)+1 ) )t h a tc a nh a v e
an arbitrary number of operands but don’t satisfy an algebraic relation.
TheMap Operator
A basic operation in the Trig
substitute procedure is the creation of a
new expression with the same main operator as uand operands that are
obtained by recursively applying the procedure to each operand of u.S i n c e
this operation occurs frequently in computer algebra, it is useful to have anMPL primitive operator that performs the operation. The Mapoperator
serves this purpose.
Definition 5.1. Letube a compound expression with
n=Number
of
operands (u),
and letF(x)andG(x,y,...,z )be operators. The Map operator has two
forms:
Map(F,u), (5.10)
Map(G,u,y,...,z ). (5.11)
The statement Map (F,u)obtains the new expression with main operator
Kind(u)and operands
F(Operand (u,1)),F(Operand (u,2)),...,F (Operand (u,n)).
The statement Map (G,u,y,...,z )obtains the new expression with main
operator Kind(u)and operands
G(Operand (u,1),y,...,z ),G(Operand (u,2),y,...,z ),...,
G(Operand (u,n),y,...,z ).
5.2. Recursive Procedures 189
MPL
 Maple
 Mathematica
 MuPAD
Map(F,
 Map(F,a+b)
 Map[F,a+b]
 Map(a+b,F)
a+b)
Map(G,
 Map(G,a+b,d,e)
 Map[G[#,d,e]&,a+b]
 Map(a+b,G,d,e)
a+b,d,e)
Figure 5.11. Thesyntaxof Mapoperators inMaple, MuPAD,andMathematica.
(Implementation: Maple(mws),Mathematica (nb),MuPAD(mnb).)
Ifuis not a compound expression, the Map operator returns the global
symbolUndeﬁned .
Example 5.2. For the operator
F(x)function:=x2,
we have
Map(F,a+b)→a2+b2.
For the operator
G(x,y,z)function:=x2+y3+z4,
we have
Map(G,a+b,c,d)→G(a,c,d)+G(b,c,d)
=/parenleftbig
a2+c3+d4/parenrightbig
+/parenleftbig
b2+c3+d4/parenrightbig
=a2+b2+2c3+2d4. /square
Most CAS languages have some form of the Mapoperator (Figure 5.11).
A procedure3for trigonometric substitution that uses the Mapoperator
is given in Figure 5.12.
Computation of Legendre Polynomials
This example provides another simple example of the mechanics of recur-
sion and reveals one of its limitations.
The Legendre polynomials are the sequence of polynomials pn(x),n=
0,1,2,...that are deﬁned by the relations
p0(x)=1, (5.12)
p1(x)=x, (5.13)
pn(x)=1
n((2n−1)xpn−1(x)−(n−1)pn−2(x)),n≥2.(5.14)
3Mathematica users see footnote 2on page 187.
190 5. Recursive Algorithms
Procedure Trig
substitute
map(u);
Input
u:a nalgebraic expression ;
Output
a new expressions where all instances of the functions
tan, cot, sec, and csc are replaced by the representationsusing sin and cos;
Local Variables
U;
Begin
1 ifKind(u)∈{integer ,fraction ,symbol }then
2Return(u)
3 else
4 U:=Map(Trig
substitute
map,u);
5 ifKind(U)=ta n then
6 Return(sin(Operand(U,1))/cos(Operand(U,1)));
7 ifKind(U)=c o t then
8 Return(cos(Operand(U,1))/sin(Operand(U,1)));
9 ifKind(U)=s e c then
10 Return(1/cos(Operand(U,1)));
11 ifKind(U)=c s c then
12 Return(1/sin(Operand(U,1)))
13 else
14 Return(U)
End
Figure 5.12. AnMPLprocedurefortrigonometricsubstitutionthatusesthe Map
operator. (Implementation: Maple(txt),Mathematica (txt),MuPAD(txt).)
The polynomials are named in honor of the French mathematician Adrien-
Marie Legendre (1752-1833), who ﬁrst used them in 1785 to study thegravitational attraction of solids of revolution. Today they have applica-
tions in numerical integration, the solution of diﬀerential equations, and
engineering.
The expression for p
n(x) is called a recurrence relation because for n≥
2,pn(x) is deﬁned in terms of the lower order polynomials pn−1(x)a n d
pn−2(x). The polynomials p0andp1serve as termination conditions for
the recursion. Using this deﬁnition, each succeeding polynomial ( n≥2) is
computed as follows:
p2(x)=1
2((2(2) −1)xp1(x)−(2−1)p0(x)) =3
2x2−1
2,
5.2. Recursive Procedures 191
p3(x)=1
3((2(3) −1)xp2(x)−(3−1)p1(x)=5
2x3−3
2x,
...
etc.
A recursive procedure for pn(x) is given in Figure 5.13. Lines 6-7 contain
recursive calls of the procedure, and line 8 contains an Algebraic
 expand
operator so that the polynomial is returned in expanded form.
Unfortunately, the Legendre procedure performs an excessive amount
of redundant calculation that makes it unsuitable for large values of n.A
trace of the recursive calls for Legendre (4,x) indicates why this is so (see
Figure 5.14). To compute Legendre (4,x), the procedure must compute re-
cursively Legendre (3,x)a n d Legendre (2,x). Observe that all recursive cal-
culations for Legendre (3,x) are done before any of the calculations for this
version of Legendre (2,x). In addition, to compute Legendre (3,x), the pro-
cedure must compute another version of Legendre (2,x)a n d Legendre (1,x).
The computation continues in this fashion until it encounters one of the
terminating conditions n=0o rn= 1. The cause of the redundant cal-
culations is apparent from the sequence of procedure calls shown in Fig-
Procedure Legendre(n,x);
Input
n: a non-negative integer;
x:as y m b o l ;
Output
pn(x);
Local Variables
f,g;
Begin
1 ifn=0then
2Return(1)
3 elseif n=1then
4Return(x)
5 else
6 f:=Legendre(n−1,x);
7 g:=Legendre(n−2,x);
8Return(Algebraic
expand((1/n)∗((2∗n−1)∗x∗f−(n−1)∗g)))
End
Figure 5.13. Computation of Legendre polynomials using recursion. (Implemen-
tation:Maple(txt),Mathematica (txt),MuPAD(txt).)
192 5. Recursive Algorithms
n=1 n=0 n=1n=2
n=1 n=0n=2n=3n=4Interactive Mode
Figure 5.14. The sequence of recursive calls for Legendre(4,x). An arrow that
points downward on a solid line represents a recursive call, and those that point
upward on a dashed line represent a return to the calling procedure.
ure5.14. Observe that there are two calls on Legendre (2,x), three calls
onLegendre (1,x), and two calls on Legendre (0,x). In each instance, the
procedure is not aware that the value is computed more than once. In gen-
eral, the number of recursive calls on the procedure increases exponentiallywithn.
For this computation, it is a simple matter to avoid the redundant cal-
culation by avoiding recursion altogether and using an iterative procedure.This is done by replacing lines 6-8 in Figure 5.13by the iteration:
f:= 1;
g:=x;
fori:= 2tondo
p:= (1/i)∗((2∗i−1)∗x∗g−(i−1)∗f;
f:=g;
g:=p;
Return (Algebraic
expand (p));
After executing the loop, pn(x) is contained in the variable p,w h i c hi s
then expanded in the last line. Although the iterative version is based on
the recurrence relation in Equation ( 5.14), it is not considered a recursive
algorithm because it does not call itself directly or indirectly.
5.2. Recursive Procedures 193
Legendre_remember := proc(x,n)
local f,g;
option remember;if n = 0 then
RETURN(1)
elif n = 1 then
RETURN(x)
else
f := Legendre_remember(x,n-1);g := Legendre_remember(x,n-2);
RETURN(expand((1/n)*((2*n-1)*x*f - (n-1)*g)))
fiend:
Figure 5.15. Computing Legendre polynomials with Maple using the option
remember . The option is also available in Mathematica and MuPAD. (Imple-
mentation: Maple(txt),Mathematica (txt),MuPAD(txt).)
Since the potential for redundant calculations occurs frequently in com-
puter algebra, it is useful to have a way to perform a calculation in a recur-
sive manner that avoids the redundant calculation. For example, the Maple
language has a feature called option remember that makes this possible (see
Figure 5.15). When this option is declared within a Maple procedure, the
system keeps a table of input/output expressions for all calls on the proce-dure. When the procedure is invoked, a check is made to see if the current
input is identical to the input of a previous procedure call. When this is so,
the output is returned from the value in the table. If the input expressionis not in the table, the output is calculated in the usual way and the new
input/output pair is stored in the table. Both Mathematica and MuPAD
also have remember options for procedures.
For the computation of Legendre polynomials, the remember option dra-
matically reduces the redundant calculation. In many situations, however,
redundant calculations can be eliminated by either avoiding recursion or by
modifying the algorithm. For example, we avoided redundant calculationswith the Derivative operator by placing the Free
ofoperation at the end of
the transformation sequence (see page 183). For this reason, the remember
feature is not used by any of the algorithms this book.
Recursive Chains
The procedures described so far are recursive because each procedure is
deﬁned directly in terms of another version of the same procedure. Recur-
194 5. Recursive Algorithms
sion may also come about indirectly. For example, suppose a procedure
u1does not call on itself directly, but calls on another procedure u2which
then calls on u1.In t h i s c a s e , u1is considered recursive because it calls
on itself indirectly through the intervening procedure u2.A ne x a m p l eo fa
recursive chain is given in the case study in Section 5.3.
Exercises
1. (a) Trace the ﬂow of the computation in response to the statement
Free
of(a(x+1)+3cos( y),x).
(b) Modify the Free
of(u, t)o p e r a t o rs ot h a ti tr e t ur n s falsewhen u
contains a target tthat is an algebraic operator or function name.
For example,
Free
of(f(x)+y, f)→false,
Free
of(y+z,”+”) →false.
(c) Give a procedure Set
free
of(u,S)t h a td e t e r m i n e si f uis free of all
expressions in a set (or list) S.T h eSet
free
ofoperator is used in
theMonomial
gpeprocedure in Figure 6.5on page227.
2. Give a procedure
Trig
free
of(u)
that returns thesymbol trueif analgebraic expression uis free of trigono-
metric functions (sin ,cos,tan,cot,sec,csc) and the symbol falseother-
wise.
3. Let ube amathematical expression . Give a procedure Symbols(u)t h a t
returns the set of symbols in u.
4. Give a procedure
Contain
parameters (u,x)
that returns trueif thealgebraic expression ucontains any symbols other
than the symbol xandfalseotherwise.
5. Let ube amathematical expression . Give a procedure
Algebraic
expression (u)
that returns trueifuis analgebraic expression andfalseif it is not
algebraic. (See Deﬁnition 3.17on page93.)
6. Let ube a polynomial in xwith rational number coeﬃcients. An eﬃcient
way to evaluate a polynomial numerically is to rewrite the polynomial ina nested form by introducing extra parenthesis. For example,
u=2x
3+3x2+4x+6=((2 x+3)x+4)x+6.
5.2. Recursive Procedures 195
In numerical methods texts, this method for evaluating a polynomial is
called Horner’s method (see Epperson [ 35]). Give a recursive procedure
Horner(u,x) that transforms a polynomial from the expanded form to the
nested form.
7. Anumerical expression uis one that is deﬁned by the rule sequence:
NUM-1. uis an integer or a fraction.
NUM-2. uis one of the symbols πore.
NUM-3. uis a compound expression with main operator +, ∗,∧,o ra
functionname(sin, f, etc.) suchthateachoperandof uisanumerical
expression.
For example, the following are numerical expressions
2+21/2,sin(3),f(3),2·π1/3,3+e.
Giveaprocedure Numerical (u)thatreturns trueifanalgebraic expression
uis a numerical expression and otherwise returns false.
8. Let ube analgebraic expression and let xbe a symbol. Give a procedure
Quadratic
form(u,x)t h a td e t e r m i n e si f uhas theform ax2+bx+cwhere
a,b,a n dcare free of x.I fuhas the proper form return [ a,b,c], otherwise
return Fail. Interpret this form in a broad sense to include more involved
sums (e.g., ax2+2x2+bx+3x+4 )a sw e l la se x p r e s s i o n st h a ta r en o t
sums (e.g., x2,2x,x/a,ab, and 3). The point of this exercise is to imple-
ment the procedure in terms of primitive operators ( Kind,Operand,e t c . )
and structure-based operators ( Free
of), and not in terms of polynomial
operators (Degree,Coeﬃcient ).
9. Let ube analgebraic expression . Deﬁne the tree-sizeofuas the num-
ber of symbols, integers, algebraic operators, and function names that oc-cur in u. For example, the expression ( x+s i n ( x)+2 ) ∗x
3consists of
x,+,sin,x,2,∗,x,∧,and 3 and so has a tree-size of 9. Give a procedure
Tree
size(u) that obtains the tree-size of u.
10. Give procedures for each of the following operators. In each case the pro-
cedures should be deﬁned in terms of the primitive operators as was done
in the text with the Trig
substitute andTrig
substitute
mapoperators.
(a) Let ube amathematical expression andvan equation. Give a pro-
cedure for the operator Substitute (u,v) that performs structural sub-
stitution. (See Deﬁnition 3.30on page111.)
(b) Let ube amathematical expression andLa list of equations. Give
a procedureSequential
substitute (u,L) that performs sequential sub-
stitution. (See Deﬁnition 3.31on page114.)
(c) Let ube amathematical expression andSa set of equations. Give a
procedureConcurrent
substitute (u,S) that performs concurrent sub-
stitution. (See Deﬁnition 3.34on page115.)
196 5. Recursive Algorithms
11. (a) Let Sbe a set of mathematical expressions and let kbe an integer
with 0 ≤k≤Number
of
operands(S). Give a procedure Comb(S,k)
that returns the set of all kelement subsets of S. For example, if
S={a,b,c,d },t h e n
Comb(S,2)→{ {a,b},{a,c},{a,d},{b,c},{b,d},{c, d}}.
The procedure can be deﬁned by the following recursive transforma-
tion rule sequence.
i. Ifk=Number
of
operands(S), thenComb(S,k)→{S}.
ii.Comb(S,0)→ {∅}.
iii. Let x=Operand(S,1),T=S∼{x},a n dD=Comb(T,k−1).
ForD={S1,...,S n},l e tE={S1∪{x},...,S n∪{x}}.T h e n
Comb(S,k)→Comb(T,k)∪E.
(b) Thepowerset ofaset Sisthesetofallsubsetsof S. Giveaprocedure
Power
set(S) that obtains the power set of a set S.
12. Derivethegeneraldiﬀerentiationpowerrulein DERIV-2.Hint:Lety=vw
and take logs of both sides of the expression.
13. Let ube analgebraic expression ,a n dl e t xbe a symbol.
(a) Give a procedure Derivative (u,x) that utilizes the DERIVrules de-
s c r i b e di nt h i ss e c t i o n .
(b) Although quotients are represented as powers or products, it is pos-
sible to recognize when an expression is a quotient and apply the
quotient rule instead of the product rule. Modify the Derivative pro-
cedure so that it recognizes when an expression is a quotient and,when this is so, applies the quotient rule.
(c) Although the DERIVtransformation rules allow for the diﬀerenti-
ation of some expressions with undeﬁned functions (see Statement(5.9)), the rules don’t handle expressions with compositions of un-
deﬁned functions such as f(g(x)) orh(x,g(x)) in an adequate way.
For these expressions the Derivative operator is returned in unevalu-
ated forminstead ofwitharepresentation thatutilizes thechainrule.Somecomputeralgebrasystemsgiverepresentationsofderivativesfor
these expressions that utilize the chain rule. Experiment with a CAS
to see how derivatives of these expressions are handled, and modifytheDerivative procedure to handle these derivatives.
(d) The DERIVtransformation rules provide for the diﬀerentiation of
anyalgebraic expression includingfactorials. (Accordingtotherules,Derivative (x!,x) is now returned in unevaluated form.) Although x!
is deﬁned only when xis a non-negative integer, there is a general-
ization of the factorial operation that involves the gamma function
5.2. Recursive Procedures 197
(Γ(x+1)= x!) where xisnolonger restricted in thisway4.W i t ht h i s
generalization, we can deﬁne transformation rules for the diﬀerentia-
tion of factorial expressions. Experiment with a CAS to see how the
diﬀerentiation operator handles factorials, and modify the Derivative
procedure to handle these expressions.
14. Let ube an equation with both sides of theequation algebraic expressions ,
xandyare symbols, and nis a non-negative integer. Give a recursive
procedure
Implicit
derivative (u,y,x,n)
that obtains the nth derivative of ywith respect to x.I f n = 0 , r e t ur n
u. Use either the diﬀerentiation operator in a CAS or the Derivative op-
erator in Exercise 13to perform the diﬀerentiations. (If a CAS has the
capability to perform implicit diﬀerentiation, do not use this capability.)
Assume that yis represented in the equation in function notation y(x)
and thatFree
of(u,y(x)) isfalse. Do not use an iteration structure in this
procedure. For example,
Implicit
derivative (x2+y(x)2=1,y ,x ,3)→−3xi
x2+y(x)2J
y(x)5.
15. Let ube analgebraic expression ,a n dl e t xandybe symbols. Give a
procedure
Derivative
order(u,x,y)
that determines the maximum order of the derivatives of ywith respect
toxinu. In this exercise d(y,x) represents the ﬁrst derivative and for
an integer n≥2,d(y,x,n) represents the derivative of order n.( W eus e
thisrepresentationratherthanarepresentationsuchas Derivative (y(x),x)
to conform with the presentation in Section 4.3.) In addition, the order
of the symbol yis 0, and the order of expressions without a yis−1.
To simplify matters, if ucontains function forms with the name dthat
contain operands diﬀerent from those in d(y,x)a n d d(y,x,n), return the
global symbol Undeﬁned . For example,
Derivative
order(d(y,x,2)+xd(y,x)+4y, x, y)→2,
Derivative
order(x+y, x, y)→1,
Derivative
order(x, x, y)→−1,
Derivative
order(d(y2,x),x ,y)→Undeﬁned ,
Derivative
order(d(y,b),x ,y)→Undeﬁned .
Note in the last two examples, the symbol Undeﬁned is returned because
the operands of the function form dare inappropriate.
TheDerivative
orderoperator is used in Exercise 14on page240.
4See Spanier and Oldham [ 92], Chapter 43 for a description of the gamma function
and its derivative.
198 5. Recursive Algorithms
16. (a) Let Sbe a set of rational numbers. Give a procedure Max(S)t h a t
returns the maximum value in S.I fSis empty, return the global
symbol Undeﬁned .
(b) Supposenowthat Sisaﬁnitesetof algebraic expressions . Generalize
the procedure Maxso that it determines the maximum value of the
expressions in Sthat can be compared. For the purposes of this
exercise two expressions fandgarecomparable iff−gis an integer
or fraction, and f>gwhenf−g>0 in automatic simpliﬁcation.
If all the expressions in Sare pairwise comparable, then return the
maximumexpression. Iftwoormoreexpressionscannotbecompared,then return an unevaluated form of Max. For example,
Max({a,2,3})→Max({a,3}),
Max({m,m+1})→m+1,
Max({3,Max({2,x}),})→Max(3,x),
Max({−5,m,m+1,2,3,√
2})→Max({3,m+1,√
2}).
Note that in the last example 3 and√
2 cannot be compared because
3−√
2 is not an integer or fraction in automatic simpliﬁcation.
This procedure returns a reasonable result as long as the input data
is appropriate. For example, if some of the expressions in Sare
complex number expressions, then the input is not appropriate (e.g.,
S={2,√
−1}).
TheMaxoperator is used in Exercise 17below and Exercise 13, page239.
17. Let ube analgebraic expression andxas y m b o l .G i v eap r o c e d ur e
Max
exponent(u,x)
that returns the largest exponent of xinu. If some exponents of xare not
integers or fractions, return an unevaluated Maxfunction as described in
Exercise16. For example,
Max
exponent(x2+x3,x)→3,
Max
exponent(x+x−1,x)→1,
Max
exponent(sin(x2+xm,x)→Max({2,m}),
Max
exponent(x(x2),x)→Max({2,x2}).
18. The absolute value function satisﬁes the following four properties:
(a)|a·b|→|a|·|b|.
(b) For nan integer, |an|→|a|n.
(c) For ı=√
−1,|ı|→1.
(d) If an expression has the form a+ıb,w h e r e a/negationslash=0a n d b/negationslash=0a r ef r e e
ofı,t h e n |a+bı|→(a2+b2)1/2.
5.3. Case Study: Elementary Integration Operator 199
Letubeanalgebraic expression . Give a procedure Absolute
value(u)t h a t
obtains the absolute value of integers and fractions and applies the above
rules when uis not an integer or fraction. If uis not an integer or fraction
or one the above forms, return the unevaluated form ” Absolute
value”(u).
For example,
Absolute
value(−1/2)→1/2,
Absolute
value(−2x)→2Absolute
value(x),
Absolute
value(x+y)→Absolute
value(x+y),
Absolute
value(x+2ı)→(x2+4)1/2.
This procedure returns a reasonable result as long as the input data is
appropriate. Forexample,sincetheproceduredoesnotperformananalysis
of involved expressions with radicals, it may return an inappropriate resultsuch as
Absolute
value~
1−6
2−√
5+ı^
→
2−6
2−√
5,
which is a complex number.
5.3 Case Study: An Elementary Indefinite Integration
Operator
In this case study we describe an algorithm that evaluates/integraltext
f(x)dxfor
a limited class of functions encountered in elementary calculus. The algo-
rithm utilizes the following:
1. an integration table,
2. the linear properties of the indeﬁnite integral,3. the “substitution” or “change of variable” method that is based on
the inversion of the chain rule, and
4. both expanded and unexpanded forms of the integrand f(x).
For example, the algorithm can evaluate the integrals
/integraldisplay
5xsin/parenleftbig
x
2/parenrightbig
cos/parenleftbig
x2/parenrightbig
dx,/integraldisplay
(cos(x)+2 )( s i n ( x)+3 )dx.
200 5. Recursive Algorithms
The Integration Table
The integration table includes the following standard elementary forms.
1. Expressions that are free of the integration variable x.
2. Powers xn,w h e r enis free of the integration variable x.S i n c em o s t
computer algebra systems return/integraltext
x−1dx=l n (x) (rather than the
more general form ln |x|), we include this form in the table.
3. The functions exp( x)a n dl n (x)a n dt h ep o w e r bx,w h e r ebis free of
the integration variable x.
4. The trigonometric functions.5. More involved expressions that occur as derivatives of the trigonomet-
ric functions or their inverses. For example, sec( x)tan(x)a p p e a r si n
the table because it is the derivative of sec( x).
Linear Properties
When the integrand is a product f(x)=cg(x)w i t hcfree ofx, the algo-
rithm applies the linear property
/integraldisplay
fd x=/integraldisplay
cgdx =c/integraldisplay
gd x (5.15)
and then evaluates recursively/integraltext
gd x. In some cases when the substitution
method is used to evaluate an integral, this step may seem counterproduc-
tive (see Equations ( 5.19)-(5.21) below). It is required, however, to match
expressions in the integration table, and its application does not hinder the
substitution method algorithm (see Example 5.4below).
Whenfis a sum, the algorithm applies the linear property
/integraldisplay
fd x=/integraldisplay n/summationdisplay
i=1fidx=n/summationdisplay
i=1/integraldisplay
fidx (5.16)
and then evaluates recursively each/integraltext
fidx.
The Substitution Method
The substitution method is a basic technique for evaluating integrals that
most readers are undoubtedly familiar with from the study of calculus. The
method depends on the inversion of the chain rule
/integraldisplay
u(v(x))v/prime(x)dx=/integraldisplay
u(v)dv=U(v(x)), (5.17)
5.3. Case Study: Elementary Integration Operator 201
whereU/prime(v)=u(v). It has the potential to obtain an anti-derivative when-
ever the integrand is a product of the form
f=u(v(x))v/prime(x). (5.18)
Once such a representation is chosen, the success of the method depends
on the evaluation of the new integral/integraltext
u(v)dv.For example, to evaluate
/integraldisplay
2xcos/parenleftbig
x2/parenrightbig
dx, (5.19)
let
v(x)=x2,u(v)=c o s (v). (5.20)
Sincev/prime=2x,
/integraldisplay
2xcos/parenleftbig
x2/parenrightbig
dx=/integraldisplay
cos(v)dv=s i n (v)=s i n/parenleftbig
x2/parenrightbig
. (5.21)
Notice that we have omitted the arbitrary constant of integration as is done
in most CAS software as well as the procedures in this section.
Although this example illustrates a general approach, the technique is
more involved in practice. The diﬃculty involves deciding how to choose
a substitution that eliminates the original integration variable x.Ins o m e
instances it is possible to represent the integrand in the form ( 5.18)i n
a number of ways and in others it may not be possible at all. For ouralgorithm, we need a set of trial substitutions and a way to test if a sub-
stitution is appropriate. Figure 5.16shows some typical substitutions used
to evaluate integrals using this method.
These examples suggest four possible forms for the substitution v(x).
1.Function forms. In
/integraldisplay(x+1 )l n ( c o s ( ( x+1 )
2)) sin((x+1 )2)
cos((x+1 )2)dx, (5.22)
the expressions
ln(cos((x+1 )2)),sin((x+1 )2),cos((x+1 )2)
are function forms.
2.Arguments of function forms. In(5.22), the expressions
cos((x+1 )2),(x+1 )2
are arguments of function forms.
202 5. Recursive Algorithms
Integral
 Substitution

sin(x)cos(x)dx=sin2(x)
2
v=s i n(x)

2xcosi
x2J
dx=s i ni
x2J
v=x2

2xi
x2+4J5dx=i
x2+4J6/6
v=x2+4

cos(x)2sin(x)dx=2sin(x)
ln(2)
v=s i n(x)
Figure 5.16. Evaluation of integrals using the substitution method.
3.Bases of powers. In(5.22), the expressions
cos((x+1 )2),x+1
are bases of powers. The ﬁrst expression is a base because the de-
nominator of the integrand in ( 5.22) has the internal representation
(cos((x+1 )2))−1.
4.Exponents of powers. Inc o s (x)2sin(x), the expression sin( x)i sa n
exponent of a power. In ( 5.22),−1 and 2 are also exponents, but
don’t give useful substitutions.
Using these substitution forms, the trial substitutions for the integrand in
(5.22)a r e
ln(cos((x+1 )2)),cos((x+1 )2),(x+1 )2,
x+1,sin((x+1 )2),−1,2. (5.23)
The ﬁrst four expressions give substitutions that transform the integrand
to the form in ( 5.18), while the last three do not. For example, the ﬁrst
substitution
v=l n ( c o s ( ( x+1 )2)),
transforms the integral to a form that is easily evaluated
5.3. Case Study: Elementary Integration Operator 203
/integraldisplay(x+1 ) l n ( c o s( x+1 )2)s i n ( (x+1 )2)
cos((x+1 )2)dx
=−(1/2)/integraldisplay
vd v=(−1/4)v2=(−1/4)/parenleftbig
ln(cos((x+1 )2))/parenrightbig2.
Substitutions using the next three expressions in ( 5.23) also lead to simpler
integrals although each one requires at least one additional substitution forevaluation. For example, if the substitution is v(x)=c o s ( (x+1 )
2), then
/integraldisplay(x+1 )l n ( c o s ( ( x+1 )2)) sin((x+1 )2)
cos((x+1 )2)dx
=−(1/2)/integraldisplayln(v)
vdv,
where the last integral is evaluated with another substitution w=l n (v).
A procedure for the substitution method must perform the following
steps.
1. Form the set Pof possible substitutions that contains the function
forms, function arguments, and bases and exponents of powers in f.
2. Check each v(x)i nPto determine if it is an appropriate substitu-
tion. There are two expressions that may be in P, but which can
be eliminated immediately. They are v(x)=xwhich is really no
substitution at all, and the expressions v(x)t h a ta r ef r e eo f x.Iff
has the factored form
f=u(v(x))·v/prime(x)
for somev(x)i nP, the new integrand u(v) is obtained by eliminating
the factor v/prime(x)f r o mfand substituting a symbol vfor the expression
v(x). This operation is obtained by
u(v)=Substitute/parenleftbiggf
v/prime(x),v(x)=v/parenrightbigg
, (5.24)
where the division operation is obtained with automatic simpliﬁca-
tion. For the process to work, the substitution and division musteliminate the original integration variable xfrom the integrand. This
condition is veriﬁed by checking that u(v)i sf r e eo f x.Ift h i si ss o ,w e
complete the integration by evaluating recursively/integraltext
u(v)dv,a n db y
substituting v(x)f o rv. Because of the division in Expression ( 5.24),
the substitution method is also called the derivative divides method.
204 5. Recursive Algorithms
Example 5.3. Consider again
/integraldisplay
2xcos/parenleftbig
x2/parenrightbig
dx.
The possible substitutions are
P={x,2,x2,cos/parenleftbig
x2/parenrightbig
}. (5.25)
Since the ﬁrst two expressions xand 2 are not useful substitutions, the third
onev(x)=x2is tried. In this case Expression ( 5.24)g i v e su(v)=c o s (v),
which is free of x, and so the anti-derivative is obtained with
Substitute/parenleftbigg/integraldisplay
cos(v)dv, v=x2/parenrightbigg
→sin/parenleftbig
x2/parenrightbig
.
On the other hand, with the fourth expression v(x)=c o s/parenleftbig
x2/parenrightbig
inP,E x -
pression ( 5.24)g i v e s
u(v)=−cos(v)
sin(x2),
which is not free of xand so this substitution does not work. /square
Expanded versus Unexpanded Integrands
There are instances where expansion of the integrand is required for evalu-
ation and others where expansion leads to more a diﬃcult integration. For
example, to evaluate/integraldisplay
(x+1 )(x+2 )dx, (5.26)
it is necessary to expand the integrand. On the other hand, while the
unexpanded form/integraldisplay
(2x+1 )c o s/parenleftbig
x2+x/parenrightbig
dx (5.27)
is easily evaluated with the substitution v(x)=x2+x, by expanding and
applying the linear property ( 5.16), we obtain
/integraldisplay
(2x+1 )c o s/parenleftbig
x2+x/parenrightbig
dx=/integraldisplay
2xcos/parenleftbig
x2+x/parenrightbig
dx+/integraldisplay
cos/parenleftbig
x2+x/parenrightbig
dx,
where the two integrals on the right cannot be evaluated using the elemen-
tary functions encountered in calculus.
To handle both ( 5.26)a n d( 5.27), the algorithm ﬁrst tries to evaluate
an integral without expanding f, and if it is not successful, tries again after
expanding f.
5.3. Case Study: Elementary Integration Operator 205
The Integration Algorithm
TheIntegral procedure, which serves as a main procedure for the algo-
r i t h m ,i ss h o w ni nF i g u r e 5.17. The procedure returns either/integraltextfd xor the
global symbol Failif it is unable to evaluate the integral. It calls on three
procedures (lines 1, 3, and 5) that also return either an evaluated integral
or the symbol Fail. The statement at line 1 invokes the Integral
 tablepro-
cedure, which compares fto a number of standard forms and serves as a
termination condition for the recursion. The procedure Integral
 tableis left
to the reader (Exercise 3(a)).
Iffis not in the table, then at lines 2-3 the procedure Linear
 properties
determines if either Equation ( 5.15)o rE q u a t i o n( 5.16) can be applied, and,
if so, applies the appropriate rule. This procedure is recursive because
it calls on Integral to evaluate the new integrals produced by the linear
properties. The procedure Linear
 properties is left to the reader (Exercise
3(b)).
If this step fails, the Substitution
 method procedure is applied at line 5.
This step is recursive because this procedure also calls on Integral .Ift h i s
step fails, the integrand is expanded (at line 7), and if this produces a new
expression, the procedure Integral is applied recursively at line 9.
TheSubstitution
 method procedure is shown in Figure 5.17.N o t i c et h a t
the procedure uses a global mathematical symbol vto avoid using a lo-
cal variable that would be used without being assigned. At line 1, the
Trial
 substitutions procedure creates a set Pof possible substitutions (Ex-
ercise 3(c)). In lines 4-10, we check each candidate ginPas a possible
substitution. Once one is found, the loop terminates and the procedure
returns the evaluated integral. The procedure is recursive because it callsonIntegral at line 9, which allows another check of the integration table
and further application of the linear properties, substitution method, and
expansion, all of which may be needed (Exercise 1).
There are two ways that the Substitution
method procedure can fail
to obtain the integral: ﬁrst, when none of the possible substitutions in P
works, and next, when the free-of test at line 8 succeeds but the Integral
operator at line 9 is unable to evaluate the new integral. In either case, the
symbolFailis returned at line 11.
Example 5.4. Consider the evaluation of
/integraldisplay
2xcos/parenleftbig
x2/parenrightbig
dx.
Figure 5.18shows the sequence of procedure calls that indicates the path
taken by the algorithm to evaluate the integral. (There are other procedure
206 5. Recursive Algorithms
Procedure Integral(f,x);
Input
f:a nalgebraic expression ;
x:as y m b o l ;
Output	
fd xor the global symbol Fail;
Local Variables F,g;
Begin
1 F:=Integral
table(f,x);
2 ifF=Fail then
3 F:=Linear
properties (f,x);
4 ifF=Fail then
5 F:=Substitution
method(f,x);
6 ifF=Fail then
7 g:=Algebraic
expand(f);
8 iff/negationslash=gthen
9 F:=Integral(g,x);
10Return(F)
End
Procedure Substitution
 method(f,x);
Input
f:a nalgebraic expression ;
x:as y m b o l ;
Output	
fd xor the global symbol Fail;
Local Variables P,F,i,u,g ;
Global v;
Begin
1 P:=Trial
substitutions (f);
2 F:=Fail;
3 i:= 1;
4 while F=Fail and i≤Number
of
operands(P)do
5 g:=Operand(P,i);
6 ifg/negationslash=xand notFree
of(g,x)then
7 u:=Substitute (f/Derivative (g,x),g=v);
8 ifFree
of(u,x)then
9 F:=Substitute (Integral(u,v),v=g);
10 i:=i+1;
11Return(F)
End
Figure 5.17. The MPLIntegralandSubstitution
 methodprocedures. (Imple-
mentations: Maple(txt),Mathematica (txt),MuPAD(txt).)
5.3. Case Study: Elementary Integration Operator 207
Operator
 Integrand
 Integration
Variable
1
Integral
 2xcosi
x2J
x
2
Linear
properties
 2xcosi
x2J
x
3
Integral
 xcosi
x2J
x
4
Substitution
method
 xcosi
x2J
x
5
Integral
 (1/2) cos( v)
 v
6
Linear
properties
 (1/2) cos( v)
 v
7
Integral
 cos(v)
 v
8
Integral
table
 cos(v)
 v
Figure 5.18. The sequence of procedure calls that contribute to the evaluation
of	
2xcosi
x2J
dx.
calls that return Failand don’t contribute to the evaluation.) At step 1,
Integral calls on Linear
 properties (step 2) where the leading constant 2 is
removed. At step 3, Linear
 properties passes the new expression xcos/parenleftbig
x2/parenrightbig
toIntegral which, at step 4, calls on Substitution
 method .T h i ss t e pi n t r o -
duces a new leading constant 1/2 and passes a new integrand to Integral
(step 5). At step 6, the leading constant 1 /2 is removed by another call
toLinear
 properties which again passes a new integrand to Integral (step
7). Finally, at step 8, Integral calls on Integral
 tablewhich terminates the
recursion and returns sin( v). At this point the recursion unwinds to give
/integraldisplay
2xcos/parenleftbig
x2/parenrightbig
dx=s i n/parenleftbig
x2/parenrightbig
. /square
Appraisal of the Algorithm
The algorithm can evaluate many integrals that depend on the application
of the linear properties and the inversion of the chain rule, but cannot
evaluate all such integrals. For example, for the integral
/integraldisplay2x
x4+1dx=a r c t a n/parenleftbig
x2/parenrightbig
,
the set of possible substitutions obtained by the algorithm is
P=/braceleftbig
x4+1,−1,x,4/bracerightbig
.
Since this integral is evaluated using the substitution v=x2, which is not
inP, the integration is not obtained with the algorithm5.
5The reader wishing to explore substitutions of this type should consult Cohen [ 24],
Section 4.4, Exercise 10(d).
208 5. Recursive Algorithms
In other cases, although the substitution is in P, the algorithm cannot
evaluate the integral because of the form of the integrand. For example,
consider the integral/integraldisplaydx
exp(x)+e x p ( −x).
In this form the substitution set is
P={exp(x)+e x p ( −x),exp(x),exp(−x),x , −x}.
Although this integral can be evaluated with v(x)=e x p (x), this substitu-
tion will not work with the integrand in this form. However, by multiplyingthe numerator and denominator of the integrand by exp( x), we obtain
/integraldisplayexp(x)
(exp(x))2+1dx=a r c t a n ( e x p ( x)),
which is evaluated with the substitution v(x)=e x p (x). Since our algorithm
does not perform the transformation
1
exp(x)+e x p ( −x)→exp(x)
(exp(x))2+1,
it cannot evaluate the integral.
Some extensions of the algorithm are described in Exercises 4,6,8,
and9.
Exercises
1. For each of the following integrals, give the sequence of procedure calls
that shows the path taken by the algorithm to evaluate the integral. For
some integrals, the sequence of procedure calls depends on the order of theexpressions in the substitution set P.
(a)
sec
3(x)tan(x)dx.
(b)
(sin(x)+4)3cos(x)dx.
(c)
x·~Wx2
2c+1}3
+2^
dx.
(d)
(sin(x)+1)(cos( x)+1) dx.
2. Explain why each of the following integrals can be evaluated with substi-
tution but cannot be evaluated by the algorithm in this section.
5.3. Case Study: Elementary Integration Operator 209
(a)x+2
x2+4x+2dx,l e t v=x2+4x+2.
(b)
sini
ax2+bx2J
xd x ,letv=ax2+bx2.
(c)1
(2x+3)
4x+5)dx=a rc ta n(√
4x+5),letv=√
4x+5.
3. (a) Give a procedure for Integral
table(f,x). Iffis not in the table,
return the global symbol Fail.
(b) Give a procedure for the Linear
properties (f,x) operator.
When fisaproduct,applyEquation( 5.15)byseparatingtheoperands
that are free of xfromfusing theSeparate
factorsprocedure (see
page148) and integrating the remaining expression with a recursive
call toIntegral. If none of the operands of fis free of x, this prop-
erty does not contribute to the evaluation of the integral, and so the
procedure returns the global symbol Fail.
When fis a sum, apply Equation ( 5.16) by evaluating the integral
of each operand using Integral. However, if some operand cannot be
integrated, then return Failbecause the algorithm cannot integrate
the entire sum.
Finally, if fis not a product or a sum, return Fail.
(c) Give a procedure Trial
substitutions (f) that ﬁnds all functions, ar-
guments of functions, and bases and exponents of powers that occur
inf. The result should be returned as a set.
4. This exercise describes a procedure that evaluates integrals of rational ex-
pressions of the formrx+s
ax2+bx+cdx, (5.28)
where a/negationslash=0 ,b,c,r,a n dsare free of x. The algorithm for this integral is
divided into two cases. First, when the integrand has the form
f=1
q,q=ax2+bx+c,
then
dx
q=

2arctanW
2ax+b
√
4ac−b2}
√
4ac−b2,ifb2−4ac<0,
−2arctanhW
2ax+b
 √
b2−4ac}
√
b2−4ac,ifb2−4ac>0,
−2
2ax+b, ifb2−4ac=0 .(5.29)
210 5. Recursive Algorithms
Next, when the integrand has the form f=rx+s
q,t h e n
rx+s
qdx=αln(q)+βdx
q,
where α=r/(2a),β=s−rb /(2a), and the integral on the right is
evaluated with Equation ( 5.29).
(a) Give a procedure Rational
form(f,x) that checks that fhas the
proper form and obtains the integral. If b2−4acis not an inte-
ger or fraction, which means that it cannot be compared to 0, return
the arctan form in ( 5.29). Iffdoes not have the form in ( 5.28), re-
turn the global symbol Fail.Hint:TheLinear
formprocedure (see
Figure5.7on page181)a n dt h eQuadratic
formprocedure (Exercise
8, page195) are useful for this exercise.
(b) Modifythe Rational
formproceduresothatitalsoevaluatesintegrals
of the form rx+s
bx+cdx,
where b/negationslash=0a n d r/negationslash=0 .( T h ec a s e s b=0o r r= 0 are handled by
other cases in Integral.)
(c) Modify themain Integralprocedure so that it calls on Rational
form.
(For further exploration of this operator and its generalization, the reader
may consult Cohen [ 24], Section 4.4, Exercise 10.)
5. Use theIntegraloperator together with the Rational
formoperator in Ex-
ercise4to evaluate
cos(x)
sin2(x)+3sin( x)+4dx.
6. This exercise describes a procedure that evaluates integrals of the form
1
(ax+b)√
rx+sdx,
where a/negationslash=0 ,b,r/negationslash=0 ,a nd sare free of x.
(a) Show that the integral can be transformed by the substitution v=√
rx+sto
1
(ax+b)√
rx+sdx=21
av2−as+brdv.
The new integral is evaluated using the Rational
formoperator (Ex-
ercise4).
(b) Give a procedure Radical
form(f,x)t h a tc h e c k si f fhas the proper
form, and, if so, applies the above transformation and returns the
result in terms of x.I ffdoes not have the proper form, return the
global symbol Fail.
5.3. Case Study: Elementary Integration Operator 211
(c) Modify the main Integralprocedure so that it calls on Radical
form
procedure.
7. UsetheIntegraloperatortogetherwiththe Radical
formoperator(Exercise
6)t oe v a l ua t e3cos(x)
(5sin(x)+1)
4sin(x)+7dx.
8. This exercise describes a procedure that evaluates integrals of the form

fd x=
sinm(x)c o sn(x)dx, (5.30)
where mandnare non-negative integers. Integrals of this form can be
evaluated using the reduction formulas

cosn(x)dx=(1/n)cosn−1(x)s i n (x)+n−1
n
cosn−2(x)dx,(5.31)

sinm(x)c o sn(x)dx=−sinm−1(x)c o sn+1(x)
m+n(5.32)
+m−1
m+n
sinm−2(x)c o sn(x)dx.
Notice that repeated use of Equation ( 5.32) reducestheintegrand in ( 5.30)
to the form sin( x)cosn(x)( w h e n mis odd) or to cosn(x)( w h e n mis
even). In the ﬁrst case, the remaining integral is evaluated by a call to
Substitution
methodand, in the second case, with Equation ( 5.31).
(a) Giveaprocedure Trig
form(f,x)thatc hec ksif fhastheproperform
and if so obtains the integral. If fdoes not have the proper form,
return the global symbol Fail.
(b) Modify the main Integralprocedure so that it calls on Trig
form.
Another approach for these integrals is described in Exercise 10, page306.
9. Let nbe a positive integer and let aandbbe free of x. The following
recurrence relations are derived using integration by parts:

xnexp(ax+b)dx= (5.33)
xn/aexp(ax+b)−n/a
xn−1exp(ax+b)dx,

xnsin(ax+b)dx= (5.34)
−xn/acos(ax+b)+n/a
xn−1cos(ax+b)dx,

xncos(ax+b)dx= (5.35)
xn/asin(ax+b)−n/a
xn−1sin(ax+b)dx.
212 5. Recursive Algorithms
(a) Give a procedure By
parts(f,x) that checks if the integrand is one
of these forms and when this is so evaluates the integral using the
appropriaterecurrencerelation. If fdoesnothaveoneoftheseforms,
return the global symbol Fail.
(b) Modify the main Integralprocedure so that it calls on the By
parts
procedure.
Further Reading
5.1A Computational View ofRecursion. A more detailed discussion of
how recursion is implemented in a computer system is given in Pratt [ 82].
5.2Recursive Procedures. Rule-based programming in Mathematica is de-
s c r i b e di nG a y l o r de ta l .[ 38]a n dG r a y[ 41].
5.3Case Study: An Elementary Indeﬁnite Integration Operator. Moses
[70] discusses the derivative divides method of integration. Symbolic integration
is a very diﬃcult mathematical and computational problem. Geddes, Czapor,
and Labahn [ 39], Chapter 11 is a good introduction to the subject. Bronstein
[13] gives a theoretical discussion of the subject.
6
Structure of Polynomials and
Rational Expressions
In Chapter 3we described the tree structure of an expression. An ex-
pression also has a semantic structure that is related to its mathematical
properties. For example, the expression 3 x2+4x+5/2 can be viewed both
as an expression tree and semantically as a polynomial in xwith degree 2
that has rational number coeﬃcients.
In this chapter, we describe the polynomial structure andrational ex-
pression structure of an algebraic expression. For polynomials, we give
three deﬁnitions of increasing generality: ﬁrst for single variable polynomi-als (Section 6.1); next for multivariate polynomials (Section 6.1); and ﬁnally
for general polynomial expressions (Sections 6.2and6.3). The deﬁnitions
are more involved than those found in mathematics textbooks, since theyfocus on computational concerns as well as the mathematical concept of
a polynomial. Along with these deﬁnitions, we give MPL procedures that
determine the polynomial structure of an expression. In Section 6.4,w e
use these structural concepts to describe the goals of two transformations,
coeﬃcient collection and algebraic expansion, and give MPL algorithms forthese operations. Finally, in Section 6.5we describe the rational expression
structure of an algebraic expression and give an algorithm that transforms
an expression to a particular rational form.
Although operators that determine the structure of polynomials and
rational expressions are available in most computer algebra languages, their
capacity varies from system to system. The concepts in this chapter provide
a framework to analyze and compare how these concepts are implemented
in various CAS languages.
213
214 6. Structure of Polynomials and Rational Expressions
6.1 Single Variable Polynomials
We begin by considering polynomials in a single variable with rational
number coeﬃcients.
Definition 6.1. (Mathematical Deﬁnition) Apolynomial uin a
single variable xis an expression of the form:
u=unxn+un−1xn−1+...+u1x+u0, (6.1)
where thecoeﬃcients ujare rational numbers, and nis a non-negative
integer. If un/negationslash=0,t h e nunis called the leading coeﬃcient ofuandnis
itsdegree . The expression u=0is called the zero polynomial ; it has
leading coeﬃcient 0and, according to mathematical convention has degree
−∞. The leading coeﬃcient is represented by lc(u,x)and the degree by
deg(u,x). When the variable xis evident from context, we use the simpler
notations lc(u)anddeg(u).
Observe that we have distinguished the zero polynomial from other
constant polynomials because it has no non-zero coeﬃcients, and so the
general deﬁnitions for leading coeﬃcient and degree do not apply1.
Example 6.2.
u=3x6+2x4−5/2,deg(u)=6,lc(u)=3,
u=x2−x+2,deg(u)=2,lc(u)=1, (6.2)
u=2x3,deg(u)=3,lc(u)=2, (6.3)
u=3,deg(u)=0,lc(u)=3. (6.4)
/square
Although Deﬁnition 6.1deﬁnes the concept of a polynomial in a math-
ematically precise way, it requires some interpretation and is not adequate
for computational purposes. For example, in the previous example, thedeﬁnition is interpreted in a broad sense to include expressions that have
coeﬃcients that are understood to be ±1 (as in Equation ( 6.2)) and those
that have a single term (as in Equations ( 6.3)a n d( 6.4)). The following
deﬁnition, which captures the essence of a single variable polynomial in a
1For the polynomial u= 0, both Maple’s degree operator and Mathematica’s
Exponent operator return a degree of −∞. On the other hand, MuPAD’s degree operator
returns a degree of 0.
6.1. Single Variable Polynomials 215
computational setting, can be easily expressed as an MPL procedure that
recognizes when an expression is a polynomial.
Definition 6.3. (Computational Deﬁnition) Amonomial in a single
variablexis an algebraic expression uthat satisﬁes one of the following
rules.
MON-1. uis an integer or fraction.
MON-2. u=x.
MON-3. u=xn,w h e r en>1is an integer.
MON-4. uis a product with two operands that satisﬁes either MON-1,
MON-2, or MON-3.
Apolynomial in a single variable xis an expression uthat satisﬁes one
of the following rules.
POLY-1. uis a monomial in x.
POLY-2. uis a sum, and each operand of uis a monomial in x.
Primitive Operations on Polynomials
TheMonomial
 svandPolynomial
 svOperators. The operators that are de-
scribed in the next deﬁnition recognize when an expression is a monomial
or a polynomial.
Definition 6.4. Letube an algebraic expression . The operator
Monomial
 sv(u,x)
returnstrue whenuis a monomial in xand otherwise returns false.( T h e
suﬃx “sv” stands for “single variable.”) The operator
Polynomial
 sv(u,x)
returnstrue whenuis a polynomial in xand otherwise returns false.
Example 6.5.
Monomial
 sv(2x3,x)→true,
Monomial
 sv(x+1,x)→false,
Polynomial
 sv(3x2+4x+5,x)→true,
Polynomial
 sv(1/(x+1 ),x)→false,
Polynomial
 sv(ax2+bx+c, x)→false.
216 6. Structure of Polynomials and Rational Expressions
The expression ax2+bx+cis not a polynomial in xbecause the coeﬃcients
are not rational numbers. It is, however, a multivariate polynomial (Deﬁni-
tion6.12, page 221), and a general polynomial expression (Deﬁnition 6.14,
page 223). /square
The operators described in Deﬁnition 6.4are understood to operate
within a computational environment deﬁned by an evaluation process thatincludes automatic simpliﬁcation. Since this process is applied to the input
arguments before the actual tests are done, an expression uis a polynomial
inxif the evaluation process transforms it to an expression that satisﬁes
Deﬁnition 6.3.Int h i ss e n s e ,s i n ( x)+x−sin(x) is a polynomial in x, because
the sin(x) terms are eliminated by automatic simpliﬁcation.
But now the question arises, should the operators apply any other trans-
formation rules to ubefore the tests are done? In other words, in what
simpliﬁcation context should we interpret our polynomial deﬁnition? Forexample, each of the expressions
(x+1 ) (x+3 ),x
2+s i n2(x)+c o s2(x),x2−1
x−1,cos(2arccos( x))
can be transformed to a polynomial in the sense of Deﬁnition 6.1. However,
if we assume a simpliﬁcation context of automatic simpliﬁcation, they are
not considered polynomials in xbecause the required transformation rules
are not applied by this process.
The question of which simpliﬁcation transformations to include in the
deﬁnition of Polynomial
 svdoes not have a simple answer. For example, if
the operator Algebraic
 expand were applied, the expression ( x+1 ) (x+3 )
would be a polynomial in x. There are, however, some cases when it is
not useful to apply Algebraic
 expand (for example, see Expression ( 6.9)o n
page224). For now, we take the conservative view that the these procedures
as well as the others in this section operate within the context of only
automatic simpliﬁcation.
Procedures for Monomial
 svandPolynomial
 svare given in Figures
6.1and6.2.InMonomial
 sv, the four MON tests are done in lines 1-11.
Notice that MON-4 (lines 10-11) is handled with two recursive calls on
the procedure. Any expression that is not handled by lines 1-11 is nota monomial in x,a n ds ofalseis returned (line 12). In a similar way,
Polynomial
svtests the two POLY rules in lines 1-7. Any expression not
handled here is not a polynomial, and so falseis returned at line 8.
The operators in the next three deﬁnitions provide a way to analyze
the polynomial structure of an expression.
6.1. Single Variable Polynomials 217
Procedure Monomial
sv(u,x);
Input
u:a nalgebraic expression ;
x:as y m b o l ;
Output
trueorfalse;
Local Variables
base,exponent;
Begin
1 ifKind(u)∈{integer ,fraction }then
2Return(true)
3 elseif u=xthen
4Return(true)
5 elseifKind(u)=” ∧”then
6base:=Operand(u,1);
7exponent :=Operand(u,2);
8 ifbase=xandKind(exponent)=integer and exponent >1then
9 Return(true)
10 elseifKind(u)=” ∗”then
11Return(Number
of
operands(u)=2andMonomial
sv(Operand(u,1),x)
andMonomial
sv(Operand(u,2),x));
12Return(false)
End
Figure 6.1. An MPL monomial recognition procedure. (Implementation: Maple
(txt),Mathematica (txt),MuPAD(txt).)
TheDegree
 svOperator
Definition 6.6. Letube an algebraic expression .I fuis a polynomial in x,
the operator
Degree
 sv(u,x)
returns deg(u,x).I fuis not a polynomial in x, the operator returns the
symbolUndeﬁned .
Example 6.7.
Degree
 sv(3x2+4x+5,x)→2,
Degree
 sv(2x3,x)→3,
Degree
 sv((x+1 ) (x+3 ),x)→Undeﬁned ,
Degree
 sv(3,x)→0. /square
218 6. Structure of Polynomials and Rational Expressions
Procedure Polynomial
sv(u,x);
Input
u:a nalgebraic expression ;
x:as y m b o l ;
Output
trueorfalse;
Local Variables
i;
Begin
1 ifMonomial
sv(u,x)then
2Return(true)
3 elseifKind(u)=”+” then
4 fori:= 1toNumber
of
operands(u)do
5 ifMonomial
sv(Operand(u,i),x)=false then
6 Return(false);
7Return(true);
8Return(false)
End
Figure 6.2. AnMPLpolynomialrecognition procedure. (Implementation: Maple
(txt),Mathematica (txt),MuPAD(txt).)
Procedures for the operator Degree
 sv(u,x), similar to the ones for
Monomial
 svandPolynomial
 sv,a r eg i v e ni nF i g u r e s 6.3and6.4.Int h i s
case, the procedure Degree
 monomial
 sv(u,x) gives the degree for mono-
mials, and Degree
 sv(u,x) is deﬁned in terms of this procedure. Observe
that in Degree
 monomial
 svat line 17, we use the structural assumption
that a constant in a product is the ﬁrst operand (Rule 2, page 90)2.
TheCoefficient
 svOperator
Definition 6.8. Letube an algebraic expression .I fuis a polynomial in x,
the operator
Coeﬃcient
 sv(u,x,j)
returns the coeﬃcient ujofxjin Equation ( 6.1). Ifj>deg(u,x),C o e ﬃ c i e n t
 sv
returns 0.I fuis not a polynomial in x, the operator returns the symbol
Undeﬁned .
2This assumption holds in both Maple and Mathematica. In MuPAD, however, since
the constant is the last operand in a product, line 17 is replaced by Return (s).
6.1. Single Variable Polynomials 219
Procedure Degree
monomial
sv(u,x);
Input
u:a nalgebraic expression ;
x:as y m b o l ;
Output
deg(u,x) or the global symbol Undeﬁned ;
Local Variables
base,exponent ,s,t;
Begin
1 ifu=0then
2Return(−∞)
3 elseifKind(u)∈{integer ,fraction }then
4Return(0)
5 elseif u=xthen
6Return(1)
7 elseifKind(u)=” ∧”then
8base:=Operand(u,1);
9exponent :=Operand(u,2);
10 ifbase=xandKind(exponent)=integer and exponent >1then
11 Return(exponent)
12 elseifKind(u)=” ∗”then
13 ifNumber
of
operands(u)=2then
14 s:=Degree
monomial
sv(Operand(u,1),x);
15 t:=Degree
monomial
sv(Operand(u,2),x);
16 ifs/negationslash=Undeﬁned and t/negationslash=Undeﬁned then
17 Return(t)
18Return(Undeﬁned )
End
Figure 6.3. An MPL procedure for Degree
monomial
sv. (Implementation:
Maple(txt),Mathematica (txt),MuPAD(txt).)
Example 6.9.
Coeﬃcient
 sv(x2+3x+5,x ,1)→3,
Coeﬃcient
 sv(2x3+3x, x,4)→0,
Coeﬃcient
 sv(3,x ,0)→3,
Coeﬃcient
 sv((x+1 ) (x+3 ),x ,2)→Undeﬁned ./square
TheCoeﬃcient
 svoperator is implemented with procedures similar to
those for Polynomial
 svandDegree
 sv(Exercise 6).
220 6. Structure of Polynomials and Rational Expressions
Procedure Degree
sv(u,x);
Input
u:a nalgebraic expression ;
x:as y m b o l ;
Output
deg(u,x) or the global symbol Undeﬁned ;
Local Variables
d,i,f;
Begin
1 d:=Degree
monomial
sv(u,x);
2 ifd/negationslash=Undeﬁned then
3Return(d)
4 elseifKind(u)=”+” then
5 d:= 0;
6 fori:= 1toNumber
of
operands(u)do
7 f:=Degree
monomial
sv(Operand(u,i),x);
8 iff=Undeﬁned then
9 Return(Undeﬁned )
10 else
11 d:=Max({d,f})
12Return(d);
13Return(Undeﬁned )
End
Figure 6.4. An MPL procedure for Degree
sv. (Implementation: Maple(txt),
Mathematica (txt),MuPAD(txt).)
TheLeading
 coefficient
 svOperator
Definition 6.10. Letube an algebraic expression .I fuis a polynomial in
x, the operator
Leading
 coeﬃcient
 sv(u,x)
returns lc(u,x)(Deﬁnition 6.1,p a g e 214). Ifuis not a polynomial in x,
the operator returns the symbol Undeﬁned .
Example 6.11.
Leading
 coeﬃcient
 sv(x2+3x+5,x)→1,
Leading
 coeﬃcient
 sv(3,x)→3./square
6.1. Single Variable Polynomials 221
TheLeading
 coeﬃcient
 svoperator can be obtained with a composition
of the Degree
 svandCoeﬃcient
 svoperators. For example, if u=3x2+
4x+ 5, the leading coeﬃcient is obtained with
Coeﬃcient
 sv(u,x,Degree
 sv(u,x))→3.
Another approach is to obtain it directly with procedures similar to those
forDegree
 sv(Exercise 7).
Multivariate Polynomials
Polynomials that contain more than one variable are called multivariate
polynomials .
Definition 6.12. (Mathematical Deﬁnition) Amultivariate poly-
nomialuin the set of symbols {x1,x2,...,x m}is a ﬁnite sum with (one
or more) monomial terms of the form
cxn1
1xn2
2···xnm
m,
where the coeﬃcient cis a rational number and the exponents njare non-
negative integers.
Example 6.13. The following are multivariate polynomials:
p+1/2ρv2+ρgy, ax2+2bx+3c, x2−y2,m c2,3x2+4./square
Although it is possible to give a computational deﬁnition for multivari-
ate polynomials that is similar to Deﬁnition 6.3and to extend the primitive
operations to this setting (Exercise 2), it is more convenient to do so in the
context of general polynomial expressions, which are deﬁned in the nextsection.
Exercises
For the exercises in this section, do not use the polynomial operators in a CAS.
1. Theheightof a polynomial is the maximum of the absolute values of its
coeﬃcients. Let ube analgebraic expression . Give a procedure
Polynomial
height(u,x)
that returns the height of a polynomial. If uis not a polynomial in x,
return the global symbol Undeﬁned .
2. (a) Give a computational deﬁnition for multivariate polynomials that is
similar to Deﬁnition 6.3.
222 6. Structure of Polynomials and Rational Expressions
(b) Give a procedure
Polynomial
mv(u,S)
that returns trueif analgebraic expression uis a multivariate poly-
nomial in a set Sof symbols and otherwise returns false.
3. Give a deﬁnition for a polynomial that includes expressions that contain
products and positive integer powers of expressions that satisfy Deﬁnition
6.3. For example,
x3+(x+1)(x+2)+4 ,(x2+x+1)3,1+(x+1)(x+2)2,((x+1)2+1)2
are polynomials according to this new deﬁnition. Give a procedure
Polynomial
sv
unexp(u,x)
that returns trueif analgebraic expression is a polynomial in this sense
and otherwise returns false.D on o tus et h e Algebraic
expandoperator as
part of the deﬁnition or the procedure.
4. Consider the class of expressions that are polynomials in ywith coeﬃ-
cients that are polynomials in xwith rational number coeﬃcients. For
example, u=( 1+ x2)y3+(2x−1)yis in this class. Give a procedure
Polynomial
xy(u,x,y) that returns trueif analgebraic expression is in
this class and otherwise returns false.
5. Consider theclass ofexpressionsthatarepolynomials in xwith coeﬃcients
that have the form c+d√
2w h e r e canddare rational numbers. For
example, the expressions x3+(1−√
2)x2+3+√
2a n d2√
2x−1a r ei n
this class. Give a procedure Polynomial
sq2(u,x) that returns trueif an
algebraic expression is in this class, and otherwise returns false.
6. Give a procedure for Coeﬃcient
sv(u,x,j).Hint:First give a procedure
Coeﬃcient
monomial
sv(u,x)
that returns a list [ c, m], where mi st h ed e g r e eo ft h em o n o m i a la n d cis
the coeﬃcient of xm.I fuis not a monomial, return the global symbol
Undeﬁned .
7. Give a procedure for Leading
coeﬃcient
sv(u,x) that does not use the
Degree
svorCoeﬃcient
svoperators.Hint:Modify the procedures for
Degree
sv. First give a procedure
Leading
coeﬃcient
monomial
sv(u,x)
that returns a list [ c, m], where mi st h ed e g r e eo ft h em o n o m i a la n d cis
the coeﬃcient of xm.I fuis not a monomial, return the global symbol
Undeﬁned .
6.2. General Polynomial Expressions 223
8. Let ube analgebraic expression .W h e n uis a polynomial in x, the pro-
cedureCoeﬃcient
list(u,x) returns the list of coeﬃcients of powers of x
inu.W h e n uis not a polynomial in x, the procedure returns the global
symbol Undeﬁned . For example,
Coeﬃcient
list(2x5+3x2+4x+5,x)→[2,3,4,5].
Give a procedure for Coeﬃcient
list(u,x).
9. A rational expression in xis an expression of the form p/q,w h e r e pand
qare polynomials with rational number coeﬃcients. The following are
rational expressions:
1
x+3,x+5
x2−2,x2−1,
where, in the third example, q=1 .Le t ubeanalgebraic expression .G i v e
a procedure
Rational
sv(u, x)
thatreturns truewhenuisarationalexpressionin xandotherwisereturns
false. Use the numerator and denominator operators in a CAS to obtain
pandq(Figure4.1on page124).
6.2 General Polynomial Expressions
There are many expressions that are polynomials in a computational con-
text that are not included in the previous deﬁnitions for polynomials. For
example, it is reasonable to consider the expression
u=a
(a+1 )x2+bx+1
a
as a polynomial in x, even though it does not satisfy the deﬁnitions in
Section 6.1. Indeed, a CAS views this expression as a polynomial when it
solves the quadratic equation u=0f o rx. In addition, it is reasonable to
view the expressions sin3(x)+2s i n2(x)+3a n d( x+1 )3+2(x+1 )2+3
as polynomials in terms of a complete sub-expression (sin( x)o r(x+ 1)).
On the other hand, the expression (3sin( x))x2+( 2l n (x))x+4i sn o ta
polynomial in xbecause the coeﬃcients of the powers of xalso depend
onx.
The next deﬁnition includes the more general polynomial expressions
given above.
Definition 6.14. (Mathematical Deﬁnition) Letc1,c2,...,c rbe al-
gebraic expressions and let x1,x2,...,x mbe algebraic expressions that are
224 6. Structure of Polynomials and Rational Expressions
not integers or fractions. A general monomial expression (GME) in
{x1,x2,...,x m}is an expression of the form
c1c2···crxn1
1xn2
2···xnm
m, (6.5)
where the exponents njare non-negative integers and each cisatisﬁes the
independence property
Free
of(ci,xj)→true,forj=1,2,...,m. (6.6)
The expressions xjare calledgeneralized variables because they mimic
t h er o l eo fv a r i a b l e s ,a n dt h ee x p r e s s i o n s ciare calledgeneralizedcoeﬃ-
cients because they mimic the role of coeﬃcients. The expression
xn1
1···xnm
m
is called the variablepart of the monomial, and if there are no generalized
variables in the monomial, the variable part is 1. The expression c1···cris
called thecoeﬃcientpart of the monomial, and if there are no generalized
coeﬃcients in the monomial, the coeﬃcient part is 1. An expression uis a
general polynomial expression (GPE) if it is either a GME or a sum
of GMEs in {x1,x2,...,x m}.
Example 6.15. The following are general polynomial expressions:
x2−x+1,(x1=x),
x2y−xy2+2,(x1=x, x2=y),
a
(a+1 )x2+bx+1
a,(x1=x), (6.7)
sin3(x)+2s i n2(x)+3,(x1=s i n (x)), (6.8)
(x+1 )3+2(x+1 )2+3,(x1=x+1 ), (6.9)√
2x2+√
3x+√
5,(x1=x). (6.10)
The deﬁnition is quite general. It includes the single variable polyno-
mials (Deﬁnition 6.3), multivariate polynomials (Deﬁnition 6.12) and allows
the more general Expressions ( 6.7), (6.8), (6.9), and ( 6.10). Notice that Ex-
pression ( 6.10) is a GPE, but not a single variable polynomial in the sense
of Deﬁnition 6.1because the coeﬃcients are not rational numbers. On the
other hand, the expression (sin( x))x2+(ln(x))x+4 is not a GPE in xalone
because the coeﬃcients sin( x)a n dl n (x) do not satisfy the independence
property in Equation ( 6.6).
The deﬁnition is also quite ﬂexible because it allows for a choice of which
parts of an expression act as variables and which parts act as coeﬃcients.
6.2. General Polynomial Expressions 225
For example, the expression 2 ax2+3bx+4cc a nb ev i e w e da sap o l y -
nomial in {a,b,c,x }with integer coeﬃcients or as a polynomial in xwith
coeﬃcients 2 a,3band 4c. In fact, it is possible to view the expression as
a polynomial in another variable (say z) with the entire expression as the
coeﬃcient part of z0. In addition, since a sum can be a generalized vari-
able, we can even designate the entire expression as a generalized variable
and view it as a polynomial in terms of itself. /square
The following deﬁnitions for a GME and GPE are more suitable for
computational purposes.
Definition 6.16. (ComputationalDeﬁnition) Ageneralmonomial
expression (GME) in a set of generalized variables
S={x1,x2,...,x m}
is an algebraic expression uthat satisﬁes one of the following rules.
GME-1. Free
of(u,xj)→true,f o rj=1,...,m .
GME-2. u∈S.
GME-3. u=xn,w h e r ex∈Sandn>1is an integer.
GME-4. uis a product, and each operand of uis a GME in S.
Ageneral polynomial expression (GPE) in a set Sof expressions
is an algebraic expression uthat satisﬁes one of the following rules.
GPE-1.uis a GME in S.
GPE-2.uis a sum and each operand of uis a GME in S.
This deﬁnition is similar to Deﬁnition 6.3for single variable polynomi-
als. In this case, however, rule GME-1, which expresses the independence
property in Equation ( 6.6), replaces rule MON-1, which only allows for
integers or fractions as coeﬃcients. Although the deﬁnition is in terms ofas e tSof generalized variables, a list Lof distinct generalized variables
would serve as well. There are a few instances in later sections where we
refer to a polynomial in a list of variables.
Primitive Operations for General Polynomial Expressions
The operators described in the following deﬁnitions obtain the polynomialstructure of an expression.
226 6. Structure of Polynomials and Rational Expressions
TheMonomial
 gpe andPolynomial
 gpe Operators
Definition 6.17. Letube an algebraic expression ,a n dl e t vbe either a
generalized variable xor a setSof generalized variables. The operator
Monomial
 gpe(u,v)
returnstrue whenever uis a GME in {x}or inS, and otherwise returns
false. The operator
Polynomial
 gpe(u,v)
returnstrue whenever uis a GPE in {x}or inS, and otherwise returns
false.
Example 6.18.
Monomial
 gpe(ax2y2,{x, y})→true,
Monomial
 gpe(x2+y2,{x, y})→false,
Polynomial
 gpe(x2+y2,{x, y})→true,
Polynomial
 gpe(sin2(x)+2s i n (x)+3,sin(x))→true,
Polynomial
 gpe(x/y+2y,{x,y})→false,
Polynomial
 gpe((x+1 )(x+3 ),x)→false./square
Procedures for the operators Monomial
 gpeandPolynomial
 gpeare
given in Figures 6.5and6.6. Although the procedures are based on the
rules in Deﬁnition 6.16, there are two modiﬁcations that are designed to
avoid redundant recursive calls on the Set
free
ofoperator. (The Set
free
of
operator determines if uis free of all of the expressions in a set S(Exercise
1, page 194).) First, in the Monomial
 gpeprocedure the independence
property GME-1 is checked at the end of the procedure in line 14 instead
of at the beginning. The reason for this has to do with the recursive call in
Monomial
 gpewhenuis a product (line 11), together with the recursive
nature of Set
free
of.IfGME-1 were at the beginning of the procedure,
theSet
free
ofoperator would test the operands of a product in GME-1 ,
and might need to re-check them again because of the recursive calls on
Monomial
 gpeat line 11. By placing the rule at the end of the procedure
we avoid this redundancy.
Next, in the Polynomial
 gpeprocedure, we check rule GPE-1 directly
only when uis not a sum (lines 2-3). Since a sum can be a monomial (for
example,u=a+bandS={a+b}), we check for this possibility separately
at line 5. By doing this we avoid redundant calls on Set
free
ofwhich would
6.2. General Polynomial Expressions 227
Procedure Monomial
gpe(u,v);
Input
u:a nalgebraic expression ;
v:ageneralized variable or a set of generalized variables ;
Output
trueorfalse;
Local Variables
i,S,base,exponent;
Begin
1 ifKind(v)/negationslash=set then S:={v}elseS:=v;
2 ifu∈Sthen
3Return(true)
4 elseifKind(u)=” ∧”then
5base:=Operand(u,1);
6exponent :=Operand(u,2);
7 ifbase∈SandKind(exponent)=integer and exponent >1then
8 Return(true)
9 elseifKind(u)=” ∗”then
10 fori:= 1toNumber
of
operands(u)do
11 ifMonomial
gpe(Operand(u,i),S)=false then
12 Return(false);
13Return(true);
14Return(Set
free
of(u,S))
End
Figure 6.5. An MPL procedure for the recognition of GMEs. (Implementation:
Maple(txt),Mathematica (txt),MuPAD(txt).)
occur if Monomial
 gpewere used to check if a sum is a monomial and then
applied again through Monomial
 gpeat line 7.
TheVariables Operator. The polynomial structure of a GPEdepends on
which expressions are chosen for the generalized variables. The operator
in the next deﬁnition deﬁnes a natural set of generalized variables for anexpression.
Definition 6.19. Letube an algebraic expression . The operator
Variables (u)
is deﬁned by the following transformation rules.
228 6. Structure of Polynomials and Rational Expressions
Procedure Polynomial
gpe(u,v);
Input
u:a nalgebraic expression ;
v:ageneralized variable or a set of generalized variables ;
Output
trueorfalse;
Local Variables
i,S;
Begin
1 ifKind(v)/negationslash=set then S:={v}elseS:=v;
2 ifKind(u)/negationslash=”+” then
3Return(Monomial
gpe(u,S))
4 else
5 ifu∈SthenReturn(true);
6 fori:= 1toNumber
of
operands(u)do
7 ifMonomial
gpe(Operand(u,i),S)=false then
8 Return(false);
9Return(true)
End
Figure 6.6. An MPL procedure for the recognition of GPEs. (Implementation:
Maple(txt),Mathematica (txt),MuPAD(txt).)
VAR-1. Ifuis an integer or a fraction, then
Variables (u)→∅.
VAR-2. Supposeuis a power. If the exponent of uis an integer that is
greater than 1, then
Variables (u)→{Operand (u,1)}
(the base of u),o t h e r w i s e
Variables (u)→{u}.
VAR-3. Supposeuis a sum. Then Variables (u)is the union of the gen-
eralized variables of each operand of uobtained using rules VAR-1,
VAR-2, VAR-4, or VAR-5.
VAR-4. Supposeuis a product. Then Variables (u)contains the union
of the generalized variables of each operand of udetermined by rules
VAR-1, VAR-2, or VAR-5, as well as any operand that is a sum.
6.2. General Polynomial Expressions 229
Observe that for a product we include an operand that is a sum in the
variable set (see Expression ( 6.11) below) even though a sum by itself is
not in the variable set (VAR-3).
VAR-5. Ifuis not covered by the above rules, then
Variables (u)→{u}.
The last rule covers symbols, function forms, and factorials.
Example 6.20. For a multivariate polynomial, the operator returns the set
of variables in the expression:
Variables (x3+3x2y+3xy2+y3)→{x,y}.
Other examples include
Variables (3x(x+1 )y2zn)→{x, x+1,y,zn}, (6.11)
Variables (asin2(x)+2bsin(x)+3c)→{a, b, c, sin(x)},
Variables (1/2)→∅,
Variables (√
2x2+√
3x+√
5)→{x,√
2,√
3,√
5}.
The last example shows that the Variables operator also selects expressions
that do not vary in the mathematical sense, but still act as natural place
holders in the expression. In fact, any algebraic expression uis always
aGPEin terms of Variables (u), and when it is viewed in this way, the
coeﬃcient part in each monomial is an integer or fraction (Exercise 7)./square
The procedure for Variables (u)i sl e f tt ot h er e a d e r( E x e r c i s e 6).
TheDegree
 gpe Operator. In the next deﬁnition we generalize the degree
concept to generalized polynomial expressions.
Definition 6.21. LetS={x1,...,x m}be a set of generalized variables. Let
u=c1···cr·xn1
1···xnm
m
be a monomial with non-zero coeﬃcient part. The degree ofuwith respect
to the set Sis the sum of the exponents of the generalized variables:
deg(u,S)=n1+n2+···+nm.
230 6. Structure of Polynomials and Rational Expressions
By mathematical convention, the degree of the 0monomial is deﬁned to
be−∞.
Ifuis aGPE that is a sum of monomials, then deg(u,S)is the max-
imum of the degrees of the monomials. If Scontains a single generalized
variablex, we use the simpler notation deg(u,x), and if the generalized
variables are understood from context, we use deg(u).
Example 6.22.
deg(3wx2y3z4,{x, z})=6,
deg(ax2+bx+c, x)=2,
deg(asin2(x)+bsin(x)+c,sin(x)) = 2,
deg(2x2yz3+wxz6,{x,z})=7./square
Definition 6.23. Letube an algebraic expression ,a n dl e tvbe a generalized
variablexor a setSof generalized variables. The degree operator has the
form:
Degree
 gpe(u,v).
Whenuis aGPE inv, the operator returns deg(u,v).I fuis not a GPE
inv, the operator returns the global symbol Undeﬁned .
Procedures for Degree
 gpe, which are similar to the ones for the oper-
ators Monomial
 gpeandPolynomial
 gpein Figures 6.5and6.6,a r el e f tt o
the reader (Exercise 8).
Definition 6.24. Letube an algebraic expression ,a n dl e t
S=Variables (u).
The operation deg(u,S)is called the total degree of the expression u.
Example 6.25. Ifu=ax2+bx+c,t h e nS={a, b, c, x }, and the total
degree is deg( u,{a,b,c,x })=3. /square
TheCoefficient
 gpe Operator
Definition 6.26. Letube an algebraic expression .I fuis aGPE in a
generalized variable xandj≥0is an integer, then the operator
Coeﬃcient
 gpe(u,x,j)
returns the sum of the coeﬃcient parts of all monomials of uwith variable
partxj. If there is no monomial with variable part xj, the operator returns
6.2. General Polynomial Expressions 231
0. Ifuis not a polynomial in x, the operator returns the global symbol
Undeﬁned .
Example 6.27.
Coeﬃcient
 gpe(ax2+bx+c, x,2)→a,
Coeﬃcient
 gpe(3xy2+5x2y+7x+9,x ,1)→3y2+7,
Coeﬃcient
 gpe(3xy2+5x2y+7x+9,x ,3)→0,
Coeﬃcient
 gpe((3 sin(x))x2+( 2l n (x))x+4,x ,2)→Undeﬁned .
/square
Procedures that obtain coeﬃcients are shown in Figures 6.7and6.8.
Whenuis aGMEinx,t h eCoeﬃcient
 monomial
 gpeprocedure returns a
list [c,m], wheremis the degree uinxandcis the coeﬃcient part of the
monomial. If uis not a monomial in x, the global symbol Undeﬁned is
returned. The case where uis a product is handled in lines 8-18. In lines
9 and 10, the assignments for candmassume initially that the degree is
zero anduis the coeﬃcient part. These values are only changed if some
operand of uis a monomial in xwith positive degree (lines 15-17). Since u
is an automatically simpliﬁed product3, this can happen with at most one
operand of u. Nevertheless, we must check each operand to determine that
uis a monomial in x.
TheCoeﬃcient
 gpeprocedure shown in Figure 6.8is similar to the
Polynomial
 gpeprocedure (Figure 6.6).
Although the Coeﬃcient
 gpeoperator is only deﬁned with respect to a
single generalized variable x, the coeﬃcient part of a more general mono-
mial can be obtained by composition. For example, if u=3xy2+5x2y+
7x+ 9, the coeﬃcient of xy2can be found with
Coeﬃcient
 gpe(Coeﬃcient
 gpe(u,x,1),y,2)→3.
However, if there are dependencies between the generalized variables, then
the order of the coeﬃcient operations is signiﬁcant. For example, if
u=3s i n (x)x2+2l n (x)x+4,
then to obtain the coeﬃcient of ln( x)x,we apply
Coeﬃcient
 gpe(Coeﬃcient
 gpe(u,ln(x),1),x,1)→2.
3We assume here that the power transformation xmxn→xn+m,f o rmandnin-
tegers, is applied during automatic simpliﬁcation, and so a product can have at mostone operand that is a power with base x. This transformation is obtained in Maple,
Mathematica, and MuPAD.
232 6. Structure of Polynomials and Rational Expressions
Procedure Coeﬃcient
monomial
gpe(u,x);
Input
u:a nalgebraic expression ;
x:ageneralized variable ;
Output
The list [ c, m]w h e r e mis the degree of the monomial and
cis the coeﬃcient of xmor the global symbol Undeﬁned ;
Local Variables
base,exponent ,i,c,m,f;
Begin
1 ifu=xthen
2Return([1,1])
3 elseifKind(u)=” ∧”then
4base:=Operand(u,1);
5exponent :=Operand(u,2);
6 ifbase=xandKind(exponent)=integer and exponent >1then
7 Return([1,exponent])
8 elseifKind(u)=” ∗”then
9 m:= 0;
10 c:=u;
11 fori:= 1toNumber
of
operands(u)do
12 f:=Coeﬃcient
monomial
gpe(Operand(u,i),x);
13 iff=Undeﬁned then
14 Return(Undeﬁned )
15 elseifOperand(f,2)/negationslash=0then
16 m:=Operand(f,2);
17 c:=u/xm;
18Return([c,m]);
19 ifFree
of(u,x)then
20Return([u,0])
21 else
22Return(Undeﬁned )
End
Figure 6.7. An MPL procedure for the Coeﬃcient
monomial
gpeoperator. (Im-
plementation: Maple(txt),Mathematica (txt),MuPAD(txt).)
The reverse operation
Coeﬃcient
 gpe(Coeﬃcient
 gpe(u,x,1),ln(x),1)
does not work because the inner coeﬃcient operation returns Undeﬁned .
It is always possible, however, to order the coeﬃcient operations to deter-
6.2. General Polynomial Expressions 233
Procedure Coeﬃcient
gpe(u,x,j);
Input
u:a nalgebraic expression ;
x:ageneralized variable ;
j: a non-negative integer;
Output
The coeﬃcient of xjin the polynomial uor the global symbol Undeﬁned ;
Local Variables
i,c,f;
Begin
1 ifKind(u)/negationslash=”+” then
2 f:=Coeﬃcient
monomial
gpe(u,x);
3 iff=Undeﬁned then Return(Undeﬁned )
4 else
5 ifj=Operand(f,2)thenReturn(Operand(f,1))
6 elseReturn(0)
7 else
8 ifu=xthen
9 ifj=1thenReturn(1)elseReturn(0);
10 c:= 0;
11 fori:= 1toNumber
of
operands(u)do
12 f:=Coeﬃcient
monomial
gpe(Operand(u,i),x);
13 iff=Undeﬁned then Return(Undeﬁned )
14 elseifOperand(f,2) =jthen c=c+Operand(f,1);
15Return(c)
End
Figure 6.8. An MPL procedure for the Coeﬃcient
gpeoperator. (Implementa-
tion:Maple(txt),Mathematica (txt),MuPAD(txt).)
mine the desired coeﬃcient (Exercise 8, page 247). Of course, if uis aGPE
in both expressions, then the order of the coeﬃcient operations does notmatter.
The
Leading
 coefficient
 gpe Operator
Definition 6.28. Letube an algebraic expression .I fuis aGPE inx,t h e n
the leading coeﬃcient of uwith respect to xis deﬁned as the sum of the
coeﬃcient parts of all monomials with variable part xdeg(u,x). The leading
coeﬃcient is represented by lc(u,x),a n dw h e n xis understood from context,
by the simpler notation lc(u).
For example, lc(3 xy2+5x2y+7x2y3+9,x)=5y+7y3.
234 6. Structure of Polynomials and Rational Expressions
Definition 6.29. Letube aGPE inx. The operator
Leading
 coeﬃcient
 gpe(u,x)
returns lc(u,x).I fuis not a GPE inx, the operator returns Undeﬁned .
Leading
 coeﬃcient
 gpecan be obtained by composition of the operators
Degree
 gpeandCoeﬃcient
 gpeor directly with procedures similar to those
forDegree
 gpe(Exercise 11).
An Appraisal of the GPE
General polynomial expressions have been deﬁned so that many expres-
sions that are clearly polynomials are included in the deﬁnition and many
expressions that are not are excluded. In addition, the primitive oper-
ators associated with the deﬁnition work well in most contexts where itis necessary to examine the polynomial structure of an expression. Since
some computer algebra systems have similar operators, the deﬁnitions are
a good starting point to evaluate and compare the polynomial capacity of
CAS software (Exercise 1).
However, the deﬁnition has some limitations. The limitations are asso-
ciated with the restricted notion of coeﬃcient independence as expressed
by the Free
ofoperator in Equation ( 6.6) and are magniﬁed by the simpliﬁ-
cation context of automatic simpliﬁcation in which the operators perform.
The following examples illustrate these points.
Example 6.30. Consider the following operations:
Polynomial
 gpe(x(x2+1 ),x)→false, (6.12)
Polynomial
 gpe(y2(y4+1 ),y2)→true. (6.13)
In Expression ( 6.12), the Polynomial
 gpeoperator concludes that the ex-
pression is not a polynomial in x. In this instance the coeﬃcient of x(the
expression x2+ 1) is not free of x. Expression ( 6.13) is obtained from
Expression ( 6.12) with the structural substitution x=y2.In t h i s c a s e ,
however, the expression is a polynomial in y2. This follows because y2is
not a complete sub-expression of y4+1w h i c hm e a n st h a t y4+ 1 can act
as a coeﬃcient of y2. The problem here has to do with the limited view
of the coeﬃcient part of a monomial which is based on the actions of the
Free
ofoperator together with the actions of automatic simpliﬁcation. /square
6.2. General Polynomial Expressions 235
Example 6.31. Consider the expression u=a(x2+1 )2+(x2+1 )w h i c h
we want to consider as a polynomial in x2+ 1. However,
Polynomial
 gpe(u, x2+1 )→true, (6.14)
Degree
 gpe(u, x2+1 )→2, (6.15)
Coeﬃcient
 gpe(u, x2+1,1)→0, (6.16)
Coeﬃcient
 gpe(u, x2+1,0)→x2+1. (6.17)
In this case the simpliﬁed form of uis
a(x2+1 )2+x2+1. (6.18)
At this point the expression is still a GPEinx2+1w i t hd e g r e e2( E x -
pressions ( 6.14)a n d( 6.15)), although some of its polynomial structure has
been changed (Expressions ( 6.16)a n d( 6.17)). The problem here is the
sum on the right in Expression ( 6.18)x2+ 1 is no longer a complete sub-
expression of the entire polynomial. Since both x2and 1 are free of x2+1,
they are relegated to the role of a coeﬃcient even though the expression u
is a polynomial in the complete sub-expression x2+1 . /square
Example 6.32. Consider the expression u=2(x2)2+3(x2) and consider
the operations:
Polynomial
 gpe(u, x2)→true,
Degree
 gpe(u, x2)→1,
Coeﬃcient
 gpe(u, x2,2)→0,
Coeﬃcient
 gpe(u, x2,1)→3,
Coeﬃcient
 gpe(u, x2,0)→2x4. (6.19)
Automatic simpliﬁcation transforms uto 2x4+3x2which is still a poly-
nomial in x2, but now the degree is 1, and the polynomial structure has
been changed. Indeed, since x4is free ofx2it is considered a coeﬃcient
part in Expression ( 6.19). /square
What can we conclude from these examples? First, the deﬁnition works
best when the generalized variables are symbols, function forms or facto-rials. When the generalized variables are restricted to expressions of this
type, general polynomial expressions are similar to multivariate polynomi-
als with coeﬃcients that are more involved expressions.
The deﬁnitions are less reliable, however, when a generalized variable is
a sum because the polynomial structure of the expression may be altered
236 6. Structure of Polynomials and Rational Expressions
by automatic simpliﬁcation (see Example 6.31). One solution, of course, is
simply to modify the GPEdeﬁnition so that a generalized variable cannot
be a sum. We have resisted doing this because the current deﬁnition is use-
ful for deﬁning the actions of the Algebraic
 expand operator in Section 6.4.
The situation is even more discouraging when a generalized variable is
a power (see Example 6.32above) or a product (Exercise 2). Although, we
rarely get satisfactory results in these cases, we have included them in thedeﬁnition because there are a few instances when the primitive operators
described here give satisfactory results.
Extensions of the Basic Definitions and Procedures
There are a number of ways that we can remove some of the limitations
of our polynomial model. First, we could restrict the class of generalized
variables to expressions that are in the set Variables (u). It is noteworthy
that the set Variables (u) never contains a product or a power with integer
exponent ≥2, although it can contain a sum. Another possibility is to
extend the capabilities of the operators by performing a more involved
analysis of an expression. (For a more detailed discussion of this extension,
consult Cohen [ 24], Sections 4.1 and 6.2.)
There are two other extensions of the polynomial model that require
only minor modiﬁcations to the deﬁnitions and basic procedures. One pos-sibility is to allow generalized variables to have negative integer exponents
even though this is not ordinarily done in mathematical deﬁnitions for poly-
nomials. For example, when this is done the expression 2 /x+3/x
2is a
polynomial with deg(u)=−1. When negative exponents are allowed, it
is also useful to deﬁne the operation low
 deg(u,x) that returns the lowest
power ofxin the expression. For example, low
 deg(2/x+3/x2,x)=−2.
A particularly useful modiﬁcation of the model is to drop the indepen-
dence Free
ofcondition GME-1 in Deﬁnition 6.16. When this is done an
expression such as ( x+1 )x2+l n (x)x+s i n (x) is a polynomial in xeven
though the coeﬃcients x+1,l n (x), and sin( x) are not free of x. Although
this modiﬁcation causes expressions to lose some of their polynomial struc-ture, it does allow the degree and coeﬃcient operations to be applied in
some useful situations. The deﬁnitions and procedures for the basic oper-
ators for this model are described in Exercise 12.
Exercises
1. In thisexercise weask youtoexplorethepolynomial capabilities ofa CAS.
For a CAS, consider its versions of MPL’s Polynomial
gpe,Degree
gpeand
Coeﬃcient
gpeoperators.
6.2. General Polynomial Expressions 237
(a) In Maple consider the typecommand with polynomoption, and the
degreeand coeffoperators.
(b) In Mathematica consider the operators PolynomialQ ,Exponent,a n d
Coefficient .
(c) InMuPADconsiderthe typeoperator withthe PolyExpr option, and
thedegreeand coeffoperators.
Consider the following questions.
(a) Does the polynomial model in a CAS employ the same coeﬃcient
independence condition as the MPL model?
(b) Are sums, products, or powers permitted as generalized variables?
(c) Are negative integer exponents permitted in the polynomial model?
(d) Is expansion part of the simpliﬁcation context?
(e) Does the model extend the MPL model in signiﬁcant way?
2. Explain why it is usually not meaningful to view an expression uas a
polynomial in terms of an expression vthat is a product.
3. Let ubeandalgebraic expression andlet Sbeasetofgeneralizedvariables.
Give a procedure
Coeﬀ
var
monomial (u,S)
that returns a two element list with the coeﬃcient part andvariable part
ofu.I fuis not aGMEinS, the procedure returns the global symbol
Undeﬁned . (This procedure is used in the Collect
termsprocedure (see
Figure6.9on page249).)
4. Give a procedure
Bilinear
form(u,x,y)
thatreturns truewhen analgebraic expression uhas theform ax+by+c,
where xandyare symbols and a,b,a n d care free of xandy.I fu
does not have this form, return false. Interpret the form broadly to allow
2x+cx+3y+dy+4 to be in this form.
5. What is returned by the Variables operator, and what is the total degree
for each of the following?
(a) (x+1)(x+2)+( x+3).
(b)(x+1)2
(1−x)2.
(c)x2
a2+x
a+b.
(d)xm+sin(x)x+1/(xy).
6. Let ube analgebraic expression . Give a procedure for Variables(u).
238 6. Structure of Polynomials and Rational Expressions
7. Suppose an algebraic expression uis viewed as a GPEinVa r i a b l e s (u).
Explain why the coeﬃcient part of a monomial in umust be an integer or
af r a c t i o n .
8. Let ube analgebraic expression ,a n dl e t vbe ageneralized variable or a
set ofgeneralized variables . In this exercise we ask youto give procedu res
to compute deg(u,v) (see Deﬁnition 6.23). First, give a procedure
Degree
monomial
gpe(u,v)
thatﬁndsthedegree ofamonomial andthenaprocedure Degree
gpe(u,v).
9. Let ube analgebraic expression . Give a procedure Total
degree(u)t h a t
returns the total degree of u. To make the exercise interesting, do not use
theDegree
gpeorVariables operators.
10. Let ube a multivariate polynomial in xandywith rational number co-
eﬃcients. The polynomial is called a homogeneous polynomial if every
monomial term has the same total degree. For example, the polynomial
u=x2+2xy+y2is homogeneous. Give a procedure
Homogeneous
 polynomial (u,x,y)
that returns trueifuis homogeneous in xandyandfalseotherwise.
11. Let ube analgebraic expression ,a n dl e t xbe ageneralized variable .
(a) Give a procedure for Leading
coeﬃcient
gpe(u,x)t h a td o e sn o tus e
theDegree
gpeorCoeﬃcient
gpeoperators. If uis not aGPEinx,
return the global symbol Undeﬁned .
(b) Give a procedure Leading
coeﬀ
degree
gpe(u,x) that returns the list
[lc(u,x),deg(u,x)].
Ifuis not aGPEinx, return the global symbol Undeﬁned .D on o t
use theDegree
gpeorCoeﬃcient
gpeoperators in this exercise.
12. Let xbe a symbol. In this exercise we give an alternate deﬁnition of a
polynomial that does not require the coeﬃcients of powers of xto be free
ofx.
Analgebraic expression uis analternate general monomial expres-
sioninxif it satisﬁes one of the following rules.
GMEALT-1. u=x.
GMEALT-2. u=xnwhere n>1 is an integer.
GMEALT-3. uis a product, and each operand of uis either a sum or
satisﬁes one of the rules GMEALT-1, GMEALT-2, or GMEALT-4.
GMEALT-4. uis analgebraic expression that is not sum and does not
satisfy rules GMEALT-1, GMEALT-2, or GMEALT-3.
6.2. General Polynomial Expressions 239
Rules GMEALT-1 and GMEALT-2 give monomials of positive degree, and
rule GMEALT-3 gives a monomial of positive degree if oneof theoperands
satisﬁes GMEALT-1 or GMEALT-2 and otherwise has degree 0. Rule
GMEALT-4 gives monomials with degree 0 in xsuch as
2,3/2,a2,sin(x),1/(x+1).
In addition, according to this rule a sum is not a monomial of degree 0.
On the other hand, in GMEALT-3 a sum is allowed as an operand in a
product that is a monomial. This means that the following are monomials
inx:
(a+1)x2,(x+1)x2,(x+1)(x+2),(x+1)2,
where the ﬁrst two expressions have degree 2 in xand the last two expres-
sions have degree 0.
Analgebraicexpression uisalternate general polynomial expression
inxif it satisﬁes one of the rules:
GPEALT-1. uis an alternate general monomial expression in x.
GPEALT-2. uis a sum, and each operand of uis an alternate general
monomial expression in x.
With this deﬁnition
u=x2
x+1+sin(x)x+c
is a polynomial in xand operations such as deg(u,x)=2 are well deﬁned.
Give procedures
Degree
alternate(u,x),Coeﬃcient
alternate(u,x,j)
that obtain the degree and coeﬃcient operations in this context.
13. Let ube analgebraic expression ,a n dl e t xbe a symbol. In this exercise
we extend the basic deﬁnitions for monomials and polynomials so thatexponents of xcan be any algebraic expressions that are free of x.F o r
example, in this context the expression
u=x
m+1+3xn+4x3+5x+6x−1
is a polynomial in x. Give a procedure Degree
general(u,x) that obtains
the degree of these polynomial expressions. If uis not a polynomial in this
sense (e.g., xx), then return the global symbol Undeﬁned .F o rt h ea b o v e
polynomial u,
Degree
 general(u,x)→Max({m+1,n ,3}).
In other words, in instances where Degree
 generalis unable to actually
ﬁnd the maximum, an unevaluated Maxfunction form is returned. A
240 6. Structure of Polynomials and Rational Expressions
version ofMaxthat obtains this operation is described in Exercise 16on
page198.
The Mathematica Exponent operator performs an operation similar to the
one described here.
14. The ﬁrst step in the Solve
odealgorithm (see Figure 4.16on page162)
transforms a diﬀerential equation to the form
M+Ndy
dx=0. (6.20)
This operation is performed by the Transform
odeprocedure which re-
turns a list [ M,N]. TheTransform
odeassumes that the equation can be
transformed to this form but does not check that this is so. Modify the
Transform
odeprocedure so that it checks that the transformed equation
has the form of Equation ( 6.20), where MandNdo not contain the func-
tion form named d, and when this is so returns [ M,N]. If the expression
cannot be transformed to this form, return the symbol Fail. For example,
Transform
ode(x2=d(y,x)+y,x,y)→[x2−y,−1],
Transform
ode(x2=d(y,x,2),x,y)→Fail.
The procedures described in this section and the Derivative
orderproce-
dure (see Exercise 15on page197) are useful for this problem.
15. (a) Alineardiﬀerential operator is an expression of the form
andny
dxn+an−1dn−1y
dxn−1+···+a1dy
dx+a0y+f
where aiandfarealgebraic expressions that are free of y.L e tube
analgebraic expression . Give a procedure
Linear
derivative
order(u, x, y)
that determines if uis a linear diﬀerential operator and, when this is
so, returns the order of the highest derivative of yinu.I fuis linear
inybutcontains noneof its derivatives, theprocedure returns0. If u
does not contain yor its derivatives, the procedure returns −1. Ifu
is not a linear diﬀerential operator, the procedure returns the globalsymbol Undeﬁned .A si nS e c t i o n 4.3, represent the derivative
dy
dx
with the function notation d(y, x) and higher order derivatives
dny
dxn
6.2. General Polynomial Expressions 241
withd(y, x, n). To simplify matters, if ucontains any function forms
with the name dthat contain operands diﬀerent from those in d(y,x)
andd(y,x,n), return the symbol Undeﬁned . For example,
Linear
derivative
order(d(y,x,2)+2x, x, y)→2,
Linear
derivative
order(2y+3x, x, y)→0,
Linear
derivative
order(2x+3,x ,y)→−1,
Linear
derivative
order(d(y,x)+y2,x ,y)→Undeﬁned ,
Linear
derivative
order(d(b),x ,y)→Undeﬁned .
(b) In Exercise 7, page169we describe a procedure Solve
ode
2(a,b,c,f)
that obtains a solution to the diﬀerential equation
ad2y
dx2+bdy
dx+cy=f, (6.21)
where a,b,andcarerationalnumbersand fisanalgebraic expression
that is free of y. Give a procedure Transform
ode
2(w,x,y)t h a td e -
terminesifanequation wcan betransformed totheformofEquation
(6.21) by rational simpliﬁcation and if so returns the list [ a,b,c,f]. If
wcannot be transformed to this form, then return Fail.Hint:This
procedure is similar to the procedure Transform
odein Exercise 14
above. For example,
Transform
ode
2(2d(y,x,2)+3 y=x2,x ,y)→[2,0,3,x2],
Transform
ode
2Wx2
d(y,x,2)−3=0,x ,y}
→[−3,0,0,−x2],
Transform
ode
2(xd(y,x,2)+3 y=x2,x ,y)→Fail.
16. A diﬀerential equation that has the form
dy
dx=Py+Qyn(6.22)
where P/negationslash=0a nd Q/negationslash=0a ref re eo f yandn/negationslash=1i sf re eo f xandyis called
aBernoulli equation. For example
dy
dx=y+xy3
is a Bernoulli equation. This equation is solved by deﬁning a new variable
z=y1−n(6.23)
that transforms the equation to
1
1−ndz
dx=Pz+Q. (6.24)
Oncewesolvethisequation,weobtainthesolution toEquation( 6.22)with
the substitution in Expression ( 6.23).
242 6. Structure of Polynomials and Rational Expressions
(a) Show that Equation ( 6.24) can be solved using the algorithm in Sec-
tion4.3.
(b) Give a procedure Bernoulli(u,x,y) that tries to determine if a dif-
ferential equation uis a Bernoulli equation and if so uses the proce-
dureSolve
ode(see Figure 4.16on page162) to ﬁnd the solution to
Equation ( 6.24) and then obtains the solution in terms of ywith the
substitution in Expression ( 6.23).
6.3 Relationships Between Generalized Variables4
In this section we state and prove a number of mathematical properties of
theFree
ofoperator and use these properties to investigate the indepen-
dence of generalized variables.
Mathematical Properties of the Free
 ofOperator
Theorem 6.33. Letu,v,a n dwbe mathematical expressions.
1. Ifu/negationslash=v,t h e n (Free
of(u,v)orFree
of(v,u))→true.
2.(TransitiveProperty) IfFree
of(u,v)→false andFree
of(v,w)→
false,t h e n Free
of(u,w)→false.
Proof: Both statements are easily proved. To show (1), if Free
of(u,v)
andFree
of(v,u)a r eb o t hfalse,t h e nvis a complete sub-expression of u,
anduis a complete sub-expression of v. The only way this can happen is
foru=v. However, u/negationslash=v, and so either Free
of(u,v)o rFree
of(v,u)m u s t
betrue. (Of course, both can be true.)
To show (2), the hypothesis states that vis a complete sub-expression
ofu,a n dwis a complete sub-expression of v. Therefore, wis a complete
sub-expression of uandFree
of(u,w)→false. /square
The next theorem extends Theorem 6.33( 1 )t oas e t Sof expressions.
Theorem 6.34. LetS={x1,x2,...,x m}be a set of mathematical expres-
sions (with m≥2).T h e n ,t h e r ei sa n xjinSsuch that
Free
of(xk,xj)→true,fork=1,2,...,j −1,j+1,...,m.
4This section is more theoretical than the previous sections.
6.3. Relationships Between Generalized Variables 243
Proof: The theorem is proved with mathematical induction. First, for
the base case m= 2, the theorem follows from Theorem 6.33(1). Next,
suppose the theorem is trueforS∼{xm}. This implies that there is an
xj,w i t h1 ≤j≤m−1, such that
Free
of(xk,xj)→true,fork=1,2,...,j −1,j+1,...,m −1.(6.25)
To show that the theorem holds for S, we consider the two cases where
Free
of(xm,xj)i se i t h e rtrueorfalse. In the ﬁrst case, Free
of(xm,xj)i s
true, and this assumption, together with the induction hypothesis ( 6.25),
implies that xjsatisﬁes the theorem for Sas well.
For the second case, we assume that
Free
of(xm,xj)→false, (6.26)
and show that xmsatisﬁes the conclusion of the theorem. First, Theorem
6.33(1) applied to Expression ( 6.26) implies that
Free
of(xj,xm)→true. (6.27)
To complete the proof we must show that
Free
of(xk,xm)→true,fork=1,2,...,j −1,j+1,...,m −1.(6.28)
However, if for some k,Free
of(xk,xm)w e r efalse, then this fact, together
with Expression ( 6.26), would imply that Free
of(xk,xj)i sfalsewhich
contradicts the induction hypothesis ( 6.25). Therefore, ( 6.28), together
with (6.27), shows that xmsatisﬁes the conclusion of the theorem. /square
Example 6.35. Ifx1=s i n (x),x2=l n ( s i n (x)), andx3=x,t h e nj=2a n d
Free
of(x1,x2)= Free
of(sin(x),ln(sin(x)))→true,
Free
of(x3,x2)= Free
of(x,ln(sin(x)))→true. /square
Theorem 6.36. LetS={x1,x2,...,x m}be a set of (distinct) mathematical
expressions. Then, there is a permutation (reordering) of S,
[xj1,xj2,...,x jm]
such that (for i<m )
Free
of(xk,xji)→true,fork=ji+1,...,j m.
244 6. Structure of Polynomials and Rational Expressions
The involved notation makes the theorem seem more complicated than
it is. It simply states that we can rearrange the expressions in Sinto a list
so that any expression in the list is free of all expressions that precede it
in the list.
Proof: [Theorem 6.36 ]Let the ﬁrst expression in the list xj1be the expres-
sion described in the conclusion of Theorem 6.34. Then all expressions xk
inS∼{xj1}satisfy the property Free
of(xk,xj1)→true. In general, de-
ﬁnexjito be the expression from the set S∼{xj1,...,x ji−1}that satisﬁes
the conclusion of Theorem 6.34. /square
Example 6.37. Supposex1=s i n (x),x2=x,a n dx3= ln(sin(x)). A re-
ordering that satisﬁes the conclusion of the theorem is i1=3,i2=1,i3=2
or
[ln(sin(x)),sin(x),x].
Ino t h e rw o r d s
Free
of(xi2,xi1)= Free
of(sin(x),ln(sin(x)))→true,
Free
of(xi3,xi1)= Free
of(x,ln(sin(x)))→true,
Free
of(xi3,xi2)= Free
of(x,sin(x))→true./square
InE x e r c i s e 2we describe a procedure that ﬁnds the permutation of the
expressions guaranteed by Theorem 6.36.
Relationships Between Generalized Variables
Although the deﬁnition of a GPErequires the coeﬃcients cibe independent
of the generalized variables xj, it does not require the generalized variables
be independent of each other. For example, the expression
2x(ln(x))2+3x2ln(x) + 4 (6.29)
is a polynomial in {x,ln(x)}, even though the two expressions are not
independent (e.g., ln( x) depends on x). When a dependence relationship
like this exists, it is not possible to view the expression as a polynomialin one of the generalized variables. For example, although the expression
(6.29) is a polynomial in {x,ln(x)}and in ln(x) alone, it is not a polynomial
inxalone. In this regard, we have the following two theorems.
Theorem 6.38. Ifuis aGPE in each of the expressions x1,x2,...,x m
individually, then it is also a GPE in{x1,x2,...,x m}.
6.3. Relationships Between Generalized Variables 245
Theorem 6.39. Supposeuis aGPE inS={x1,x2,...,x m}, and suppose
that for some j
Free
of(xk,xj)→true, k =1,2,...,m, k /negationslash=j.
Thenuis aGPE inxjalone.
The proofs of the theorems are left to the reader (Exercises 4and5).
However, if uis a polynomial in a set of expressions, then it must also
be a polynomial in at least one of the generalized variables.
Theorem 6.40. Letube aGPE in the expressions S={x1,x2,...,x m}.
Thenuis also a GPE in somexj.
Proof: This theorem follows from Theorem 6.34and Theorem 6.39./square
Sometimes it is useful to replace the generalized variables in an expres-
sion by symbols. This can be done with concurrent substitution. Let ube a
GPEinS={x1,x2,...,x m}and lety1,y2,...,y mbe unassigned symbols.
The substitution
Concurrent
 substitute (u,[x1=y1,x2=y2,...,x m=ym])
creates a multivariate polynomial with each generalized variable xireplaced
by a symbol yi.
With sequential substitution, however, we may not obtain the intended
substitution. This point is illustrated in the next example.
Example 6.41. Consider the expression u=ssin(s) ln(sin(s)) as a poly-
nomial in S={s,sin(s),ln(sin(s))}. We obtain a multivariate polynomial
with the substitutions
Sequential
 substitute (u,[x=l n ( s i n (s)),y=s i n (s),z=s])→zyx.
On the other hand, if the order of substitutions is
Sequential
 substitute (u,[y=s i n (s),z=s, x= ln(sin(s))])→zyln(y),
we don’t eliminate all generalized variables. /square
However, Theorem 6.36implies that we can ﬁnd a re-ordering of the
generalized variables [ xj1,xj2,...,x jm] so that the substitution
Sequential
 substitute (u,[xj1=y1,xj2=y2,...,x jm=ym])
246 6. Structure of Polynomials and Rational Expressions
creates a multivariate polynomial with each generalized variable xjire-
placed by a symbol yi.
By substituting symbols for generalized variables, we alter some of the
polynomial structure of an expression. For example, the new expressionwill be a GPEin eachy
jindividually even though the original polynomial
may not be a GPEin terms of each of the generalized variables.
Exercises
1. Suppose
Free
of(u,v)→true,Free
of(v,w)→true.
Does this imply that Free
of(u,w)→true?
2. Let S={x1,x2,...,x m}be a set of (distinct) mathematical expressions.
Giveaprocedure Free
of
sort(S)thatreturnsthelistofre-orderedexpres-
sions described in Theorem 6.36.Hint:Any elementary sorting algorithm
(insertion sort, bubble sort, selection sort) will do where vprecedes uin
the list ifFree
of(u,v)→true.
3. Let Sbe a set of symbols, and suppose uis aGPEinS. Show that uis a
polynomial in each member of S.
4. Prove Theorem 6.38.
5. Prove Theorem 6.39.
6. Let ube an algebraic expression, and consider uas aGPEinVariables(u).
Give a procedure GPE
to
mult(u) that transforms uto a multivariate
polynomial. Note:This problem requires an arbitrary number of variable
names. The CAS must have the capability to generate variable names5or
provide subscripted variables.
7. (a) Let Lbe a list of symbols and let ube a multivariate polynomial in
the symbols of Lwith rational number coeﬃcients. The operator
Leading
numer
coeﬀ(u,L)
obtains the leading numerical coeﬃcient of an expression which is
deﬁned using the following rules.
LNC-1. IfL=[] ,the n
Leading
numer
coeﬀ(u,L)→u.
LNC-2. Letx=First(L,1) and l=Leading
coeﬃcient
gpe(u,x).
Then,
Leading
numer
coeﬀ(u,L)→Leading
numer
coeﬀ(l,Rest(L)).(6.30)
5For example, in Mathematica the Unique command creates symbol names, or in
Maple the catcommand concatenates variable names and integer values. (Implementa-
tion: Maple (mws), Mathematica (nb).)
6.4. Manipulation of General Polynomial Expressions 247
For example,
Leading
numer
coeﬀ(2x2y+3xy2,[x,y])→2,
Leading
numer
coeﬀ(2x2y+3xy2,[y,x])→3.
Notice that the leading numerical coeﬃcient depends on the order of
the symbols in L. Give a procedure for Leading
numer
coeﬀ(u,L).
(b) Let s=Leading
numer
coeﬀ(u,L). If u/negationslash= 0, deﬁne the polyno-
mial sign ofuwith respect to Las the sign (1 or −1) ofs.I n
addition deﬁne the polynomial sign of 0 as 0. Give a procedure for
Polynomial
sign(u,L) that returns the polynomial sign.
(c) Give a procedure Polynomial
sign
var(u) which obtains the polyno-
mial sign of uwith respect to the expressions in Variables(u). For
this operation it is necessary to replace the generalized variables in u
with symbols because the coeﬃcient computation in ( 6.30)m a yc r e -
atenewgeneralized variables(Exercise 6). Forexample, thishappens
withu=−c∗(x+y) which has the generalized variables candx+y.
However, by automatic simpliﬁcation the coeﬃcient of cis−x−y
which has two new generalized variables xandy.
Since the polynomial sign depends on the order of the expressions in
thesetVariables(u),it isusefultocreatealist of thegeneralized vari-
ables in a standard order. (Formore information on an orderrelation
that can be used for this purpose, consult Cohen [ 24], Section 3.1.)
8. Suppose that uis aGPEinS={x1,x2,...,x m},a n dl e t n1,...n mbe
non-negative integers.
(a) Explain why it is always possible to obtain the coeﬃcient of
xn1
1xn2
2···xnm
m
using a composition of Coeﬃcient
gpeoperators.
(b) Give a procedure Coeﬃcient
vars(u,L)w h e r e
L=[ [x1,n1],[x2,n2],...,[xm,nm]]
that implements the statement in part (a).
6.4 Manipulation of General Polynomial Expressions
In this section we describe two operators that manipulate general polyno-
mial expressions. Both of the operators are based on the two distributive
transformations:
a(b+c)=ab+ac, (a+b)c=ac+bc. (6.31)
248 6. Structure of Polynomials and Rational Expressions
TheCollect
 terms Operator
The collection of coeﬃcients of like terms in a polynomial occurs frequently
in algebraic manipulation. During automatic simpliﬁcation this operation
is applied only to monomials with coeﬃcient parts that are rational num-
bers. The collection of (rational and non-rational) coeﬃcients is obtained
with the Collect
 terms operator. The goal of this operator is given in the
next deﬁnition.
Definition 6.42. Analgebraic expression uis incollected form in a set
Sofgeneralized variables if it satisﬁes one of the following properties:
1.uis aGME inS.
2.uis a sum of GMEsinSwith distinct variable parts .
The deﬁnition is similar to Deﬁnition 6.16for general polynomial ex-
pressions (page 225), except now property (2) requires that the variable
parts be distinct.
Example 6.43. The expression
(2a+3b)xy+( 4a+5b)x (6.32)
is in collected form in S={x, y}, where the two distinct variable parts are
xyandx. On the other hand, the expanded form of Expression ( 6.32)
2axy+3bxy+4ax+5bx (6.33)
is not in collected form (in S) because there are two monomials with vari-
able partxyand two with variable part x.
The collected form depends, of course, on which expressions are taken
as the generalized variables. For example, if S={a,b}, the collected form
of Expression ( 6.33)i s( 2xy+4x)a+(3xy+5x)b.IfS={a,b,c,d,x,y },
then Expression ( 6.33) is already in collected form because the four mono-
mials in the sum have distinct variable parts. /square
Example 6.44. Strictly speaking, automatic simpliﬁcation prevents the
transformation of some expressions to collected form. For example, whenS={x}, the collected form of ax+bx+c+dis (a+b)x+(c+d).
However, the automatic simpliﬁcation rules remove the parentheses from
(c+d), giving two monomials canddwith variable part the integer 1. Given
that our procedures operate within the context of automatic simpliﬁcation,
this situation is unavoidable. /square
6.4. Manipulation of General Polynomial Expressions 249
Procedure Collect
terms(u,S);
Input
u:a nalgebraic expression ;
S: a non-empty set of generalized variables ;
Output
the collected form of uor the global symbol Undeﬁned ifuis
not aGPEinS;
Local Variables
f,combined ,i,j,N,T,v ;
Begin
1 ifKind(u)/negationslash=”+” then
2 ifCoeﬀ
var
monomial (u,S)=Undeﬁned then
3 Return(Undeﬁned )
4 elseReturn(u)
5 else
6 ifu∈SthenReturn(u);
7 N:= 0;
8 fori:= 1toNumber
of
operands(u)do
9 f:=Coeﬀ
var
monomial (Operand(u,i),S);
10 iff=Undeﬁned then Return(Undeﬁned )
11 else
12 j:= 1;
13 combined :=false;
14 while notcombined andj≤Ndo
15 ifOperand(f,2) =Operand(T[j],2)then
16 T[j]: =[Operand(f,1)+Operand(T[j],1),Operand(f,2)];
17 combined :=true;
18 j:=j+1;
19 ifnotcombined then
20 T[N+1]:= f;
21 N:=N+1;
22 v:= 0;
23 forj:= 1toNdo
24 v:=v+Operand(T[j],1)∗Operand(T[j],2);
25Return(v)
End
Figure 6.9. An MPL procedure that transforms an algebraic expression to col-
lected form. (Implementation: Maple(txt),Mathematica (txt),MuPAD(txt).)
A procedure Collect
 terms that obtains a collected form is given in
Figure 6.9. The procedure returns either a collected form or the symbol
Undeﬁned whenuis not a GPEinS.
250 6. Structure of Polynomials and Rational Expressions
This procedure uses an array Tthat keeps track of the coeﬃcients of
the various monomials. Most computer algebra languages allow arrays to
be used in this way. In addition, at lines 2 and 9, the procedure uses the
operator Coeﬀ
 var
monomial (u,S) which is described in Exercise 3, page
237.W h e nuis aGME inS, this operator returns a two element list with
the coeﬃcient and variable parts of uand otherwise returns the symbol
Undeﬁned .
Collect
 terms begins (lines 1-5) by checking if an expression u,w h i c hi s
not a sum, is a monomial and when this is so, returns uwhich is in collected
form (Deﬁnition 6.42(1)). The remainder of the procedure applies to sums.
At line 6 we check if the sum uis inS, which means it is in collected
form. In lines 7-21, we create an array Twith entries that are two operand
lists that contain the coeﬃcient and distinct variable parts obtained so far.For each operand of u, we obtain, at line 9, a list fwith its coeﬃcient
and variable parts, and then check if the variable part corresponds to the
variable part of some earlier operand of uthat is in T(lines 12-18). If the
variable part of fcorresponds to an earlier variable part, the appropriate
element of Tis reassigned (line 16), and combined is assigned the symbol
true, which terminates the while loop. If the variable part of fdoes not
correspond to the variable part of some T[j], for 1 ≤j≤N, it is added
to the array T(lines 19-21). Finally, in lines 22-24, we use Tto create the
new expression vthat is the collected form.
Observe that Deﬁnition 6.42andCollect
terms require that ube a poly-
nomial in S. This means, for u=ax+s i n (x)x+b, the operator is unable
to collect coeﬃcients in xbecause the expression is not even a polynomial
inx. We can avoid the limitation by eliminating the free-of tests from the
procedure Coeﬀ
 var
monomial that is called in lines 2 and 10. We leave
these modiﬁcations to the reader (Exercise 3).
TheAlgebraic
 expand Operator
Ina na l g e b r a i cs e n s e ,t h e Algebraic
 expand operator applies the two dis-
tributive transformations in ( 6.31) in a left to right fashion to products
and powers that contain sums. With these transformations, the operator
obtains manipulations such as:
(x+2 )(x+3 )(x+4 ) →x3+9x2+2 6x+2 4, (6.34)
(x+y+z)3→x3+y3+z3+3x2y+3x2z+3y2x
+3y2z+3z2x+3z2y+6xyz,(6.35)
(x+1 )2+(y+1 )2→x2+2x+y2+2y+2, (6.36)
((x+2 )2+3 )2→x4+8x3+3 0x2+5 6x+4 9. (6.37)
6.4. Manipulation of General Polynomial Expressions 251
The last two examples show that Algebraic
 expand is recursive.
There are, however, other instances where it is less certain what the
operator should do. For example, should Algebraic
 expand perform the
following manipulations?
a
(x+1 )(x+2 )→a
x2+3x+2, (6.38)
(x+y)3/2→x(x+y)1/2+y(x+y)1/2. (6.39)
The ﬁrst example diﬀers from those above because a denominator contains
a product of sums, while the second example involves non-integer expo-
nents.
The next deﬁnition gives the form of the output of our Algebraic
 expand
operator.
Definition 6.45. Analgebraic expression uis inexpanded form if the
setVariables (u)does not contain a sum.
According to this deﬁnition, the expressions on the left in ( 6.34)-(6.37)
are in unexpanded form, while those on the right are in expanded form.For example,
Variables ((x+2 )(x+3 )(x+4 ) ) →{x+2,x+3,x+4},
while for the expanded form of this expression,
Variables (x
3+9x2+2 6x+ 24) →{x}.
On the other hand, the expressions on the left in ( 6.38)a n d( 6.39)a r e
already in expanded form, and so our Algebraic
 expand operator does not
obtain the manipulations shown for these expressions.
Deﬁnition 6.45only makes sense if it is understood in the context of
automatic simpliﬁcation. Without this context, some expressions that
are obviously not in expanded form satisfy the deﬁnition. For example,
u=/parenleftbig
(x+1 )2/parenrightbig2is certainly not in expanded form, and since automatic
simpliﬁcation obtains the transformation
/parenleftbig
(x+1 )2/parenrightbig2→(x+1 )4, (6.40)
we have Variables (u)={x+1}.On the other hand, without the trans-
formation in ( 6.40),Variables (u)={(x+1 )2}, which does not contain a
sum.
252 6. Structure of Polynomials and Rational Expressions
The Integer Exponent Case. We describe ﬁrst a simpliﬁed version of the
Algebraic
 expand algorithm which applies to algebraic expressions uwith
the restriction that all powers in uhave integer exponents.
Procedures for expansion in this setting are given in Figures 6.10and
6.11. The procedure Algebraic
 expand (u) ﬁrst recursively expands the
operands of sums, products, and powers with positive integer exponents
(lines 3, 6, and 11), and then calls on Expand
 product andExpand
 power
to apply the distributive laws to products and powers (lines 6 and 11). Line
12 is invoked when uis not a sum, product, or power.
The procedure Expand
 product (r,s), which expands the product of two
expanded expressions, uses a recursive approach to apply the right and left
distributive laws. If ris a sum, it applies the right distributive law (line
3), and if sis a sum, it apples the left distributive law by a recursive call
with the operands interchanged (line 5). (If both randsare sums, both
distributive laws are applied through recursion.) Line 7, which serves asa termination condition for the recursion, applies when neither rnorsis
a sum. The assumption that all exponents are integers is essential here
because without it the output of the procedure may not be in expanded
form (see Expression ( 6.43)b e l o w ) .
The procedure Expand
power(u,n), which expands an expanded ex-
pressionuto an integer power n≥2, is given in Figure 6.11.W h e nuis a
sum, the expanded form is obtained by letting
f=Operand (u,1),r=u−f,
and applying the binomial expansion
un=(f+r)n=n/summationdisplay
k=0/parenleftbigg/parenleftbiggn!
k!(n−k)!fn−k/parenrightbigg
rk/parenrightbigg
.
Observe that the automatically simpliﬁed form of the expression
n!
k!(n−k)!fn−k
is in expanded form. Indeed, fn−kis in expanded form because fis in
expanded form (by recursion), and fis not a sum because it is the operand
of a sum. The assumption that all exponents are integers is used herebecause without it f
n−kmay not be in expanded form (see Expression
(6.45) below). On the other hand, the base of rkc a nb eas u m ,a n ds o
this power must be expanded recursively. This operation is performed in
line 7, where Expand
 product is used to expand the product of these two
expressions.
6.4. Manipulation of General Polynomial Expressions 253
Procedure Algebraic
expand(u);
Input
u:a nalgebraic expression where all exponents of powers are integers;
Output
the expanded form of u;
Local Variables
v,base,exponent;
Begin
1 ifKind(u)=”+” then
2 v:=Operand(u,1);
3Return(Algebraic
expand(v)+Algebraic
expand(u−v))
4 elseifKind(u)=” ∗”then
5 v:=Operand(u,1);
6Return(Expand
product(Algebraic
expand(v),Algebraic
expand(u/v)))
7 elseif Kind(u)=” ∧”then
8base:=Operand(u,1);
9exponent :=Operand(u,2);
10 ifKind(exponent)=integer and exponent ≥2then
11 Return(Expand
power(Algebraic
expand(base),exponent));
12Return(u)
End
Procedure Expand
product(r,s);
Input
r,s : expanded algebraic expressions , where all exponents of powers are
integers;
Output
the expanded form of r∗s;
Local Variables
f;
Begin
1 ifKind(r)=”+” then
2 f:=Operand(r,1);
3Return(Expand
product(f,s)+Expand
product(r−f,s));
4 elseifKind(s)=”+” then
5Return(Expand
product(s,r))
6 else
7Return(r∗s)
End
Figure 6.10. MPL procedures for Algebraic
expandandExpand
product.( I m -
plementation: Maple(txt),Mathematica (txt),MuPAD(txt).)
254 6. Structure of Polynomials and Rational Expressions
Procedure Expand
power(u,n);
Input
u: an expanded algebraic expression where all exponents of powers are
integers;
n: a non-negative integer;
Output
the expanded form of un;
Local Variables
f,r,k,s,c ;
Begin
1 ifKind(u)=”+” then
2 f:=Operand(u,1);
3 r:=u−f;
4 s:= 0;
5 fork:= 0tondo
6 c:=n!/(k!∗(n−k)!);
7 s:=s+Expand
product(c∗fn−k,Expand
power(r,k));
8Return(s)
9 else
10Return(un)
End
Figure 6.11. An MPL procedure for Expand
power. (Implementation: Maple
(txt),Mathematica (txt),MuPAD(txt).)
The Non-integer Exponent Case. Ifucontains powers with non-integer ex-
ponents, the Algebraic
 expand operator may return an expression that is
not in expanded form. To see how this happens, let’s suppose that the
transformations
uvuw=uv+w, (6.41)
(uv)n=unv,n an integer , (6.42)
are applied from left to right during automatic simpliﬁcation6.( T h e t w o
transformations hold for both the real and complex interpretations of the
6In Maple, automatic simpliﬁcation obtains the transformation ( 6.41), whenvand
ware rational numbers, and ( 6.42), whenvis a rational number.
In Mathematica, automatic simpliﬁcation obtains the transformations ( 6.41)a n d
(6.42).
In MuPAD, automatic simpliﬁcation obtains the transformation ( 6.41), when vand
ware rational numbers, and ( 6.42).
For a summary of the power transformations in Maple, Mathematica, and MuPAD,
see Cohen [ 24], Section 3.1.
6.4. Manipulation of General Polynomial Expressions 255
power operation.) In this context, Algebraic
 expand together with the
transformation ( 6.41) obtains
Algebraic
 expand/parenleftBig
(x(y+1 )3/2+1 )(x(y+1 )3/2−1)/parenrightBig
→x2(y+1 )3−1 (6.43)
=x2y3+3x2y2+3x2y+x2−1, (6.44)
and together with the transformation ( 6.42) obtains
Algebraic
 expand/parenleftBig
(x(y+1 )1/2+1 )4/parenrightBig
→x4(y+1 )2+4x3(y+1 )3/2(6.45)
+6x2(y+1 )+4x(y+1 )1/2+1
=x4y2+2x4y+x4+4x3(y+1 )3/2(6.46)
+6x2y+6x2+4x(y+1 )1/2+1.
Algebraic
 expand obtains Expressions ( 6.43)a n d( 6.45), and the expanded
forms are shown in Expressions ( 6.44)a n d( 6.46). In both examples, the
output of Algebraic
 expand is not in expanded form, because in each case
the output of the Variables operator contains the generalized variable y+1.
In the ﬁrst example, the input to Algebraic
 expand is a product, and the
output contains a new product and a new power that are not in expandedform. This situation arises from line 7 in Expand
product whenr=s=
x(y+1 )3/2, and so by the transformation ( 6.41),r∗s=x2(y+1 )3which
is not in expanded form. In the second example, the input is a power, andthe output contains new products and powers that are not in expanded
form. This situation arises from line 7 in Expand
power. For example,
whenf=x(y+1 )1/2andn−k= 4, the transformation ( 6.42) implies
fn−k=x4(y+1 )2which is not in expanded form.
One way to expand an expression u0with non-integer exponents is to
apply a sequence of expansions
u1:=Algebraic
 expand (u0),
u2:=Algebraic
 expand (u1),
...
ui:=Algebraic
 expand (ui−1),
...
where the process stops when ui=ui−1. The problem with this approach
is that it performs unnecessary work by trying to expand parts of an ex-
pression that are already in expanded form. Another approach is to modify
256 6. Structure of Polynomials and Rational Expressions
the algorithm in Figures 6.10and6.11so that new unexpanded products
and powers obtained with Expand
 product andExpand
 power are expanded,
although we must take care to avoid introducing redundant recursion or
inﬁnite recursive loops. We leave the details of this modiﬁcation to thereader (Exercise 9(a)).
Extensions of the
Algebraic
 expand Operator. There are two extensions of
theAlgebraic
 expand operator that obtain manipulations beyond the ex-
panded form described in Deﬁnition 6.45. The ﬁrst extension is based on
theexpand operator in the Macsyma system which returns an expression
with the following properties.
1. Each complete sub-expression of an expression is in expanded form,
2. The denominator of each complete sub-expression in an expression is
in expanded form.
These properties include Deﬁnition 6.45and imply the following expan-
sions:
sin(a(b+c))→sin(ab+ac), (6.47)
a
b(c+d)→a
bc+bd. (6.48)
In each of these examples, the expression on the left satisﬁes Deﬁnition 6.45
because
Variables (sin(a(b+c)))→{sin(a(b+c))},
Variables/parenleftbigga
bc+bd/parenrightbigg
→{a,1/b,1/(c+d)}.
However, in Expression ( 6.47), sin(a(b+c)) has a complete sub-expression
that is not in expanded form, and in Expression ( 6.48), the denominator of
a
b(c+d)
is not in expanded form. An extension of the Algebraic
 expand operator
that obtains these transformations is described in Exercise 8.
The second extension of Algebraic
 expand , which has to do with frac-
tional exponents, is based on the Expand operator in Mathematica. Let
ube an algebraic expression, and let fbe a positive fraction (that is not
an integer). According to Deﬁnition 6.45, the expression ufis in expanded
form. However, another expanded form for ufis obtained by separating f
6.4. Manipulation of General Polynomial Expressions 257
into the sum of an integer and a fraction mwith 0<m< 1. We obtain
this representation with
f=⌊f⌋+m,
where
⌊f⌋= largest integer ≤f, m =f−⌊f⌋.
The function ⌊f⌋is called the ﬂoor function off.W eh a v e
uf=umu⌊f⌋, (6.49)
and obtain an expanded form by expanding u⌊f⌋and multiplying each term
of this expansion by um. For example, with ⌊5/2⌋=2 ,w eh a v e
(x+1 )5/2=(x+1 )1/2(x+1 )2
=(x+1 )1/2x2+2(x+1 )1/2x+(x+1 )1/2.(6.50)
An extension of Expand
 power that obtains this transformation is described
in Exercise 9(b).
Exercises
1. Suppose uis in collected form with respect to a set S.
(a) Is ualso in collected form with respect to a subset of S?
(b) Is each complete sub-expression of ualso in collected form with re-
spect to S?
2. Let ube a sum. A common algebraic operation is to combine terms that
have denominators with the same variable part into a single term. For
example,
a
2bc+d
3bc=a/2+d/3
bc. (6.51)
In this example, both denominators have the variable part bc.G i v eap r o -
cedureCombine(u) that combines terms in a sum uwhose (non-constant)
denominators diﬀer byat most a rational numberfactor into a single term.
Ifuis not a sum, then return u. This exercise requires a Denominator
operator. Most CAS languages have this operator (see Figure 4.1on page
124), and transformation rules for the operator are given in Section 6.5.
Hint:This operation can be performed by the Collect
terms(u,S)p r o c e -
dure with the appropriate generalized variables inS.
3. Let ubeanalgebraic expression ,andlet Sbeasetof generalized variables .
Give a procedure Collect
terms
2(u,S) that collects coeﬃcients in Sbut
doesn’t require that ube aGPEinS. For example,
Collect
terms
2(ax+sin(x)x+b,{x})→(a+sin(x))x+b.
258 6. Structure of Polynomials and Rational Expressions
4. Explore the capacity of the algebraic expand operator in a CAS. How does
it compare with the version of the operator described in this section? (Use
expandin Maple and MuPAD, and Expandin Mathematica.)
5. Let ube analgebraic expression . The operator Distribute (u), which pro-
vides a fast way to apply the distributive transformation, can replaceAlgebraic
expandin some situations. It is deﬁnedusing the following rules.
(a) If uis not a product, then
Distribute (u)→u.
(b) If uis a product, then
i. Ifudoes not have an operand that is a sum, then
Distribute (u)→u.
ii. Suppose uhas an operand that is a sum, and let vbe the ﬁrst
such operand. Form a new sum by multiplying the remaining
operands of uby each operand of v.R e t ur nt h i ss um .
For example,
Distribute (a(b+c)(d+e))→ab(d+e)+ac(d+e),
DistributeWx+y
xy}
→1/y+1/x.
Give a procedure for Distribute (u).
6. Give a procedure Expand
main
op(u) that expands only with respect to
the main operator of u. In other words, the operator does not recursively
expand the operands of sums, products, or powers before it applies the
distributive transformations. For example,
Expand
main
opi
xi
2+(1+ x)2JJ
→2x+x(1+x)2,
Expand
main
opQi
x+(1+ x)2J2w
→x2+2x(1+x)2+(1+ x)4.
7. Let Tbe a set of expressions that are sums. Give procedures for an
operatorExpand
restricted(u,T) which applies the distributive laws as
Algebraic
expanddoes, except that it does not apply the laws to members
ofT. For example, for u=(x+a)2(x+b),
Expand
restricted(u,{x+a})→(x+a)2x+(x+a)2b,
Expand
 restricted (u,{x+b})→(x+b)x2+2a(x+b)x+a2(x+b),
Expand
restricted(u,{x+a,x+b})→(x+a)2(x+b).
6.5. General Rational Expressions 259
8. Let ube analgebraic expression . Modify the expand algorithm so that it
returns anexpression with properties (1) and(2) on page 256.Y o urp r o c e -
dureshould obtain theexpansionsin ( 6.38), (6.47), and(6.48). Sincethese
properties require the expansion of denominators, there is the possibilitythat a denominator expands and simpliﬁes to 0. For example, this occurs
with1
x2+1−x(x+1).
Make sure your procedures check for this situation and return the global
symbol Undeﬁned when it occurs. This exercise requires the Numerator
andDenominator operators. Most CAS languages have these operators
(see Figure 4.1on124), and transformation rules for these operators are
given in Section 6.5.
9. (a) Modify the Algebraic
expandalgorithm so that it obtains the ex-
pandedform whentheinputexpressions includepowers withfractionexponents. Assume that the transformations in ( 6.41)a n d(6.42)a r e
included in automatic simpliﬁcation.
(b) Modifythe Expand
powerprocedureinpart(a)sothatitalso obtains
the expansions using the decomposition of fraction powers in ( 6.49)
and (6.50). Most computer algebra languages have an operator to
compute ⌊N⌋. (InMapleandMuPADuse floor,andinMathematica
useFloor.)
6.5 General Rational Expressions
In a mathematical sense, a rational expression is deﬁned as a quotient of two
polynomials. In this section we discuss the rational expression structure
of an algebraic expression and describe an algorithm that transforms an
expression to a particular rational form.
Definition 6.46. (Mathematical Deﬁnition) LetS={x1,...,x m}be a
set of generalized variables .A n algebraic expression uis ageneral ratio-
nal expression (GRE) in Sif it has the form u=p/q,w h e r epandqare
GPEs inS.
Example 6.47.
x2−x+y
x+4,S ={x},
x2sin(y)−xsin2(y)+2(z+1 )
x+s i n (y),S ={x,sin(y)},
x2+bx+c, S ={x}.
260 6. Structure of Polynomials and Rational Expressions
F o re a c he x a m p l e ,w eh a v eg i v e no n ep o s s i b l ec h o i c ef o r S. Notice that the
deﬁnition is interpreted in a broad sense to include GPEs for which the
denominator is understood to be 1. /square
TheNumerator andDenominator Operators. To determine if an expression
is a GRE, we must deﬁne precisely the numerator and denominator of the
expression. The Numerator andDenominator operators, which are used
for this purpose, are deﬁned by the following transformation rules.
Definition 6.48. Letube an algebraic expression .
ND-1 .I fuis a fraction, then
Numerator (u)→Operand (u,1),
Denominator (u)→Operand (u,2).
ND-2 .S u p p o s e uis a power. If the exponent of uis a negative integer or
a negative fraction, then
Numerator (u)→1,Denominator (u)→u−1,
otherwise
Numerator (u)→u, Denominator (u)→1.
ND-3 .S u p p o s e uis a product and v=Operand (u,1).T h e n
Numerator (u)→Numerator (v)∗Numerator (u/v),
Denominator (u)→Denominator (v)∗Denominator (u/v).
ND-4 .I fudoes not satisfy any of the previous rules, then
Numerator (u)→u, Denominator (u)→1.
Example 6.49. Consider the expression u=( 2/3)x(x+1 )
x+2yn.T h e n
Numerator (u)→2x(x+1 )yn,Denominator (u)→3(x+2 )./square
TheNumerator andDenominator operators are deﬁned in terms of
the tree structure of an expression and are interpreted in the context of
automatic simpliﬁcation. Although the operators are adequate for our
6.5. General Rational Expressions 261
purposes, the next two examples show in some cases they give unusual
results.
Example 6.50. Consider the expression
1
x+1
y.
Certainly, if we transform the expression to
x+y
xy,
it is clear which expression is the numerator and which is the denominator.
The deﬁnition, however, does not include this transformation as part of the
simpliﬁcation context, and so the numerator is
1
x+1
y
and the denominator is 1. /square
Example 6.51. Consider the expression x−r2−4r−5. In this case, the expo-
nent is negative for all real values of r. However, since the exponent of the
expression is not a negative integer or fraction, the numerator is x−r2−4r−5
and the denominator is 1. /square
Modiﬁcations of the Numerator andDenominator operators that ad-
dress the issues in the last two examples are described in Exercise 4.
We give next a deﬁnition of a general rational expression that is more
suitable for computational purposes.
Definition 6.52. (Computational Deﬁnition) LetS={x1,...,x m}
be a set of generalized variables .A n algebraic expression uis ageneral
rational expression (GRE) in SifNumerator (u)andDenominator (u)
areGPEs inS.
TheRational
 gre Operator
Definition 6.53. Letube an algebraic expression ,a n dl e tvbe either a
generalized variable xor a setSofgeneralized variables . The operator
Rational
 gre(u,v)
returnstrue wheneveruis a GRE in {x}orSand otherwise returns false.
The operator is deﬁned by the following transformation rule:
262 6. Structure of Polynomials and Rational Expressions
Rational
 gre(u,v)→
Polynomial
 gpe(Numerator (u),v)andPolynomial
 gpe(Denominator (u),v)
where the Polynomial
 gpe operator is given in Figure 6.6on page 228.
Example 6.54.
Rational
 gre/parenleftbiggx2+1
2x+3,x/parenrightbigg
→true,
Rational
 gre/parenleftbigg1
x+1
y,{x,y}/parenrightbigg
→false. (6.52)
/square
TheRational
 variables Operator. TheRational
 variables operator deﬁnes
a natural set of generalized variables for a rational expression.
Definition 6.55. Letube an algebraic expression . The operator
Rational
 variables (u)
is deﬁned by the transformation rule:
Rational
 variables (u)→
Variables (Numerator (u))∪Variables (Denominator (u)),
where the Variables operator is given in Deﬁnition 6.19on page 227.
Example 6.56.
Rational
 variables/parenleftbigg2x+3y
z+4/parenrightbigg
→{x,y,z },
Rational
 variables/parenleftbigg1
x+1
y/parenrightbigg
→/braceleftbigg1
x,1
y/bracerightbigg
.
There is a natural way to view (2 x+3y)/(z+4 )a sa GREinx,y,a n d
z. On the other hand, 1 /x+1/yis not a GRE in xandy(see Expression
(6.52) )b u tc a nb ev i e w e da sa GREin the two generalized variables 1/x
and 1/y. /square
Rationalization of Algebraic Expressions
The rationalization process, which is based on the transformation that
combines operands in a sum over a common denominator, transforms an
6.5. General Rational Expressions 263
algebraic expression to a form with a more appropriate set of generalized
variables. When the process is applied (in a recursive manner), it obtains
the following transformations:
a
b+c
d→ad+bc
bd,
1+1
1+1/x→2x+1
x+1,
1
/parenleftbigg
1+1
x/parenrightbigg1/2+/parenleftbigg
1+1
x/parenrightbigg3/2
→x2+(x+1 )2
x2/parenleftbiggx+1
x/parenrightbigg1/2. (6.53)
The goal of rationalization is described in the following deﬁnition.
Definition 6.57. Analgebraic expression uis inrationalized form if it
satisﬁes one of the following properties:
1.uis an integer, fraction, symbol, factorial, or function form.
2.uis any other type, and consider uas a rational expression in
S=Rational
 variables (u).
Then,
(a) each expression vinSis in rationalized form with
Denominator (v)=1,
(b) the coeﬃcient part of each of the monomials in Numerator (u)
andDenominator (u)is an integer.
Observe that Rule 2(a) is recursive. As usual, we interpret this deﬁni-
tion in the context of automatic simpliﬁcation.
Some examples will help clarify the deﬁnition.
Example 6.58. The expression a/b+c/dis not in rationalized form because
Rational
 variables (a/b+c/d)→{a,1/b,c,1/d,},
264 6. Structure of Polynomials and Rational Expressions
and so property 2(a) of Deﬁnition 6.57is not satisﬁed. However, ( ad+
bc)/(bd) is in rationalized form because
Rational
 variables/parenleftbiggad+bc
bd/parenrightbigg
→{a,b,c,d },
and the coeﬃcient part of each of the monomials ad,bc,a n dbdis 1.
The expression
1+1
1+1/x
is not in rationalized form because
Rational
 variables/parenleftbigg
1+1
1+1/x/parenrightbigg
→/braceleftbigg1
1+1/x/bracerightbigg
,
and so property 2(a) of Deﬁnition 6.57is not satisﬁed. This expression can
be transformed to2x+1
x+1,
which is in rationalized form because
Rational
 variables/parenleftbigg2x+1
x+1/parenrightbigg
→{x},
and the coeﬃcient parts of all monomials in the numerator and denomina-
tor are integers.
The expression a+b/2 is not in rationalized form because the coeﬃcient
part ofb/2 is not an integer, and so property 2(b) in Deﬁnition 6.57is not
satisﬁed. However, its sum (2 a+b)/2 is in rationalized form. /square
TheRationalize
 expression Operator. The operator
Rationalize
 expression (u)
n transforms an algebraic expression uto an equivalent expression in ra-
tionalized form. The operator is understood to operate in an automatic
simpliﬁcation context that includes the power transformations7
7In Maple, automatic simpliﬁcation obtains the transformation ( 6.54)w h e nvand
ware rational numbers, ( 6.55)w h e nvis a rational number, and ( 6.56).
In Mathematica, automatic simpliﬁcation obtains the transformation ( 6.54), (6.55),
and ( 6.56).
In MuPAD, automatic simpliﬁcation obtains the transformation ( 6.54)w h e nvandw
are rational numbers, ( 6.55), and ( 6.56).
For a summary of power transformation rules in Maple, Mathematica, and MuPAD,
see Cohen [ 24], Section 3.1.
6.5. General Rational Expressions 265
Procedure Rationalize
expression (u);
Input
u:a nalgebraic expression ;
Output
a rationalized form of u;
Local Variables f,g,r;
Begin
1 ifKind(u)=” ∧”then
2ReturnQ
Rationalize
expression (Operand(u,1))Operand (u,2)w
3 elseifKind(u)=” ∗”then
4 f:=Operand(u,1);
5Return(Rationalize
expression (f)∗Rationalize
expression (u/f))
6 elseifKind(u)=”+” then
7 f:=Operand(u,1);
8 g:=Rationalize
expression (f);
9 r:=Rationalize
expression (u−f);
10Return(Rationalize
sum(g,r))
11 else
12Return(u)
End
Procedure Rationalize
sum(u,v);
Input
u,v:algebraic expressions in rationalized form;
Output
analgebraic expression in rationalized form;
Local Variables m,n,r,s;
Begin
1 m:=Numerator (u);
2 r:=Denominator (u);
3 n:=Numerator (v);
4 s:=Denominator (v);
5 ifr=1ands=1then
6Return(u+v)
7 else
8Return(Rationalize
sum(m∗s, n∗r)/(r∗s))
End
Figure 6.12. An MPL algorithm that rationalizes an algebraic expression. (Im-
plementation: Maple(txt),Mathematica (txt),MuPAD(txt).)
266 6. Structure of Polynomials and Rational Expressions
uvuw→uv+w, (6.54)
(uv)n→uvn, (6.55)
(uv)n→unvn, (6.56)
whereu,v,a n dware algebraic expressions and nis an integer. These
transformations hold for both the real and complex interpretations of the
power operation.
Procedures that transform an expression to rationalized form are given
in Figure 6.12. In the main procedure Rationalize
 expression , in lines 1-2 a
power is rationalized by recursively rationalizing its base. For example,
Rationalize
 expression/parenleftbig
(1 + 1/x)2/parenrightbig
→(x+1 )2
x2,
where the transformation is obtained by rationalizing the base 1+1 /xand
then using the transformation ( 6.56). Notice that we rationalize the base
even when the exponent is not an integer because the base may appear with
an integer exponent later in the computation as a result of the rational-ization process (see Example 6.59below). Unfortunately, this means that
some expressions that are already in rationalized form are transformed to
another rationalized form. For example,
Rationalize
expression/parenleftBig
(1 + 1/x)1/2/parenrightBig
→/parenleftbiggx+1
x/parenrightbigg1/2
.
In lines 3-5, a product is rationalized by recursively rationalizing each
of its operands.
In lines 6-10, a sum is rationalized by ﬁrst rationalizing its operands
and then combining the operands over a common denominator (line 10).
The actual sum transformation occurs in the Rationalize
 sumprocedure
that performs the transformation
m/r+n/s→ms+nr
rs. (6.57)
Notice that Rationalize
 sumis recursive (line 8) because the sum in the
numerator of the right side of ( 6.57) may not be in rationalized form (see
Example 6.59below). The termination condition for the recursion is in
lines 5-6. We have separated the computation into two procedures to avoid
some redundant recursion.
Example 6.59. In this example we outline the steps in a rationalization that
requires both the rationalization of powers with non-integer exponents and
the recursive step in Rationalize
 sum. Consider the expression8
8For clarity, we use notation with the quotient operator even though quotients are
transformed to products and powers by automatic simpliﬁcation.
6.5. General Rational Expressions 267
1
/parenleftbigg
1+1
x/parenrightbigg1/2+/parenleftbigg
1+1
x/parenrightbigg3/2
.
Rationalizing the two operands of the sum, we obtain
1
/parenleftbiggx+1
x/parenrightbigg1/2+/parenleftbiggx+1
x/parenrightbigg3/2
.
Applying the sum transformation in ( 6.57) followed by the power transfor-
mations in ( 6.54)a n d( 6.55), we obtain
1+(x+1 )2
x2
/parenleftbiggx+1
x/parenrightbigg1/2,
where the sum in the numerator is not in rationalized form. Again apply-
ing the transformation ( 6.57) to the numerator, we obtain with automatic
simpliﬁcation
x2+(x+1 )2
x2/parenleftbiggx+1
x/parenrightbigg1/2,
which is in rationalized form. /square
Example 6.60. In order for the algorithm to obtain a rationalized form, dis-
tributive transformations that undo a rationalization cannot be included in
automatic simpliﬁcation. A problem arises with both the Maple and Mu-PAD systems in which integers and fractions are automatically distributed
over sums. For example, in Maple or MuPAD, implementations of the al-
gorithm attempt to transform a+b/2t o( 2a+b)/2, but then automatic
simpliﬁcation transforms it back to a+b/2. /square
Rational-Expanded Form
Since algebraic expansion is not part of the simpliﬁcation context of ratio-
nalization, the Rationalize
 expression operator may return an expression
with the numerator or denominator in unexpanded form. For example,
Rationalize
 expression (a/b+c/d+e/f)→adf+b(cf+de)
bdf.
268 6. Structure of Polynomials and Rational Expressions
The following deﬁnition combines rationalization and expansion.
Definition 6.61. Analgebraic expression uis inrational-expanded
form if it satisﬁes the following two properties:
1.uis in rationalized form.
2.Numerator (u)andDenominator (u)are in algebraic expanded form.
The next example shows that there is an involved interaction between
the rationalization and expansion operations.
Example 6.62. Consider the expression
/parenleftBig/radicalBig
1
(x+y)2+1+1/parenrightBig/parenleftBig/radicalBig
1
(x+y)2+1−1/parenrightBig
x+1.
This expression is in rationalized form, but not rational-expanded form.
Expanding the numerator we obtain
1
(x+y)2+1−1
x+1,
which is not in rationalized form. Transforming this expression to ratio-
nalized form we obtain
−(x+y)2
/parenleftBig
(x+y)2+1/parenrightBig
(x+1 ),
which again is not in rational-expanded form. Expanding the numerator
and denominator, we obtain
−x2−2xy−y2
x3+x2+2x2y+2xy+xy2+y2+x+1,
which is in rational-expanded form. /square
The operator Rational
 expand (u) transforms an algebraic expression u
to rational-expanded form. The procedure for this operator is left to the
reader (Exercise 3).
6.5. General Rational Expressions 269
Normal Simplification Operators
LetMrepresent the set of algebraic expressions that do not contain fac-
torials, function forms, or powers with non-integer exponents. For this
class of expressions, the Rational
 expand operator together with automatic
simpliﬁcation can always determine if an expression simpliﬁes to 0. An
operator with this property is called a normal simpliﬁcation operator or a
zero equivalence operator for the class M. For example,
Rational
 expand/parenleftBigg
1
1/a+c/(ab)+abc+ac2
(b+c)2−a/parenrightBigg
→0.
On the other hand, rationalization alone does not obtain this transforma-
tion:
Rationalize
 expression/parenleftBigg
1
1/a+c/(ab)+abc+ac2
(b+c)2−a/parenrightBigg
→(b+c)2a2b+/parenleftBig
abc+ac2−a(b+c)2/parenrightBig
(ab+ca)
(ab+ca)(b+c)2.
Rational Simplification
Although the Rationalize
 expression operator transforms an expression to
rationalized form, it often introduces extraneous common factors into the
numerator and denominator. For example, the operator obtains
Rationalize
 expression (x/z+y/z2)→z2x+zy
z3,
where an extraneous common factor zappears in the numerator and de-
nominator. Although it is possible to modify the algorithm to avoid this,
it is better to eliminate the common factors after rationalization because
other common factors can be eliminated then as well. In Exercise 6,w e
describe an operator that eliminates the explicit common factors that ariseduring rationalization as well as some other explicit common factors.
The more interesting problem, however, involves the elimination of com-
mon factors that are implicit or hidden. For example, it is not so obviousthat the expression
2a
3+2 2ab+6a2+7a+6ba2+1 2b2+2 1b
7a2−5ab2−2ba2−5a+2 1ab+3b3−15b(6.58)
has a common factor a+3bin the numerator and denominator and can be
simpliﬁed to
2a2+4b+6a+7
7a−2ab−5+b2. (6.59)
270 6. Structure of Polynomials and Rational Expressions
The process of eliminating explicit and implicit common factors from the
numerator and denominator of a rational expression is called rational sim-
pliﬁcation . One way to obtain this simpliﬁcation is by factoring the nu-
merator and denominator and cancelling the common factors. Since fac-torization is a time consuming process, this is usually done instead with a
greatest common divisor algorithm. Since the topic is beyond the scope of
this chapter, the reader may consult Cohen [ 24], Sections 4.2 and 6.3, for
more information on this problem.
Since rational simpliﬁcation is an important aspect of simpliﬁcation,
most computer algebra systems have some capability to perform this oper-
ation (Exercise 5).
Exercises
1. Explore the capacity of the numerator and denominator operators in a
CAS. What is the simpliﬁcation context of these operators in the CAS?
Are the operators deﬁned with the same transformations as the ones givenin the text? (See Figure 4.1on page124.)
2. Let ubeanalgebraic expression . Give procedures for each of the following
operators:
(a)Numerator (u) (Deﬁnition 6.48).
(b)Denominator (u) (Deﬁnition 6.48).
(c)Rational
gre(u,v) (Deﬁnition 6.53).
(d)Rational
variables(u) (Deﬁnition 6.55).
3. Let ube analgebraic expression . Give a procedure Rational
expand(u)
that transforms uto rational-expanded form (Deﬁnition 6.61). Since ratio-
nal expansion includes the expansion of denominators, there is the possi-
bility that a denominator expands and simpliﬁes to 0. For example, thisoccurs with
1
x2+x−x(x+1).
Make sure your procedure checks for this situation and returns the global
symbol Undeﬁned when it occurs. Your procedure should obtain the
rational expansion in Example 6.59.
4. In this exercise we describe two modiﬁcations of the operators Numerator
andDenominator .
(a) Give procedures for Numerator (u)a n dDenominator (u)t h a tr a t i o -
nalize ubefore obtaining the numerator and denominator.
(b) Let ube analgebraic expression ,a n dl e t Lbe a list of distinct sym-
bols. In addition, suppose the exponent of each power in uis a
multivariate polynomial in the variables in L. A modiﬁcation of
6.5. General Rational Expressions 271
the deﬁnition for the Numerator andDenominator operators is ob-
tained by determining the sign of the exponent of a power using the
Polynomial
signoperatordescribed in Exercise 7on page246.I nt h i s
case, Rule ND-2 is replaced by the following rule.
ND-2. Suppose that uis a power, and let z=Operand(u,2). If
Polynomial
sign(z,L)<0,
then
Numerator (u,L)→1,
and
Denominator (u,L)→
Operand(u,1)∧Algebraic
expand(−1∗z),
otherwise
Numerator (u,L)→u,Denominator (u,L)→1.
Notice that the list Lappears as an input parameter because the
polynomial sign depends on the order of the symbols in L.G i v e
proceduresNumerator (u,L)a n dDenominator (u,L) that obtain the
numerator and denominator of uwith this modiﬁcation to the ND
rules.
5. Explore the rational simpliﬁcation capability of a CAS. For example can
the rational simpliﬁcation operator in a CAS simplify Expression ( 6.58)t o
Expression ( 6.59)? How about the transformation
x3+i√
2+√
3J
x2+i
2√
2√
3−5J
x+√
2−√
3
x3+i
−√
2+√
3J
x2+i
−5−2√
2√
3J
x−√
2−√
3
→x+√
2−√
3
x−√
2−√
3,
which is more involved because it includes radical expressions? (See Fig-
ure4.1on page124.)
6. Let ube analgebraic expression in rationalized form. In this exercise we
outline an algorithm for an operator Cancel(u) that performs a limited
version of rational simpliﬁcation. The operator can eliminate extrane-
ous common factors introduced by the Rationalize
expression operator as
well as some other explicit common factors. The cancellation is obtainedthrough automatic simpliﬁcation after performing a limited version of fac-
torization on the numerator and denominator of u. The operator is based
on the following operators:
272 6. Structure of Polynomials and Rational Expressions
(a) Let uandvbealgebraic expressions . The operator
Common
factors(u,v)
ﬁnds some factors that are common to uandv. It is deﬁned using
the following transformation rules.
CF-1.Ifuandvare integers then Common
factors(u,v)r e t ur n s
the greatest (positive) common divisor of uandv. Most com-
puteralgebra systems haveanoperator thatobtains thegreatestcommon divisor of integers (see Figure 4.1on page124).
CF-2.Ifuis a product, let
f=Operand(u,1),r=Common
factors(f,v).
Then
Common
factors(u,v)→r∗Common
factors(u/f, v/r).
CF-3.Ifvis a product then
Common
factors(u,v)→Common
factors(v,u).
CF-4.If none of the previous rules apply, then deﬁne
base(u)=k
Operand(u,1) ifKind(u)=” ∧”,
u otherwise,
exponent( u)=Operand(u,2) ifKind(u)=” ∧”,
1o t h e r w i s e .
If base( u)=b a s e ( v) and both exponent( u) and exponent( v)a r e
positive rational numbers, then
Common
factors(u,v)→
base(u)Min({exponent( u),exponent( v)}),
otherwiseCommon
factors(u,v)→1.
For example, the operator obtains
Common
factorsi
6xy3,2x2yzJ
→2xy,
Common
factors(x+y, a(x+y))→x+y.
Give a procedure for this operator.
(b) Let ube analgebraic expression . The operator Factor
out(u)p e r -
forms a limited version of factorization. It is deﬁned using the fol-lowing transformation rules.
FO-1.Ifuis a product then Factor
out(u)→Map(Factor
out,u).
6.5. General Rational Expressions 273
FO-2.Ifuis a power then
Factor
out(u)→Factor
out(Operand(u,1))Operand (u,2).
FO-3.Suppose that uis a sum with noperands, and let
s=Map(Factor
out,u).
Ifsis not a sum, then
Factor
out(u)→s.
Otherwise, suppose that sis a sum with operands s1,...,s n,
and let cbe the common factor of all the siobtained using the
Common
factorsoperator described in part (a). Then
Factor
out(u)→c(s1/c+···+sn/c),
where the divisions are obtained with automatic simpliﬁcation.
FO-4.If none of the previous rules apply, then Factor
out(u)→u.
For example,
Factor
outi
(x2+xy)3J
→x3(x+y)3,
Factor
out(a(b+bx))→ab(1+x),
Factor
outQ
21/2+2w
→21/2(1+21/2),
Factor
out(abx+acx+bcx)→(ab+ac+bc)x,
Factor
out(a/x+b/x)→a/x+b/x.
In the last example, 1 /xis not isolated because the Common
factors
operator in FO-3 retrieves only powers with positive rational expo-nents (see CF-4). Give a procedure for this operator.
(c) Let ube analgebraic expression in rationalized form. Give a pro-
cedure for the operator Cancel(u) that is deﬁned by the following
transformation rule.
Letn=Numerator (u)a n dd=Denominator (u). Then
Cancel(u)→Factor
out(n)/Factor
out(d).
For example,
CancelW(a+b)c+(a+b)d
ae+be}
→c+d
e.(6.60)
Note: Cancel (u) does not remove all explicit common factors. For
example, although
a(a+b)−a2−ab+rs+rt
r2
274 6. Structure of Polynomials and Rational Expressions
hasacommonfactor of rinthenumeratoranddenominatorandsim-
pliﬁes to ( s+t)/r,t h i si sn o to b t a i n e dw i t h Cancel. However, if the
expression is ﬁrst transformed to rational-expanded form, the sim-
pliﬁcation is obtained with Cancel. On the other hand, if the input
toCancelin Expression ( 6.60) is transformed to rational-expanded
form, the common factor is not removed. For further discussion of
common factors in these cases and implicit common factors, see Co-hen [24], Section 6.3.
7
Exponential and Trigonometric
Transformations
This chapter is concerned with the manipulation of algebraic expressions
that contain exponential or trigonometric functions. In Section 7.1we
describe expansion algorithms that expand these functions with respect totheir arguments. These algorithms obtain the transformations
exp(2x+y)→(exp(x))
2exp(y), (7.1)
sin(2x+y)→2c o s (y)sin(x)cos(x)+2s i n (y)(cos(x))2(7.2)
−sin(y).
In Section 7.2we describe contraction algorithms that invert the trans-
formations in ( 7.1)a n d( 7.2). In addition, we describe a simpliﬁcation
algorithm that can verify a large class of trigonometric identities.
7.1 Exponential and Trigonometric Expansion
In this section we describe algorithms that expand the exponential andtrigonometric functions that appear in an expression.
275
276 7. Exponential and Trigonometric Transformations
Exponential Expansion
Letu,v,a n dwbe algebraic expressions. The exponential function satisﬁes
the following properties1:
exp(u+v)=e x p (u)e x p (v), (7.3)
exp(wu)=e x p (u)w. (7.4)
The operation that applies these transformations in a left to right manner
is called exponential expansion , and the operation that applies the trans-
formations in a right to left manner is called exponential contraction2.In
this section we describe procedures for exponential expansion. Procedures
for exponential contraction are described in Section 7.2.
The goal of exponential expansion is described in the next deﬁnition.
Definition 7.1. Analgebraic expression uis inexponential-expanded
form if the argument of each exponential function in u
1. is not a sum;
2. is not a product with an operand that is an integer.
Although Equation ( 7.4) provides a way to remove any operand of a
product from the argument of an exponential function, it doesn’t specifywhich operand should be removed. To eliminate this ambiguity, we only
remove an integer operand from the argument
3. This point is illustrated
in the next two examples.
Example 7.2. Consider the manipulation
exp(2wx+3yz)=e x p ( 2 wx)exp(3yz)
=e x p (wx)2exp(yz)3.
1Property ( 7.3) is valid in either a real number of complex number context. Property
(7.4) is valid in a real context but is only valid in a complex context when wis an
integer. For example, if u=( 3/2)πı(whereı=√
−1) andw=1/2, by using the
principal value of the square root function, we have (exp( u))w=√
2/2−√
2/2ıand
exp(wu)=−√
2/2+√
2/2ı. For a discussion of the exponent relationships in a complex
setting, see Pennisi [ 78], pages 112-113. (Implementation: Maple (mws), Mathematica
(nb), MuPAD (mnb).)
2During automatic simpliﬁcation the Mathematica system transforms the function
form Exp[u]t ot h ep o w e r Euand also applies the contraction EuEv→Eu+v. In addition,
it applies the contraction ( Eu)n→Enuwhennis an integer. Therefore, to implement
the expansion and contraction procedures described in this chapter in this system, it isnecessary to use another representation for the exponential function. (Implementation:Mathematica (nb).)
3In Maple and Mathematica, an integer operand in a product is the ﬁrst operand.
In MuPAD, an integer operand in a product is the last operand.
7.1. Exponential and Trigonometric Expansion 277
The exponential on the left has an operand that is a sum and so is
not in exponential-expanded form. Applying Equation ( 7.3), we obtain
two new exponentials, which are also not in expanded form. Applying
Equation ( 7.4) to each exponential, we obtain the expanded form of the
expression. /square
Example 7.3. Consider the manipulation
exp(2(x+y)) = exp( x+y)2
=e x p (x)2exp(y)2.
The exponential on the left has an operand that is a product with an integer
operand and so is not in exponential-expanded form. Applying Equation
(7.4), we obtain a new exponential that has an operand that is a sum and so
is not in expanded form. Applying Equation ( 7.3), we obtain the expanded
form of the expression. /square
A procedure that transforms an expression to exponential-expanded
f o r mi sg i v e ni nF i g u r e 7.1. At line 4, the Mapoperator calls on the proce-
dure recursively to search all operands of the expression for exponentials. If
the resulting expression is an exponential (line 5), the procedure attempts
to apply Equation ( 7.3) (lines 7-9) or Equation ( 7.4) (lines 10-13). At line
9, two new exponentials are created that may not be in expanded form, and
so the procedure is called recursively to reapply the rules. (This recursion
is needed in Example 7.2.) For the same reason, the procedure is applied
recursively4to the new exponential created in line 13. (This recursion is
needed in Example 7.3.)
Unfortunately, because recursion is used in two ways, to traverse all
operands of the expression tree and to reapply the rules to newly created
exponentials, Expd
 expcreates some redundant recursion. To see how this
happens, consider the expansion of the expression exp(2 wx+3yz)d e -
s c r i b e di nE x a m p l e 7.2. In this case, there are 28 procedure calls with the
following inputs:
exp(2wx+3yz),2wx+3yz,2wx,2,w ,x , 3yz,3,y,z, (7.5)
exp(2wx),2wx,2,w ,x , (7.6)
exp(wx), w x, w, x, (7.7)
exp(3yz),3yz,3,y,z, (7.8)
exp(yz),yz,y,z. (7.9)
4In the Maple and MuPAD systems an expression like exp( 2(x+y)) is transformed
to exp( 2x+2y) by automatic simpliﬁcation, and so the recursive call at line 13 is not
needed. (Implementation: Maple (mws), MuPAD (mnb).)
278 7. Exponential and Trigonometric Transformations
Procedure Expd
exp(u);
Input
u:a nalgebraic expression ;
Output
analgebraic expression in exponential-expanded form;
Local Variables
v,A,f;
Begin
1 ifKind(u)∈{integer ,fraction ,symbol }then
2Return(u)
3 else
4 v:=Map(Expd
exp,u);
5 ifKind(v)=e xp then
6A : = Operand(v,1);
7 ifKind(A)=”+” then
8 f:=Operand(A,1);
9 Return(Expd
exp(exp(f))∗Expd
exp(exp(A−f)))
10 elseifKind(A)=” ∗”then
11 f:=Operand(A,1);
12 ifKind(f)=integer then
13 Return(Expd
exp(exp(A/f))f);
14Return(v)
End
Figure 7.1. An MPL procedure that transforms an algebraic expression to
exponential-expanded form. (Implementation: Maple(txt),Mathematica (txt),
MuPAD(txt). In the MuPAD implementation, the statement at line 11 assigns
the last operand of Atof.)
The inputs associated with the tree traversal of exp(2 wx+3yz) from line
4a r eg i v e ni n( 7.5). Since there are no exponentials in 2 wx+3yz,t h e
next recursive step occurs when the new exponential exp(2 wx)i sc r e a t e d
at line 9, which leads to the inputs for the next sequence of calls in ( 7.6).
Observe that redundant recursion occurs (from line 4) because all sub-
expressions of 2 wxare traversed for a second time. In a similar way, the
next sequence of inputs is given in ( 7.7) when the procedure attempts at line
13 to expand the new exponential exp( wx). Once again, more redundant
recursion arises (from line 4) as the sub-expressions of wxare traversed
for a third time. Finally, more redundant recursion occurs (from lines 9
and 13) with expansion of the new expressions exp(3 yz) and exp( yz)( s e e
(7.8)a n d( 7.9)).
7.1. Exponential and Trigonometric Expansion 279
One simple way to eliminate the redundant recursion is to implement
the procedure in a language that remembers the input-output values of pro-
cedure calls. Another approach is to separate the two roles for recursion by
using two procedures. The procedures that perform exponential expansionin this way are shown in Figure 7.2. Notice that there is an outer main
procedure Expand
expand an inner procedure Expand
 exp
rules.T h er e -
cursion that is used to traverse all operands of the expression tree is ob-tained with the Mapoperator at line 4 of Expand
exp. This procedure also
calls on Expand
 exp
rulesat line 6, which takes as input the argument of
an exponential function and applies the transformation rules (Equations
(7.3)a n d( 7.4)). Notice that the reapplication of the rules is obtained in
Expand
 exp
rulesat lines 3 and 7. Since Expand
 exp
rulesonly applies re-
cursion when a rule is applied, some redundant recursion is eliminated. For
example, to obtain the expanded form of exp(2 wx+3yz), the sequence
of inputs to Expand
 expis still given in ( 7.5), while the sequence of inputs
forExpand
 exp
rulesis given by
2wx+3yz,2wx, wx, 3yz, yz.
Using the two procedures in Figure 7.2, there are 15 procedure calls, while
using the single procedure in Figure 7.1, there are 28 procedure calls.
Appraisal of Expand
 exp. In the present form, the algorithm encounters a
division by zero whenever an application of a transformation rule together
with automatic simpliﬁcation transforms a denominator to zero. This oc-curs, for example, with
1
exp(2x)−exp(x)2.
A modiﬁcation of the algorithm that recognizes this and returns the symbol
Undeﬁned is described in Exercise 2.
Since Expand
 expis applied in the simpliﬁcation context of automatic
simpliﬁcation, it is unable to obtain some transformations that require
additional algebraic operations. For example, the manipulation
exp((x+y)(x−y)) = exp(x2)/exp(y2) (7.10)
is not obtained with exponential expansion unless the argument of the
exponential on the left is ﬁrst algebraically expanded. A modiﬁcation of
the algorithm that obtains this transformation is described in Exercise 3.
280 7. Exponential and Trigonometric Transformations
Procedure Expand
exp(u);
Input
u:a nalgebraic expression ;
Output
analgebraic expression in exponential-expanded form;
Local Variables
v;
Begin
1 ifKind(u)∈{integer ,fraction ,symbol }then
2Return(u)
3 else
4 v:=Map(Expand
exp,u);
5 ifKind(v)=e xp then
6 Return(Expand
exp
rules(Operand(v,1)))
7 else
8 Return(v)
End
Procedure Expand
exp
rules(A);
Input
A:a nalgebraic expression that is the argument of an exponential
function;
Output
the exponential-expanded form of exp( A);
Local Variables
f;
Begin
1 ifKind(A)=”+” then
2 f:=Operand(A,1);
3Return(Expand
exp
rules(f)∗Expand
exp
rules(A−f))
4 elseifKind(A)=” ∗”then
5 f:=Operand(A,1);
6 ifKind(f)=integer then
7 Return(Expand
exp
rules(A/f)f);
8Return(exp(A))
End
Figure 7.2. Two MPL procedures that separate the two roles for recursion
in exponential expansion. (Implementation: Maple(txt),Mathematica (txt),
MuPAD(txt). In the MuPAD implementation, the statement at line 5 of
Expand
exp
rulesassigns the last operand of Atof.)
7.1. Exponential and Trigonometric Expansion 281
Trigonometric Expansion
The sin and cos functions satisfy the identities:
sin(θ+φ)=s i n (θ)c o s (φ)+c o s (θ)s i n (φ), (7.11)
cos(θ+φ)=c o s (θ)c o s (φ)−sin(θ)s i n (φ). (7.12)
Thetrigonometric expansion operation applies these identities in a left to
right manner to all sin and cos functions in an expression. We also obtain
expanded forms for sin( nθ)a n dc o s ( nθ)(na positive integer) by viewing
the argument nθas a sum with nidentical operands θand repeatedly ap-
plying the rules. In addition, by applying the identities sin( −θ)=−sin(θ)
and cos( −θ)=c o s (θ), we obtain expanded forms for sin( nθ)a n dc o s ( nθ)
whennis a negative integer as well.
The goal of trigonometric expansion is described in the next deﬁnition.
Definition 7.4. An expression uis intrigonometric-expanded form if
the argument of each sinandcosfunction in u
1. is not a sum;
2. is not a product with an operand that is an integer.
The deﬁnition is given only in terms of sine and cosine functions be-
cause the other trigonometric functions can be expressed in terms of these
functions. (See the Trig
substitute procedure in Figure 5.12on page 190.)
Example 7.5. Consider the manipulation
sin(2x+3y)=s i n ( 2 x)cos(3y)+c o s ( 2x)sin(3y) (7.13)
=2 s i n (x)cos(x)/parenleftbig
cos3(y)−3cos (y)sin2(y)/parenrightbig
(7.14)
+/parenleftbig
cos2(x)−sin2(x)/parenrightbig/parenleftbig
3cos2(y)sin(y)−sin3(y)/parenrightbig
.
The sin on the left is not in trigonometric-expanded form because its ar-
gument is a sum. Applying the identity ( 7.11), we obtain two new sines
and two new cosines that are also not in expanded form. By reapplyingthe rules, we obtain the ﬁnal expanded form in Expression ( 7.14). /square
Example 7.6. Consider the manipulation
sin(2(x+y)) = 2 sin( x+y)cos(x+y) (7.15)
=2 ( s i n ( x)cos(y)+c o s (x)sin(y))(cos(x)cos(y)
−sin(x)sin(y)). (7.16)
282 7. Exponential and Trigonometric Transformations
The sin on the left is not in trigonometric-expanded form because its argu-
ment is a product with an integer operand. Applying the identity ( 7.11),
we obtain a new sine and a new cosine that are not in expanded form. By
reapplying the rules, we obtain the expanded form in Expression ( 7.16).
/square
Because of the identity
sin2(θ)+c o s2(θ)=1, (7.17)
an expression can have a number of trigonometric-expanded forms. For
example, our algorithm (shown in Figure 7.3) obtains the expanded form
cos(5x)=c o s5(x)−10 cos3(x)sin2(x)+5c o s (x)sin4(x).(7.18)
By using the identity ( 7.17), however, we can remove sin2(x)a n ds i n4(x)
from the expression and obtain another expanded form that involves only
cosines
cos(5x)=1 6c o s5(x)−20 cos3(x)+5c o s (x). (7.19)
Although a simple expansion algorithm is obtained by repeatedly ap-
plying the identities ( 7.11)a n d( 7.12), a straightforward implementation
can involve excessive recursion. We describe next three modiﬁcations to
this process that reduce some of this recursion.
First, as with exponential expansion, recursion is used two ways: to
examine all the operands of an expression tree and to reapply the transfor-
mations ( 7.11)a n d( 7.12) when a new sine or cosine is created. To reduce
redundant recursion, we divide the computation into two procedures that
handle each of the recursive tasks.
The next example shows another way that redundant recursion can
arise.
Example 7.7. Consider the trigonometric expansion of sin( a+b+c+d).
First, we apply the identity ( 7.11)w i t hθ=aandφ=b+c+dto obtain
sin(a+b+c+d)=s i n (a)cos(b+c+d)+c o s (a)sin(b+c+d).
Next, apply the identities ( 7.11)a n d( 7.12) recursively to cos( b+c+d)a n d
sin(b+c+d)w i t hθ=bandφ=c+d.t oo b t a i n
cos(b+c+d)=c o s (b)cos(c+d)−sin(b)sin(c+d),
sin(b+c+d)=s i n (b)cos(c+d)+c o s (b)sin(c+d).
Because both of the expressions on the right require expansions for cos( c+d)
and sin(c+d), the next recursive application of the rules leads to some
redundant recursion. Using this approach, this example requires seven
7.1. Exponential and Trigonometric Expansion 283
Procedure Expand
trig(u);
Input
u:a nalgebraic expression ;
Output
analgebraic expression in trigonometric-expanded form;
Local Variables v;
Begin
1 ifKind(u)∈{integer ,fraction ,symbol }then
2Return(u)
3 else
4 v:=Map(Expand
trig,u);
5 ifKind(v)=s i n then
6 Return(Operand(Expand
trig
rules(Operand(v,1)),1))
7 elseifKind(v)=c o s then
8 Return(Operand(Expand
trig
rules(Operand(v,1)),2))
9 else
10 Return(v)
End
Procedure Expand
trig
rules(A);
Input
A:a nalgebraic expression that is the argument of a sin or cos;
Output
a two element list [ s,c]w h e r e sandcare the
trigonometric-expanded forms of sin( A)a n dc o s ( A);
Local Variables f,r,s,c;
Begin
1 ifKind(A)=”+” then
2 f:=Expand
trig
rules(Operand(A,1));
3 r:=Expand
trig
rules(A−Operand(A,1));
4 s:=Operand(f,1)∗Operand(r,2)+Operand(f,2)∗Operand(r,1);
5 c:=Operand(f,2)∗Operand(r,2)−Operand(f,1)∗Operand(r,1);
6Return([s,c])
7 elseifKind(A)=” ∗”then
8 f:=Operand(A,1);
9 ifKind(f)=integer then
10 Return([Multiple
angle
sin(f,A/f),Multiple
angle
cos(f,A/f)]);
11Return([sin(A),cos(A)])
End
Figure 7.3. MPL procedures that transform an algebraic expression to
trigonometric-expanded form. (Implementation: Maple(txt),Mathematica
(txt),MuPAD(txt). In the MuPAD implementation, the statement at line 8
ofExpand
trig
rulesassigns the last operand of Atof.)
284 7. Exponential and Trigonometric Transformations
applications of the rules. In general, if a sin or cos has an argument that
is a sum of nsymbols, the number of rule applications grows exponentially
as 2n−1−1 (Exercise 6(a)). /square
There are a number of ways to eliminate this redundant recursion. One
way is simply to implement the algorithm in a language that remembers the
input-output values of procedure calls. Another approach, which we usehere, is to obtain sin( A)a n dc o s ( A) simultaneously. (See the discussion on
page285and the procedure Expand
trig
rulesin Figure 7.3.) This approach
requires only 2( n−1) rule applications to expand a sin or cos of a sum of
nsymbols (Exercise 6(b)).
Another improvement to the algorithm is based on the following repre-
sentations for multiple angle expansions. For na positive integer,
cos(nθ)=n/summationdisplay
j=0
jeven(−1)j/2/parenleftbiggn
j/parenrightbigg
cosn−j(θ)sinj(θ), (7.20)
sin(nθ)=n/summationdisplay
j=1
jodd(−1)(j−1)/2/parenleftbiggn
j/parenrightbigg
cosn−j(θ)sinj(θ). (7.21)
For example, the expansion in Equation ( 7.18) is obtained using the ﬁrst
formula.
These representations are derived using the exponential representations
for sin and cos and the binomial theorem. For example to obtain the sum
(7.20),
cos(nθ)=exp(ınθ)+e x p ( −ınθ)
2=exp(ıθ)n+e x p ( −ıθ)n
2
=(cos(θ)+ısin(θ))n+( c o s (θ)−ısin(θ))n
2
=( 1/2)
n/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
cosn−j(θ)ıjsinj(θ)
+n/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
cosn−j(θ)(−ı)jsinj(θ)

=( 1/2)n/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
cosn−j(θ)s i nj(θ)ıj(1 + ( −1)j).
7.1. Exponential and Trigonometric Expansion 285
However, using
ıj(1 + ( −1)j)=/braceleftbigg
2(−1)j/2,jeven,
0,j odd,
we obtain the representation ( 7.20).
Another approach for expanding sin( nθ)a n dc o s ( nθ) that uses recur-
rence relations is described in Exercise 10.
Procedures that transform an expression to trigonometric-expanded
form are given in Figure 7.3. The main procedure Expand
 trigapplies
the process to the operands of an expression using the Mapoperator in
line 4 and, if the resulting expression is a sin or cos, invokes the procedureExpand
trig
rulesto apply the expansion rules (lines 6 and 8).
Expand
 trig
rules(A) returns a two element list with the trigonometric-
expanded forms of sin( A)a n dc o s ( A). WhenAis a sum, the procedure is
applied recursively to both Operand (A,1) and to A−Operand (A,1) (line
2-3) after which the identities ( 7.11)a n d( 7.12) are applied to the result-
ing expressions (lines 4-5). (This recursion is needed in Example 7.5.)
WhenAis a product with an integer operand, the procedure invokes the
Multiple
 angle
 sinandMultiple
 angle
 cosprocedures, which apply the mul-
tiple angle representations given in ( 7.21)a n d( 7.20). (These procedures
are left to the reader (Exercise 5).) This step is also recursive because these
procedures invoke Expand
 trig
rules. (This recursion is needed in Exam-
ple7.7.) Finally, when neither transformation rule applies, the procedure
returns [sin( A),cos(A)] (line 11).
Appraisal of Expand
 trig.In the present form the algorithm encounters a
division by zero whenever an application of a transformation rule together
with automatic simpliﬁcation transforms a denominator to zero. For ex-ample, this occurs with the expression 1 /(sin(2x)−2sin(x)cos(x)). A
modiﬁcation of the algorithm that recognizes this and returns Undeﬁned
is described in Exercise 7.
Since the Expand
trigalgorithm does not include algebraic expansion, it
misses some opportunities to apply the trigonometric expansion rules. Forexample, the expression sin(( x+y)
2) is not expanded because ( x+y)2is
not in (algebraic) expanded form. In addition, the output for an expression
like sin(a+b+c+d) is cumbersome because it is returned in a nested form
rather than in an algebraic expanded form. In Exercise 8, we describe
modiﬁcations of the procedures that handle these problems.
In some instances, Expand
 trigdistorts the mathematical meaning of
an expression. Consider the expression
sin(2x)−2s i n (x)cos(x)
(sin(x))2+( c o s (x))2−1.
286 7. Exponential and Trigonometric Transformations
Strictly speaking, this expression is an indeterminate form because both the
numerator and denominator simplify to 0. However, Expand
 trigsimpliﬁes
the expression to 0 because the expanded form of the numerator is 0 while
the denominator is already in expanded form and is not changed. In Section7.2, we describe the Simplify
trigoperator that recognizes the problem for
this expression and indicates that it is undeﬁned. However, because it is
theoretically impossible to give an algorithm that can always determine ifan algebraic expression simpliﬁes to 0, it is impossible to avoid this problem
in all cases
5.
Exercises
1. Give the exponential-expanded form of the expression
exp((exp(2 x)−exp2(x)+1)(2 x+3y)).
2. TheExpand
expalgorithm encounters a division by zero if the transfor-
mation rules transform a sub-expression in a denominator to zero. For
example, this occurs with 1 /(exp(2 x)−exp(x)2). Modify the procedure so
that it recognizes this situation and returns the global symbol Undeﬁned
when it occurs.
3. Modify the deﬁnition of an exponential-expanded expression ugiven in
Deﬁnition 7.1so that it includes properties 1 and 2 from that deﬁnition
as well as the property that each complete sub-expression of uis in alge-
braic expanded form. Modify the procedures in Figure 7.2to obtain an
expression in this form. For example, your procedures should obtain
Expand
expi
expi
(x+y)2JJ
→expi
x2J
(exp(xy))2expi
y2J
.
4. Let u,v,a n dwbealgebraic expressions . The natural logarithm function
satisﬁes the following two properties:
ln(uv)=l n( u)+ln( v), (7.22)
ln(uw)=wln(u). (7.23)
Analgebraic expression is inlog-expanded form if the argument of each
logarithm is not a product or a power. For example, the manipulation
ln((wx)a)+ln( ybz)→a(ln(w)+ln( x))+bln(y)+ln( z).
transforms the expression on the left to log-expanded form. An expression
can be transformed to log-expanded form by applying Equations ( 7.22)
and (7.23) in a left to right manner. Give a procedure Expand
log(u)t h a t
transforms an algebraic expression uto log-expanded form.
5See footnote 6on page 145.
7.1. Exponential and Trigonometric Expansion 287
5. Let θbe analgebraic expression ,a n dl e t nbe an integer. Give procedures
Multiple
angle
sin(n,θ),Multiple
angle
cos(n,θ)
that ﬁnd the expansions for sin( nθ)a n dc o s ( nθ) using Equations ( 7.20)
and (7.21). Keep in mind when θis a sum, sin( θ)a n dc o s ( θ)a r en o ti n
expanded form. (This situation occurs in Example 7.6.) In this case it is
necessary6to expand these expressions with Expand
trig
rules.
Besuretoaccount forthepossibility that nisanegativeinteger. Although
most computeralgebra systemsapply transformations suchas sin( −2y)→
−sin(2y) during automatic simpliﬁcation, this situation will arise in our
algorithm with sin( x−2y)b e c a us eExpand
trig
rulestakes theargument
of a sin or cos as input rather than the function form.
6. Considertheexpansionofsin( A)andcos( A)where Aisasumof nsymbols.
(a) Showthattoexpandsin( A)orcos( A)usingtheapproachinExample
7.7requires 2n−1−1 rule applications.
(b) Show that to expand sin( A)a n dc o s ( A) simultaneously using the
algorithm in Figure 7.3requires 2( n−1) rule applications.
7. TheExpand
trigalgorithm may encounter a division by zero if the trans-
formation rules transform a sub-expression in a denominator to zero. For
example, this occurs with 1 /(sin(2x)−2sin(x)c o s (x)). Modify the pro-
cedure so that it recognizes this situation and returns the global symbol
Undeﬁned when it occurs.
8. Suppose we modify the deﬁnition of a trigonometric-expanded expression
uin Deﬁnition 7.4so that it includes properties (1) and (2) in that deﬁni-
tion as well as the property that each complete sub-expression of uis in
algebraic expandedform. Modify theprocedures inFigure 7.3to obtainan
expression in this form. For example, your procedures should obtain
Expand
trigi
sini
(x+y)2JJ
→
sin(x2)ii
(cos(xy))2−(sin(xy))2J
cos(y2)
−2c o s (xy)sin(xy)sin(y2)J
+cos(x2)i
2c o s (xy)sin(xy)cos(y2)
+i
(cos(xy))2−(sin(xy))2J
sin(y2)J
.
9. In this exercise we describe an extension to the Expand
trigalgorithm to
include the sinh and cosh functions. These functions satisfy the identities
sinh(θ+φ)=sinh( θ)c o s h ( φ)+cosh( θ) sinh( φ),
cosh(θ+φ)=c o s h( θ)c o s h ( φ)+sinh( θ) sinh( φ),
6In the Maple and MuPAD systems, it is not necessary to invoke Expand
 trig
rules
here because an integer is distributed over the operands of a sum by automatic simpli-ﬁcation, and so θcannot be a sum.
288 7. Exponential and Trigonometric Transformations
sinh(−θ)=−sinh(θ),cosh(−θ)=c o s h( θ),
cosh(nθ)±sinh(nθ)=(c o s h( θ)±sinh(θ))n,(7.24)
where nis a positive integer.
(a) Using the identity ( 7.24)i tf o l l o w st h a t
cosh(nθ)=1/2( ( c o s h ( θ)+sinh( θ))n+(cosh( θ)−sinh(θ))n),
sinh(nθ)=1/2 ((cosh( θ)+sinh( θ))n−(cosh(θ)−sinh(θ))n).
Usetheseformulas toderiverepresentations similar tothosein Equa-
tions (7.20)a n d(7.21) for sinh( nθ)a n dc o s h ( nθ).
(b) Extend the Expand
trigalgorithm so that it also expands the sinh
and cosh functions.
10. This exercise describes another approach that ﬁnds the expanded form for
sin(nθ)a n dc o s ( nθ) that uses recurrence relations.
(a) Show that for n≥2,pn=s i n(nθ) satisﬁes the recurrence relation
pn=2c o s( θ)pn−1−pn−2,p 1=s i n(θ),p 0=0.
(b) Show that for n≥2,qn=c o s( nθ) satisﬁes the recurrence relation
qn=2c o s( θ)qn−1−qn−2,q 1=c o s( θ),q 0=1.
Notice that this recurrence relation gives the expansion in ( 7.19).
(c) Giveproceduresthatﬁndtheexpandedformsforsin( nθ)andcos( nθ)
usingtherecurrencerelations inparts(a)and(b). Besuretoaccountforthepossibilitythat nisnegativeand θisasum. (Seethediscussion
in Exercise 5above.)
11. In this exercise we ask youto give a procedu re for trigonometric expansion
of the tangent function that is based on the identity
tan(θ+φ)=tan(θ)t a n (φ)
1−tan(θ)t a n (φ). (7.25)
(a) Let nbe a positive integer. Show that
tan(nθ)=n
j=1
jodd(−1)(j−1)/2~
n
j^
tanj(θ)
n
j=0
jeven(−1)j/2~
n
j^
tanj(θ).(7.26)
(b) Give a procedure Expand
tan(u) that is based on Equations ( 7.25)
and (7.26).
7.2. Exponential and Trigonometric Contraction 289
7.2 Exponential and Trigonometric Contraction
In this section we describe the exponential and trigonometric contraction
operators and a trigonometric simpliﬁcation operator that can verify a large
class of trigonometric identities.
Exponential Contraction
Exponential contraction applies the two transformation rules7
exp(u)e x p (v)→exp(u+v), (7.27)
exp(u)w→exp(wu). (7.28)
The goal of this operation is described in the following deﬁnition.
Definition 7.8. Analgebraic expression uis inexponential-contracted
form if it satisﬁes the following properties.
1. Each product in ucontains at most one operand that is an exponential
function.
2. Each power in udoes not have an exponential function for its base.
3. Each complete sub-expression of uis in algebraic-expanded form.
Properties (1) and (2) are obtained by applying the transformations
(7.27)a n d( 7.28). We have included property (3) because algebraic expan-
sion creates new opportunities to apply these rules. This point is illustrated
in the next example.
Example 7.9. Consider the manipulation
exp(x)(exp(x)+e x p (y)) = (exp( x))2+e x p (x)e x p (y)
=e x p ( 2 x)+e x p (x+y).
The expression on the left is not in contracted form because it is not in
algebraic-expanded form. Algebraic expansion gives a new sum with two
operands, a new power and a new product, that are not in contracted form.Applying the transformations ( 7.27)a n d( 7.28) we obtain the contracted
form. /square
7See footnote 1on page 276for some remarks about the validity of these transfor-
mations in real and complex contexts.
290 7. Exponential and Trigonometric Transformations
Procedure Contract
exp(u);
Input
u:a nalgebraic expression ;
Output
analgebraic expression in exponential-contracted form;
Local Variables
v;
Begin
1 ifKind(u)∈{integer ,fraction ,symbol }then
2Return(u)
3 else
4 v:=Map(Contract
exp,u);
5 ifKind(v)∈{”∗”,”∧”}then
6 Return(Contract
exp
rules(v))
7 else
8 Return(v)
End
Figure 7.4. The main MPL procedure that transforms an algebraic expression to
exponential-contracted form. (Implementation: Maple(txt),Mathematica (txt),
MuPAD(txt).)
Example 7.10. Consider the manipulation
exp(exp(x))exp(y)= exp(exp( x)e x p (y))
= exp(exp( x+y)).
The expression on the left is not in contracted form because it is a power
with an exponential for a base. Applying Equation ( 7.28)w eo b t a i na n
expression with a new product that is not in contracted form. Applying
Equation ( 7.27) we obtain the contracted form. /square
Procedures8for exponential contraction are shown in Figures 7.4and
7.5. Notice that there is an outer main procedure Contract
 expa n da ni n n e r
procedure Contract
 exp
rules. We have divided the computation in this
way to account for the two types of recursion that occur in the algorithm
and to indicate clearly where algebraic expansion or a reapplication of ther u l e si sr e q u i r e d .
The recursion that is used to traverse all operands of the expression tree
is obtained with the Mapoperator in line 4 of Contract
exp. At line 6, this
8See footnote 2on page 276concerning the Mathematica implementation of these
procedures.
7.2. Exponential and Trigonometric Contraction 291
Procedure Contract
exp
rules(u);
Input
u:a nalgebraic expression that is sent by either Contract
exp
or a recursive call of this procedure;
Output
analgebraic expression in exponential-contracted form;
Local Variables v,b,s,p,i,y ;
Begin
1 v:=Expand
main
op(u);
2 ifKind(v)=” ∧”then
3 b:=Operand(v,1);
4 s:=Operand(v,2);
5 ifKind(b)=e xp then
6 p:=Operand(b,1)∗s;
7 ifKind(p)∈{”∗”,”∧”}then
8 p:=Contract
exp
rules(p);
9 Return(exp(p))
10 else
11 Return(v)
12 elseifKind(v)=” ∗”then
13 p:= 1;
14 s:= 0;
15 fori:= 1toNumber
of
operands(v)do
16 y:=Operand(v,i);
17 ifKind(y)=exp then
18 s:=s+Operand(y,1)
19 else
20 p:=p∗y;
21Return(exp(s)∗p)
22 elseifKind(v)=”+” then
23 s:= 0;
24 fori:= 1toNumber
of
operands(v)do
25 y:=Operand(v,i);
26 ifKind(y)∈{”∗”,”∧”}then
27 s:=s+Contract
exp
rules(y)
28 else
29 s:=s+y;
30Return(s)
31 else
32Return(v)
End
Figure 7.5. The inner MPL procedure for exponential contraction. (Implemen-
tation:Maple(txt),Mathematica (txt),MuPAD(txt).)
292 7. Exponential and Trigonometric Transformations
procedure calls on Contract
 exp
ruleswhich applies algebraic expansion
and the transformation rules (Equations ( 7.27)a n d( 7.28)). Notice that
we only invoke Contract
 exp
ruleswhenvis a product or a power.
The second type of recursion occurs when either algebraic expansion or
an application of one of the contraction rules creates a new sum, product,or power that is not in contracted form. This recursion is invoked at lines 8
and 27 of Contract
exp
rules. At line 1 we algebraically expand the input
expression. To avoid redundant recursion, we use the Expand
 main
 opop-
erator that does not recursively expand its operands (Exercise 6, page 258).
Whenvis power (line 2) with an exponential function at its base (line 5),
we apply Equation ( 7.28) to obtain a new operand pof the exponential.
Then, ifpis a product or a power (by automatic simpliﬁcation), we recur-
sively contract this expression (lines 7 and 8). (This recursion is requiredin Example 7.10.) If the base is not an exponential, no transformation is
possible and we return v(line 11).
Next, ifvis a product (line 12), we loop through its operands (lines
13-20) combining exponentials with Equation ( 7.27). Lines 22-30 handle
the case when vis a sum. (This part is only invoked when a sum is created
by the expansion in line 1.) In this case, we loop through the operands andrecursively contract when an operand is a product or power. Finally, lines
31 and 32 apply to any other type of expression that was created by the
expansion at line 1. For example, for u=(√
2+1 )(√
2−1) the expansion
at line 1 assigns 1 to vwhich is returned at line 32.
Appraisal of Contract
 exp.Although exponential contraction acts as an
expression simpliﬁer for many expressions with exponentials, it does not
simplify all such expressions. For example, consider the exponential con-
traction
Contract
 exp/parenleftbigg1
exp(x)(exp(y)+e x p ( −x))−exp(x+y)−1
(exp(x+y))2−1/parenrightbigg
(7.29)
→exp(−x)
exp(y)+e x p ( −x)−exp(x+y)
(exp(x+y))2−1+1
(exp(x+y))2−1.
Although the (uncontracted) expression in ( 7.29) simpliﬁes to 0, this simpli-
ﬁcation is not obtained with Contract
 exp. There are two reasons for this.
First, since the ﬁrst term in ( 7.29) has the internal form exp( x)−1(exp(y)+
exp(−x))−1which is in algebraic-expanded form, the contraction operation
does not distribute exp( x)o v e rt h es u me x p ( y)+e x p ( −x). Next, in the
second term in ( 7.29), the numerator and denominator have a common fac-
tor exp(x+y)−1 that is not eliminated by exponential contraction. One
way to simplify the expression in ( 7.29) is to ﬁrst rationalize it using the
7.2. Exponential and Trigonometric Contraction 293
Rationalize
 expression operator described in Section 6.5and then contract
the numerator of the resulting expression. An operator that obtains the
simpliﬁcation in this way is described in Exercise 4.
Trigonometric Contraction
The sin and cos functions satisfy the identities:
sin(θ)s i n (φ)=cos(θ−φ)
2−cos(θ+φ)
2, (7.30)
cos(θ)c o s (φ)=cos(θ+φ)
2+cos(θ−φ)
2, (7.31)
sin(θ)c o s (φ)=sin(θ+φ)
2+sin(θ−φ)
2. (7.32)
Thetrigonometric contraction operation applies these identities in a left to
right manner. By repeatedly applying the identities ( 7.30)a n d( 7.31), we
also obtain contracted forms for sinn(θ)a n dc o sn(θ) (for an integer n>1).
The goal of this operation is given in the following deﬁnition.
Definition 7.11. An expression uis intrigonometric-contracted form
if it satisﬁes the following properties.
1. A product in uhas at most one operand that is a sine or cosine.
2. A power in uwith a positive integer exponent does not have a base
that is a sine or cosine.
3. Each complete sub-expression of uis in algebraic-expanded form.
Notice that the deﬁnition does not refer to the tan, cot, sec, and csc
functions because these functions can be expressed in terms of sin and cos.
We have included property (3) because algebraic expansion creates new
opportunities to apply the contraction rules. This point is illustrated in
the next two examples.
Example 7.12. Consider the manipulation
(sin(x)+c o s (y)) cos(y)=s i n ( x)c o s (y)+c o s2(y)
=sin(x+y)
2+sin(x−y)
2+1
2+cos(2y)
2.
294 7. Exponential and Trigonometric Transformations
The expression on the left is not in contracted form because it is not in
algebraic-expanded form. By expanding the expression, we obtain a new
sum with two operands, a new product and a new power, that are not in
contracted form. By applying the identities ( 7.32)a n d( 7.31), we obtain
the contracted form. /square
Example 7.13. Consider the manipulation
sin2(x)cos2(x)=/parenleftbigg1
2−cos(2x)
2/parenrightbigg/parenleftbigg1
2+cos(2x)
2/parenrightbigg
(7.33)
=1
4−cos2(2x)
4(7.34)
=1
4−1/2+c o s ( 4x)/2
4
=1
8−cos(4x)
8.
The expression on the left is not in contracted form because it contains a
sine and cosine to positive integer powers. Applying the identities ( 7.30)
and (7.31), we obtain a new product that is not in contracted form because
it is not in algebraic-expanded form. Algebraically expanding the right
side of Equation ( 7.33), we obtain in ( 7.34) a new sum that again is not
in contracted form because it contains a positive integer power of a cosine.
Applying the identity ( 7.31) and algebraically expanding, we obtain the
contracted form. /square
A simple algorithm for trigonometric contraction is obtained by repeat-
edly applying the identities ( 7.30), (7.31), and ( 7.32) although the approach
involves an excessive amount of recursion. As with exponential contraction,
we can reduce the redundant recursion by dividing the operation into twoprocedures. Another improvement involves the contraction of positive in-
teger powers of sines and cosines using the following representations. For
na positive integer,
cos
n(θ)=

/parenleftbig
n
n/2/parenrightbig
2n+1
2n−1n/2−1/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
cos((n−2j)θ),neven,
1
2n−1⌊n/2⌋/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
cos((n−2j)θ),n odd,(7.35)
7.2. Exponential and Trigonometric Contraction 295
sinn(θ)=

(−1)
n/parenleftbign
n/2/parenrightbig
2n+(−1)n
2
2n−1n/2−1/summationdisplay
j=0(−1)j/parenleftbiggn
j/parenrightbigg
cos((n−2j)θ),neven,
(−1)n−1
2
2n−1⌊n/2⌋/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
(−1)jsin((n−2j)θ),n odd,
(7.36)
where the ﬂoor function ⌊n/2⌋is the largest integer ≤n/2. We verify the
representation for cosn(θ)f o rnodd. Using the exponential representation
for cos(θ) and the binomial theorem, we have
cosn(θ)=/parenleftbiggeiθ+e−iθ
2/parenrightbiggn
=1
2nn/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
(eiθ)n−j(e−iθ)j
=1
2nn/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
ei(n−2j)θ
=1
2n
⌊n/2⌋/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
ei(n−2j)θ+n/summationdisplay
j=⌊n/2⌋+1/parenleftbiggn
j/parenrightbigg
ei(n−2j)θ
,
where the two sums in the last expression have the same number of terms.
We can combine these two sums by expressing the second sum in termsof a new summation index k=n−j. Observe that since nis odd,n=
2⌊n/2⌋+1, and this implies that k=⌊n/2⌋whenj=⌊n/2⌋+1. Therefore,
by reversing the order of summation in the second sum and using theidentity/parenleftbiggn
n−k/parenrightbigg
=/parenleftbiggn
k/parenrightbigg
,
we have
cos
n(θ)=1
2n
⌊n/2⌋/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
ei(n−2j)θ+⌊n/2⌋/summationdisplay
k=0/parenleftbiggn
k/parenrightbigg
ei(n−2(n−k))θ

=1
2n⌊n/2⌋/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
(ei(n−2j)θ+e−i(n−2j)θ)
296 7. Exponential and Trigonometric Transformations
=1
2n−1⌊n/2⌋/summationdisplay
j=0/parenleftbiggn
j/parenrightbigg
cos((n−2j)θ).
The derivations for the other cases are similar (Exercise 6).
Example 7.14. Using Equation ( 7.35)w eh a v e
cos4(x)=1/8c o s ( 4x)+1/2c o s ( 2x)+3/8. /square
Procedures for trigonometric contraction are given in Figures 7.6,7.7,
and7.8. The recursion that is used to traverse all operands of an expression
tree is obtained with the Mapoperator in line 4 of Contract
 trig.A t
line 6, this procedure calls on Contract
 trig
rules, which applies algebraic
expansion and calls on other procedures that apply the transformation rules
in (7.30), (7.31), and ( 7.32).
The second type of recursion occurs when either algebraic expansion
or an application of one of the contraction rules creates a new sum, prod-
uct, or power that is not in contracted form. This recursion is invoked
inContract
 trig
rulesat line 15 through Contract
 trig
product and directly
at line 21. At line 1 of Contract
 trig
rules, we algebraically expand the
Procedure Contract
trig(u);
Input
u:a nalgebraic expression ;
Output
analgebraic expression in trigonometric-contracted form;
Local Variables
v;
Begin
1 ifKind(u)∈{integer ,fraction ,symbol }then
2Return(u)
3 else
4 v:=Map(Contract
trig,u);
5 ifKind(v)∈{”∗”,”∧”}then
6 Return(Contract
trig
rules(v))
7 else
8 Return(v)
End
Figure 7.6. The main MPL procedure that transforms an algebraic expression
to trigonometric-contracted form. (Implementation: Maple(txt),Mathematica
(txt),MuPAD(txt).)
7.2. Exponential and Trigonometric Contraction 297
Procedure Contract
trig
rules(u);
Input
u:a nalgebraic expression (sum, product, power) that is sent by
eitherContract
trig,Contract
trig
power, or a recursive call
of this procedure;
Output
analgebraic expression in trigonometric-contracted form;
Local Variables
v,s,c,d,i,y ;
Begin
1 v:=Expand
main
op(u);
2 ifKind(v)=” ∧”then
3Return(Contract
trig
power(v))
4 elseifKind(v)=” ∗”then
5 s:=Separate
sin
cos(v);
6 c:=Operand(s,1);
7 d:=Operand(s,2);
8 ifd=1then
9 Return(v)
10 ifKind(d)∈{sin,cos}then
11 Return(v)
12 elseifKind(d)=” ∧”then
13 Return(Expand
main
op(c∗Contract
trig
power(d)))
14 else
15 Return(Expand
main
op(c∗Contract
trig
product(d)))
16 elseifKind(v)=”+” then
17 s:= 0;
18 fori:= 1toNumber
of
operands(v)do
19 y:=Operand(v,i);
20 ifKind(y)∈{”∗”,”∧”}then
21 s:=s+Contract
trig
rules(y)
22 else
23 s:=s+y;
24Return(s)
25 else
26Return(v)
End
Figure 7.7. The inner MPL procedure for trigonometric contraction. (Imple-
mentation: Maple(txt),Mathematica (txt),MuPAD(txt).)
298 7. Exponential and Trigonometric Transformations
Procedure Contract
trig
product(u);
Input
u: a product of sines, cosines, and positive integer powers
of sines and cosines;
Output
the trigonometric-contracted form of u;
Local Variables
A,B,θ,φ;
Begin
1 ifNumber
of
operands(u)=2then
2 A:=Operand(u,1);
3 B:=Operand(u,2);
4 ifKind(A)=” ∧”then
5 A:=Contract
trig
power(A);
6 Return(Contract
trig
rules(A∗B))
7 elseifKind(B)=” ∧”then
8 B:=Contract
trig
power(B);
9 Return(Contract
trig
rules(A∗B))
10 else
11 θ:=Operand(A,1);
12 φ:=Operand(B,1);
13 ifKind(A)=s i n andKind(B)=s i n then
14 Return(cos(θ−φ)/2−cos(θ+φ)/2)
15 elseifKind(A)=cos andKind(B)=c o s then
16 Return(cos(θ+φ)/2+cos( θ−φ)/2)
17 elseifKind(A)=sin andKind(B)=c o s then
18 Return(sin(θ+φ)/2+sin( θ−φ)/2)
19 elseifKind(A)=cos andKind(B)=s i n then
20 Return(sin(θ+φ)/2+sin( φ−θ)/2)
21 else
22 A:=Operand(u,1);
23 B:=Contract
trig
product(u/A);
24Return(Contract
trig
rules(A∗B))
End
Figure 7.8. The MPL procedure Contract
trig
productthat contracts products
whose operands are sines, cosines, or positive integer powers of sines or cosines.(Implementation: Maple(txt),Mathematica (txt),MuPAD(txt).)
input expression using the operator Expand
 main
 op(Exercise 6, page 258).
Whenvis a power (lines 2-3), we contract using Contract
 trig
power which
checks ifvis a positive integer power of a sine or cosine and if so, applies
Equation ( 7.35)o rE q u a t i o n( 7.36) (Exercise 7).
7.2. Exponential and Trigonometric Contraction 299
Next, in lines 4-15, when vis a product we ﬁrst apply Separate
 sin
cos
(Exercise 12, page 152) which returns a two element list with the operands
ofvseparated into two categories: the product of the operands that are
sines, cosines, or positive integer powers of sines and cosines (representedbyd), and the product of the remaining operands (represented by c). At
lines 8-9, when d= 1, there are no opportunities for contraction, and so v
is returned. In a similar way, at lines 10-11, when dis a sine or cosine, there
are no opportunities for contraction, and so vis returned. At lines 12-13,
whendis a positive integer power of a sine or cosine, we contract using
Contract
trig
power which applies Equation ( 7.35)o rE q u a t i o n( 7.36)( E x -
ercise7). Because this procedure returns a sum, we algebraically expand to
distribute cover the sum so that property (3) in Deﬁnition 7.11is satisﬁed.
Line 15 handles the case when dis a product of sines, cosines, or positive in-
teger powers of sines and cosines using the procedure Contract
 trig
product
which is described below. Again, expansion is required because the outputof this procedure is a sum.
Lines 16-24 handle the case when vis a sum, and lines 25-26 handle
other types of expressions that may arise because of the expansion at line 1.
Contract
trig
product , which contracts a product of sines, cosines and
positive integer powers of sines and cosines, is shown in Figure 7.8.T h e
case where uhas two operands is handled in lines 1-20. When one of the
operands is a power, this power is contracted (line 5 or 8), and the new
product is contracted with a recursive call to Contract
 trig
rules(line 6 or
9). At lines 11-20, both AandBare either sines or cosines, and so we
apply the transformations in ( 7.30), (7.31), or ( 7.32). The case when u
has three or more operands is handled in lines 21-24. In this situation, the
product with the ﬁrst operand removed is contracted recursively (line 23),and then the new product is contracted with Contract
trig
rules(line 24).
Simplification of Trigonometric Expressions
We now have all the building blocks that are needed to construct an oper-
ator that can verify a large class of trigonometric identities.
Automatic Simplification of Trigonometric Functions. Because our simpliﬁca-
tion operator performs in the context of automatic simpliﬁcation, we con-
sider ﬁrst the trigonometric transformations that are applied in this setting.
These include the following transformations.
1.Evaluation of trigonometric functions. Letf(x) be a trigono-
metric function. Typically, automatic simpliﬁcation evaluates f(kπ/n)
wherekandn/negationslash= 0 are integers and nis small (usually n=1,2,3,4,6).
300 7. Exponential and Trigonometric Transformations
Although the values f(kπ/n) can always be expressed using radicals, the
representations are quite involved for large values of n. For example
sin(π/60) =/radicalbig
5+√
5
8−/radicalbig
5+√
5√
3
8−/parenleftBig
−√
5
4+1/4/parenrightBig√
2
4
−/parenleftBig
−√
5
4+1/4/parenrightBig√
2√
3
4. (7.37)
Because it is rarely useful to evaluate f(kπ/n) for large values of n,t h e s e
evaluations are usually not performed during automatic simpliﬁcation (Ex-ercise 3, page 56).
2.Transformation to argument with positive sign and other
standard forms. In most computer algebra systems, automatic simpliﬁ-
cation transforms a trigonometric function to an equivalent form with anargument with positive sign. This includes transformations such as
sin(−2/3)→−sin(2/3),sin(−x)→−sin(x),cos(−2ab)→cos(2ab).
In addition, in both Maple and Mathematica automatic simpliﬁcation trans-
forms trigonometric functions so that arguments that are sums are trans-
formed to a standard form, although each system uses its own scheme todetermine the standard form. For example, the Maple system obtains the
transformation
sin(1−x)→−sin(x−1),
while the Mathematica system obtains the opposite transformation
Sin[x−1]→− Sin[1−x].
3.Transformationstoargumentsintheﬁrstquadrant. Ins o m e
systems, automatic simpliﬁcation transforms a trigonometric function with
an argument that includes a rational multiple of πto an equivalent function
where the multiple of πis between 0 and π/2. Typical transformations are
sin(15π/16)→sin(π/16),sin(x+2π/3)→cos(x+π/6).
4.Elementary trigonometric expansions. Ins o m es y s t e m s ,a u -
tomatic simpliﬁcation applies a limited form of trigonometric expansion
when the argument of a trigonometric function is a sum with an operand
of the form kπ/2w h e r ekis an integer. For example,
sin(x+π/2+y)→cos(x+y), cos(x+2π)→cos(x).
7.2. Exponential and Trigonometric Contraction 301
MPL
 Maple
 Mathematica
 MuPAD
sin(π/3)
→√
3/2
√
3/2
√
3/2
√
3/2
sin(−x)
→−sin(x)
 −sin(x)
 −Sin[x]
 −sin(x)
sin(1−x)
→−sin(x−1)
 −sin(x−1)
 Sin[1−x]
 sin(−x+1)
sin(−1+x)
→sin(−1+x)
 sin(−1+x)
 −Sin[1−x]
 sin(x−1)
sin(15 π/16)
→sin(π/16)
 sin(π/16)
 Sin[15π/16]
 sin(π/16)
sin(x+2π/3)
→cos(x+π/6)
 cos(x+π/6)
 Sin[2π/3+x]
 sin(x+2π/3)
sin(x+π/2+y)
→cos(x+y)
 cos(x+y)
 Cos[x+y]
sin(x+y+π/2)
cos(x+2π)
→cos(x)
 cos(x)
 Cos[x]
 cos(x)
sin(x)/cos(x)
→sin(x)/cos(x)
sin(x)/cos(x)
 Tan[x]
 sin(x)/cos(x)
Figure 7.9. Examples of trigonometric transformations in automatic simpliﬁ-
cation in Maple, Mathematica, and MuPAD. (Implementation: Maple(mws),
Mathematica (nb),MuPAD(mnb).)
However, for other rational multiples of π(such as sin( x+π/6)), the ex-
pansion does not occur.
5.Function transformations. The Mathematica system obtains the
following function transformations in automatic simpliﬁcation:
Sin[x]/Cos[x]→ Tan[x],
Cos[x]/Sin[x]→ Cot[x],
1/Sin[x]→ Csc[x],
1/Cos[x]→ Sec[x].
These transformation are not obtained by automatic simpliﬁcation in either
Maple or MuPAD.
Examples of trigonometric transformations in automatic simpliﬁcation
in Maple, Mathematica, and MuPAD are given in Figure 7.9.
The Simplification Algorithm. To motivate the simpliﬁcation algorithm, let’s
consider a number of examples.
302 7. Exponential and Trigonometric Transformations
Example 7.15. Consider the expression
(cos(x)+s i n (x))4+( c o s (x)−sin(x))4+c o s ( 4x)−3. (7.38)
The trigonometric contraction algorithm simpliﬁes this expression to 0.
On the other hand, the trigonometric expansion algorithm described
in Section 7.1(together with algebraic expansion) does not simplify Ex-
pression ( 7.38) to 0. These operations obtain the trigonometric-expanded
form
3c o s4(x)+6c o s2(x)sin2(x)+3s i n4(x)−3./square
Example 7.16. Consider the expression
sin(x)+s i n (y)−2s i n (x/2+y/2)cos(x/2−y/2).
Again, the contraction algorithm simpliﬁes this expression to 0. On the
other hand, trigonometric expansion gives the expanded form
sin(x)+s i n (y)−/parenleftBig
2( s i n (x/2)cos(y/2) + cos(x/2)sin(y/2))
(cos(x/2)cos(y/2) + sin(x/2)sin(y/2))/parenrightBig
. /square
These examples suggest that trigonometric contraction is a more pow-
erful simpliﬁer than trigonometric expansion. However, the next example
shows that both expansion and contraction play a role in simpliﬁcation.
Example 7.17. Consider the expression
sin3(x)+c o s3(x+π
6)−sin3(x+π
3)+3s i n ( 3x)
4. (7.39)
Although this expression simpliﬁes to 0, this is not obtained with trigono-
metric contraction, which obtains
3
4sin(x)+3
4cos/parenleftBig
x+π
6/parenrightBig
−3
4sin/parenleftBig
x+π
3/parenrightBig
.
The problem here is that the simpliﬁcation requires the trigonometric ex-
pansion of cos( x+π/6) and sin( x+π/3) and evaluation of the resulting sin
and cos functions at π/3o rπ/6. The simpliﬁcation to 0 is obtained by ﬁrst
expanding Expression ( 7.39) and then contracting the resulting expression.
/square
Example 7.18. Consider the identity
sin(x)+s i n ( 3x)+s i n ( 5x)+s i n ( 7x)
cos(x)+c o s ( 3x)+c o s ( 5x)+c o s ( 7x)=t a n ( 4x).
7.2. Exponential and Trigonometric Contraction 303
Procedure Simplify
trig(u);
Input
u:a nalgebraic expression ;
Output
either an algebraic expression in trigonometric contracted form
or the global symbol Undeﬁned ;
Local Variables
v,w,n,d;
Begin
1 v:=Trig
substitute(u);
2 w:=Rationalize
expression (v);
3 n:=Expand
trig(Numerator (w));
4 n:=Contract
trig(n);
5 d:=Expand
trig(Denominator (w));
6 d:=Contract
trig(d);
7 ifd=0then
8Return(Undeﬁned )
9 else
10Return(n/d)
End
Figure 7.10. The MPL procedure Simplify
trig. (Implementation: Maple(txt),
Mathematica (txt),MuPAD(txt).)
We verify the identity by subtracting the right side from the left side and
showing this expression simpliﬁes to 0. Our algorithm does this by replacing
tan(4x) with sin(4 x)/cos(4x), rationalizing the resulting expression, and
then contracting the numerator of the rationalized form. In this case the
numerator of the rationalized expression is
cos(4x)(sin(x)+s i n ( 3x)+s i n ( 5x)+s i n ( 7x))
−(cos(x)+c o s ( 3x)+c o s ( 5x)+c o s ( 7x))sin(4x),
which has 0 as a contracted form. /square
A procedure that obtains the simpliﬁcations in the above examples is
given in Figure 7.10. At line 1 we form a new expression by replacing the
tan, sec, cot, and csc functions with equivalent forms with sin and cos using
theTrig
substitute operator9(given in Section 5.2), and at line 2 we ratio-
9These substitutions do not occur in Mathematica because automatic simpliﬁcation
performs the inverse transformations (see footnote 2, page 187). Our implementation of
the algorithm in this system does not include the step in line 1.
304 7. Exponential and Trigonometric Transformations
nalize the resulting expression. At line 3, we trigonometrically expand the
numerator of wso that a rational multiple of πthat appears as an operand
of a sum in an argument of a sin or cos now appears directly as the argu-
ment of a sin or cos. This operation together with automatic simpliﬁcationobtains the numerical representation of some sines and cosines. (This op-
eration is required in Example 7.17.) At line 4, we contract the numerator
and in lines 5 and 6 apply expansion and contraction to the denominator.Finally, at line 7 we check if the denominator has been simpliﬁed to 0, and,
if so, return the global symbol Undeﬁned . Otherwise, we return n/d.
Appraisal of
Simplify
 trig.TheSimplify
 trigoperator can verify many trig-
onometric identities that appear in trigonometry textbooks. In this role,
it is most eﬀective by showing that the diﬀerence of the two sides of an
identity simplify to 0, as was done in Example 7.18. For expressions that
do not simplify to 0, however, it is less successful. For example, for theidentity
sin(x)+s i n ( 3x)+s i n ( 5x)+s i n ( 7x)
cos(x)+c o s ( 3x)+c o s ( 5x)+c o s ( 7x)=sin(4x)
cos(4x),
the smaller expression on the right is a simpler form than the one on the
left. However, Simplify
 trigdoes not change either side of this expres-
sion because the numerators and denominators on both sides are in con-
tracted form.
In addition, identities that require other (non-trigonometric) transfor-
mations might not be veriﬁed with Simplify
 trig. For example, although
the expression
sin2/parenleftbiggx+1
x+2/parenrightbigg
+c o s2/parenleftbigg1+1/x
1+2/x/parenrightbigg
simpliﬁes to 1, this is not obtained by our algorithm because it does not
recognize the arguments of sin and cos as equivalent expressions.
The algorithm depends, of course, on the transformations applied to
trigonometric functions during automatic simpliﬁcation. For example, both
the Maple and Mathematica implementations of the algorithm simplify
Expression ( 7.39) to 0. On the other hand, the MuPAD implementation
obtains
−sin(x−y)
2−sin(−x+y)
2
because arguments of sines that are sums are not transformed to a stan-
dard form in this system. In a similar way, both the Maple and MuPAD
implementations simplify
sin(x)+s i n ( 3x)+s i n ( 5x)+s i n ( 7x)
cos(x)+c o s ( 3x)+c o s ( 5x)+c o s ( 7x)−tan(4x)
7.2. Exponential and Trigonometric Contraction 305
to 0, while the Mathematica implementation does not because automatic
simpliﬁcation does not permit the transformation
tan(4x)→sin(4x)/cos(4x).
Exercises
1. Determine if each of the following expressions is in exponential-contracted
form. If the expression is not in exponential-contracted form, transform it
to this form.
(a)1
(1+exp( x))(1+exp( y)).
(b) exp(( x+y)(x−y)).
(c) exp(( a+b)exp(x))exp(y).
2. Analgebraic expression uis inlog-contracted form if it satisﬁes the follow-
ing two properties.
(a) A sum in uhas at most one operand that is a logarithm.
(b) A product in uthat has an operand that is a logarithm does not also
have an operand that is an integer or fraction.
For example, aln(x)+aln(y)+(ln( x))2is in log-contracted form, while
ln(x)+ln( y)+2ln( x)i sn o t .A n algebraic expression can be transformed
to log-contracted form by applying the transformations
ln(u)+ln( v)→ln(uv), (7.40)
nln(u)→ln(un), (7.41)
where nis an integer or fraction. If a product contains more than one
logarithm, ( 7.41) is applied to the ﬁrst operand that is a logarithm. Give
a procedureContract
log(u) that transforms an algebraic expression uto
log-contracted form.
3. TheContract
expalgorithmencountersadivisionby0ifthetransformation
rules transform a sub-expression in a denominator to 0. For example, this
occurs with 1 /(exp(2 x)−(exp(x))2). Modify the algorithm so that it
recognizes this situation and returns the global symbol Undeﬁned when
it occurs.
4. Let ube analgebraic expression . Give a procedure for Simplify
exp(u)
which rationalizes uand then exponentially contracts the numerator and
denominator of the resulting expression. If the denominator contracts to0, the procedure returns the global symbol Undeﬁned . Your procedure
should simplify Expression ( 7.29)t o0 .
5. Find the trigonometric-contracted form of sin( x)cos
2(x)cos(2 x).
6. Verify Equation ( 7.35)f o rneven and Equation ( 7.36)f o rneven and n
odd.
306 7. Exponential and Trigonometric Transformations
7. Let ube a power. Give a procedure Contract
trig
power(u) that does the
following.
(a) If the exponent of uis a positive integer and the base is a sine or
cosine, then contract uusing Equation ( 7.35)o rE q ua t i o n( 7.36).
The ﬂoor function is obtained in Maple and MuPAD with floorand
in Mathematica with Floor.
(b) If the exponent of uis not a positive integer or the base is not a sine
or cosine, then return u.
8. TheContract
trigalgorithm encounters a division by 0 if the transforma-
tion rules transform a sub-expression in a denominator to 0. For example,
this occurs with 1 /(sin(2x)−2sin(x)cos(x)). Modify the algorithm so
that it recognizes this situation and returns the global symbol Undeﬁned
when it occurs.
9. (a) State and derive the formulas similar to Equation ( 7.35)o rE q ua t i o n
(7.36)f o rs i n hn(θ)a n dc o s hn(θ).
(b) Modify the algorithm Contract
trigso that it also contracts the hy-
perbolic functions sinh and cosh.
Identities for sinh and cosh are given in Exercise 9, page287.
10. This exercise refers to the Trig
formoperator described in Exercise 8, page
211. Modify this procedure so that it evaluates	
sinm(ax)cosn(ax)dxby
transforming sinm(ax)c o sn(ax)to contractedform andthenapplyingthe
Integraloperator to the contracted form.
11. Each of the following expressions simpliﬁes to 0. Is this simpliﬁcation
obtained bySimplify
trig? If 0 is obtained, then explain how this is done.
If not, explain why not.
(a) tan( x/2)−(sin(x)/(1+cos( x))).
(b) sin2(15π/16)+cos2(π/16)−1.
(c) sin2(x2−1)+cos2i
1−x2J
−1.
(d) sin2W
x+1
x}
+cos2Wx2+1
x}
−1.
(e) sinQ
xQ
1+π
6xww
−√
3/2s i n (x)−1/2s i n (x).
(f) sinQi
sin2(x)+cos2(x)J
(x+π/6)w
−√
3/2s i n (x)−1/2s i n (x).
(g) 8 cos3(2π/7)+4 cos2(2π/7)−4c o s ( 2 π/7)−1.
Further Reading
SeeHobson[ 47]forotherapproachestotrigonometricexpansionandcontraction.
Gutierrez and Recio [ 42] discuss new algorithms for trigonometric simpliﬁcation
and some applications to robotics.
Bibliography
[1] Williams W. Adams and Philippe Loustaunau. An Introduction to
Gr¨obner Bases . Graduate Studies in Mathematics, Volume 3. Amer-
ican Mathematical Society, Providence, RI, 1994.
[2] Alkiviadis G. Akritas. Elements of Computer Algebra with Applica-
tions. John Wiley & Sons, New York, 1989.
[3] Michael Artin. Algebra . Prentice Hall, Inc., Englewood Cliﬀs, NJ,
1991.
[ 4 ]E .J .B a r b e a u . Polynomials . Springer-Verlag, New York, 1989.
[5] David Barton and Richard Zippel. Polynomial decomposition algo-
rithms. Journal of Symbolic Computation , 1(1):159–168, 1985.
[6] Thomas Becker, Volker Weispfenning, and Heinz Kredel. Gr¨obner
bases, A Computational Approach to Commutative Algebra . Springer-
Verlag, New York, 1993.
[7] Laurent Bernardin. A review of symbolic solvers. SIGSAM Bulletin ,
30(1):9–20, March 1996.
[8] Laurent Bernardin. A review of symbolic solvers. In Michael J.
Wester, editor, Computer Algebra Systems, A Practical Guide , pages
101–120. John Wiley & Sons, Ltd., New York, 1999.
[9] A. S. Besicovitch. On the linear independence of fractional powers of
integers. J. London Math. Soc. , 15:3–6, 1940.
307
308 Bibliography
[10] Garrett Birkhoﬀ and Saunders Mac Lane. A Survey of Modern Al-
gebra. A K Peters, Ltd., Natick, MA, 1997.
[11] E. Bond, M. Auslander, S. Grisoﬀ, R. Kenney, M. Myszewski, J. Sam-
met, R. Tobey, and S. Zilles. Formac–An experimental formula ma-
nipulation compiler. In Proc. 19th ACM National Conference , pages
K2.1–1–K2.1–11, August 1964.
[12] William E. Boyce and Richard C. DiPrima. Elementary Diﬀerential
Equations . Sixth Edition. John Wiley & Sons, New York, 1997.
[13] Manuel Bronstein. Symbolic Integration I, Transcendental Functions .
Springer-Verlag, New York, 1997.
[14] W. S. Brown. On Euclid’s algorithm and the computation of polyno-
mial greatest common divisors. Journal of the Association for Com-
puting Machinery , 18(4):478–504, October 1971.
[15] W. S. Brown. The subresultant prs algorithm. ACM Transactions
on Math. Software , 4(3):237–249, September 1978.
[16] W. S. Brown and J. F. Traub. On Euclid’s algorithm and the theory of
subresultants. Journal of the Association for Computing Machinery ,
18(4):505–514, October 1971.
[17] B. Buchberger, G. E. Collins, R. Loos, and R. Albrecht. Com-
puter Algebra, Symbolic and Algebraic Computation . Second Edition.
Springer-Verlag, New York, 1983.
[18] Bruno Buchberger. Gr¨ obner bases: An algorithmic method in poly-
nomial ideal theory. In N. K. Bose, editor, Recent Trends in Mul-
tidimensional Systems Theory , pages 184–232. D. Reidel Publishing
Company, Dordrecht, Holland, 1985.
[19] Ronald Calinger. Classics of Mathematics . Moore Publishing Com-
pany Inc., Oak Park, IL, 1982.
[20] Shang-Ching Chou. Mechanical Geometry Theorem Proving .D .R e i -
del Publishing Company, Boston, 1988.
[21] Barry A. Cipra. Do mathematicians still do math. Science , 244:769–
770, May 19, 1989.
[22] Henri Cohen. A Course in Computational Algebraic Number Theory .
Springer-Verlag, New York, 1993.
Bibliography 309
[23] J. S. Cohen, L. Haskins, and J. P. Marchand. Geometry of equilib-
rium conﬁgurations in the ising model. Journal of Statistical Physics ,
31(3):671–678, June 1983.
[24] Joel S. Cohen. Computer Algebra and Symbolic Computation: Math-
ematical Methods . A K Peters, Natick, MA, 2002.
[25] George Collins. Subresultants and reduced polynomial remainder
sequences. J. ACM , 14:128–142, January 1967.
[26] George Collins. The calculation of multivariate polynomial resul-
tants. J.ACM , 18(4):515–532, October 1971.
[27] George Collins. Computer algebra of polynomials and rational func-
tions. American Mathematical Monthly , 80(7):725–754, September
1973.
[28] Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest.
Introduction to Algorithms . McGraw-Hill, New York, 1989.
[29] J. H. Davenport, Y. Siret, and E. Tournier. Computer Algebra, Sys-
tems and Algorithms for Algebraic Computation . Academic Press,
New York, 1988.
[30] P. J. Davis and R. Hersh. The Mathematical Experience .B i r k h ¨ auser,
Boston, MA, 1981.
[31] Richard A. Dean. Classical Abstract Algebra .H a r p e ra n dR o w ,N e w
York, 1990.
[32] William R. Derrick and Stanley I. Grossman. Diﬀerential Equations
with Applications . Third Edition. West Publishing Company, St.
Paul, MN, 1987.
[33] F. Dorey and G. Whaples. Prime and composite polynomials. Journal
of Algebra , 28:88–101, 1974.
[34] H. T. Engstrom. Polynomial substitutions. A m e r .J .o fM a t h e m a t i c s ,
63:249–255, 1941.
[35] James F. Epperson. An Introduction to Numerical Methods and Anal-
ysis. John Wiley & Sons, New York, 2002.
[36] R. J. Fateman. Macsyma’s general simpliﬁer. philosophy and op-
eration. In V.E. Lewis, editor, Proceedings of MACSYMA’s Users’
Conference , Washington, D.C., June 20–22 1979, pages 563–582. MIT
Laboratory for Computer Science, Cambridge, MA, 1979.
310 Bibliography
[37] Richard J. Fateman. Symbolic mathematics system evaluators. In
M i c h a e lJ .W e s t e r ,e d i t o r , Computer Algebra Systems, A Practical
Guide, pages 255–284. John Wiley & Sons, Ltd., New York, 1999.
[38] Richard J. Gaylord, N. Kamin, Samuel, and Paul R. Wellin. An
Introduction to Programming with Mathematica, Second Edition .
Springer-Verlag, New York, 1996.
[39] K.O. Geddes, S.R. Czapor, and G. Labahn. Algorithms for Computer
Algebra . Kluwer Academic Publishers, Boston, 1992.
[40] J¨urgen Gerhard, Walter Oevel, Frank Postel, and Stefan Wehmeier.
MuPAD Tutorial, English Edition . Springer-Verlag, New York, 2000.
[41] John W. Gray. Mastering Mathematica, Programming Methods and
Applications . Second Edition. Academic Press, New York, 1997.
[42] J. Gutierrez and T. Recio. Advances on the simpliﬁcation of sine-
cosine equations. Journal of Symbolic Computation , 26(1):31–70,
July 1998.
[43] G. H. Hardy and E. M. Wright. An Introduction To The Theory of
Numbers . Oxford at The Clarendon Press, London, 1960.
[44] K. M. Heal, M. L. Hansen, and K. M. Rickard. Maple 6 Learning
Guide. Waterloo Maple Inc., Waterloo, ON, Canada, 2000.
[45] Andr´ eH e c k . Introduction to Maple . Second Edition. Springer-Verlag,
New York, 1996.
[46] I. N. Herstein. Topics in Algebra . Second Edition. Xerox Publishing
Company, Lexington, MA, 1975.
[47] E. W. Hobson. Treatise on Plane and Advanced Trigonometry .S e v -
enth Edition. Dover Publications, Inc., New York, 1957.
[48] Douglas R. Hofstadter. G¨odel, Escher, Bach: An Eternal Golden
Braid. Random House Inc., New York, 1980.
[49] David J. Jeﬀrey and Albert D. Rich. Simplifying square roots of
square roots by denesting. In Michael J. Wester, editor, Computer
Algebra Systems, A Practical Guide , pages 61–72. John Wiley & Sons,
Ltd., New York, 1999.
[50] Richard D. Jenks and Robert S. Sutor. Axiom, The Scientiﬁc Com-
putation System . Springer-Verlag, New York, 1992.
Bibliography 311
[51] N. Kajler, editor. Computer-Human Interaction in Symbolic Compu-
tation. Springer-Verlag, New York, 1998.
[52] Israel Kleiner. Field theory, from equations to axiomatization. part i.
American Mathematical Monthly , 106(7):677–684, August-September
1999.
[53] Israel Kleiner. Field theory, from equations to axiomatization. part ii.
American Mathematical Monthly , 106(9):859–863, November 1999.
[54] Morris Kline. Mathematics and The Search for Knowledge .O x f o r d
University Press, New York, 1985.
[55] D. Knuth. The Art of Computer Programming , volume 2. Second
Edition. Addison-Wesley, Reading, MA, 1981.
[56] Donald Knuth, Ronald Graham, and Oren Patashnik. Concrete
Mathematics, A Foundation For Computer Science . Addison-Wesley,
Reading, MA, 1989.
[57] K. Korsvold. An on-line algebraic simplify program. Technical report,
Stanford University, 1965. Stanford University Artiﬁcial Intelligence
Project, Memorandum 37.
[58] J. S. Kowalik, editor. Coupling Symbolic and Numerical Computing
in Expert Systems . Elsevier Science Publishers, New York, 1986.
[59] Dexter Kozen and Susan Landau. Polynomial decomposition algo-
rithms. Journal of Symbolic Computation , 7:445–456, 1989.
[60] Susan Landau. Simpliﬁcation of nested radicals. SIAM J. Comput. ,
21(1):85–110, February 1992.
[61] Ulrich Libbrecht. Chinese Mathematics in the Thirteenth Century .
MIT Press, Cambridge, MA, 1973.
[62] R. Lidl and H. Niederreiter. Introduction to Finite Fields and their
Applications . Revised Edition. Cambridge University Press, New
York, 1994.
[63] C. C. Lin and L. A. Segel. Mathematics Applied to Deterministic
Problems in the Natural Sciences . Classics in Applied Mathematics
1. Society for Industrial and Applied Mathematics, Philadelphia,
1988.
[64] John D. Lipson. Elements of Algebra and Algebraic Computing .B e n -
jamin/Cummings, Menlo Park, CA, 1981.
312 Bibliography
[65] Stephen B. Maurer and Anthony Ralston. Discrete Algorithmic
Mathematics . A K Peters, Ltd., Natick, MA, 1998.
[66] Maurice Mignotte. Mathematics for Computer Algebra . Springer-
Verlag, New York, 1991.
[67] Maurice Mignotte and Doru S ¸tef˘anescu. Polynomials, An Algorith-
mic Approach . Springer-Verlag, New York, 1999.
[68] Bhubaneswar Mishra. Algorithmic Algebra . Springer-Verlag, New
York, 1993.
[69] M. B. Monagan, K. O. Geddes, K. M. Heal, G. Labahn, S. M.
Vorkoetter, and J. McCarron. Maple 6 Programming Guide .W a -
terloo Maple Inc., Waterloo, ON, Canada, 2000.
[70] Joel Moses. Symbolic Integration . PhD thesis, MIT, September 1967.
[71] Joel Moses. Algebraic simpliﬁcation: A guide for the perplexed.
Communications of the ACM , 14(8):527–537, August 1971.
[72] George M. Murphy. Ordinary Diﬀerential Equations and Their So-
lutions . D. Van Nostrand, New York, 1960.
[73] David Musser. Algorithms for Polynomial Factorization .P h Dt h e s i s ,
Department of Computer Science, University of Wisconsin, 1971.
[74] Paul J. Nahin. An Imaginary Tale, The Story of√
−1. Princeton
University Press, Princeton, NJ, 1998.
[75] Jurg Nievergelt, J. Craig Farrar, and Edward M. Reingold. Com-
puter Approaches to Mathematical Problems . Prentice-Hall, Engle-
wood Cliﬀs, NJ, 1974.
[76] F. S. Nowlan. Objectives in the teaching college mathematics. Amer-
ican Mathematical Monthly , 57(1):73–82, February 1950.
[77] R. Pavelle, M. Rothstein, and J. P. Fitch. Computer algebra. Scien-
tiﬁc American , 245:136–152, 1981.
[78] Louis L. Pennisi. Elements of Complex Variables . Holt, Rinehart and
Winston, New York, 1963.
[79] Charles Pinter. A Book of Abstract Algebra . Second Edition.
McGraw-Hill, New York, 1990.
Bibliography 313
[80] Marcelo Polezzi. A geometrical method for ﬁnding an explicit formula
for the greatest common divisor. American Mathematical Monthly ,
104(5):445–446, May 1997.
[81] Frank Postel and Paul Zimmermann. Solving ordinary diﬀerential
equations. In Michael J. Wester, editor, Computer Algebra Systems,
A Practical Guide , pages 191–209. John Wiley & Sons, Ltd., New
York, 1999.
[82] T. W. Pratt. Programming Languages, Design and Implementation .
Second Edition. Prentice Hall, Englewood Cliﬀs, NJ, 1984.
[83] Gerhard Rayna. Reduce, Software for Algebraic Computation .
Springer-Verlag, New York, 1987.
[84] D. Richardson. Some undecidable problems involving elementary
functions of a real variable. Journal of Symbolic Logic , 33(4):511–
520, December 1968.
[85] J. F. Ritt. Prime and composite polynomials. Trans. Am. Math.
Soc., 23:51–66, 1922.
[86] P. Sconzo, A. LeSchack, and R. Tobey. Symbolic computation of f
andgseries by computer. The Astronomical Journal , 70(1329):269–
271, May 1965.
[87] George F. Simmons. Diﬀerential Equations with Applications and
Historical Notes . Second Edition. McGraw-Hill, New York, 1991.
[88] George F. Simmons. Calculus with Analytic Geometry . Second Edi-
tion. McGraw-Hill, New York, 1996.
[89] Barry Simon. Symbolic magic. In Michael J. Wester, editor, Com-
puter Algebra Systems, A Practical Guide , pages 21–24. John Wiley
& Sons, Ltd., New York, 1999.
[90] Barry Simon. Symbolic math powerhouses revisited. In Michael J.
Wester, editor, Computer Algebra Systems, A Practical Guide .J o h n
Wiley & Sons, Ltd., New York, 1999.
[91] Trevor J. Smedley. Fast methods for computation with algebraic
numbers. Research Report CS-90-12, Department of Computer Sci-ence, University of Waterloo, May 1990.
[92] Jerome Spanier and Keith B. Oldham. An Atlas of Functions .H e m i -
sphere Publishing Corporation, New York, 1987.
314 Bibliography
[93] Frederick W. Stevenson. Exploring the Real Numbers . Prentice Hall,
Upper Saddle River, NJ, 2000.
[94] David R. Stoutemyer. Crimes and misdemeanors in the com-
puter algebra trade. Notices of the American Mathematical Society ,
38(7):778–785, September 1991.
[95] R. Tobey, R. Bobrow, and S. Zilles. Automatic simpliﬁcation in
Formac. In Proc. AFIPS 1965 Fall Joint Computer Conference ,v o l -
ume 27, pages 37–52. Spartan Books, Washington, DC, November
1965. Part 1.
[96] Joachim von zur Gathen and J¨ urgen Gerhard. Modern Computer
Algebra . Cambridge University Press, New York, 1999.
[97] Paul Wang and Barry Trager. New algorithms for polynomial square
free decomposition over the integers. SIAM Journal of Comp. , 8:300–
305, 1979.
[98] Mark Allen Weiss. Data Structures and Problem Solving Using C++ .
Second Edition. Addison-Wesley, Reading, MA, 2000.
[99] Clark Weissman. Lisp 1.5 Primer . Dickenson Publishing Company,
Belmont, CA, 1967.
[100] Michael J. Wester. Computer Algebra Systems, A Practical Guide .
John Wiley & Sons, Ltd., New York, 1999.
[101] F. Winkler. Polynomial Algorithms in Computer Algebra . Springer-
Verlag, New York, 1996.
[102] Stephen Wolfram. The Mathematica Book . Fourth Edition. Cam-
bridge University Press., New York, 1999.
[103] D. Wooldridge. An algebraic simplify program in Lisp. Technical
report, Stanford University, December 1965. Artiﬁcial Intelligence
Project, Memo 11.
[104] W. A. Wulf, M. Shaw, P. Hilﬁnger, and L. Flon. Fundamental Struc-
tures of Computer Science . Addison-Wesley, Reading, MA, 1981.
[105] Chee Keng Yap. Fundamental Problems of Algorithmic Algebra .O x -
ford University Press, New York, 2000.
[106] David Y. Y. Yun. On square-free decomposition algorithms. In R. D.
Jenks, Proceedings of the 1976 ACM Symposium of Symbolic and
Algebraic Computation , pages 26–35. ACM, New York, 1976.
Bibliography 315
[107] David Y. Y. Yun and David R. Stoutemyer. Symbolic mathematical
computation. In J. Belzer, A.G. Holzman, and A. Kent, editors,
Encyclopedia of Computer Science and Technology , volume 15, pages
235–310. M. Dekker, New York, 1980.
[108] Richard Zippel. Eﬀective Polynomial Computation .K l u w e r A c a -
demic Publishers, Boston, 1993.
[109] Daniel Zwillinger. Handbook of Diﬀerential Equations .A c a d e m i c
Press, Boston, MA, 1989.
Index
Absolute
value(u),34,123,199
Actual parameters
for a procedure, 134
of a function, 133
Adjoin(x,L),72
Akritas, A., 26
Algebraic expression
conventional structure, 84
expanded form, 251
exponential-contracted
form,289
exponential-expanded
form,276,286
log-contracted form, 305
log-expanded form, 286
simpliﬁed structure, 93
trigonometric-contracted
form,293
trigonometric-expanded
form,281,287
Algebraic
expand(u),34,253,259
Algebraic
expression (u),194
Assignment, 38
Atomic expression, 81
Automatic simpliﬁcation, 52
context of, 54
Automatically simpliﬁed algebraic
expression ( ASAE),93Automatic
simplify(u),83
Axiom,6
base(u),272
Bernardin, L., 27
Bernoulli(u,x,y),242
Bilinear
form(u,x,y),237
Buchberger, B., 26
By
parts(f,x),212
CAIN (Computer Algebra
Information Network), 26
Cancel(u),273
CAS,2
Chou, S.C., 27
Cipra, B.A., 27
Coeﬃcient (u, x, j),34,64
Coeﬃcient
alternate(u,x,j),239
Coeﬃcient
gpe(u,x,j),230,233
Coeﬃcient
list(u,x),223
Coeﬃcient
 monomial
 gpe
(u,x),232
Coeﬃcient
monomial
sv(u,x),222
Coeﬃcient
sv(u,x,j),218,222
Coeﬃcient
vars(u,L),,247
Coeﬀ
var
monomial (u,S),237
Cohen, Joel S., 10
Collect
terms(u,S),248,249
Collect
terms
2(u,S),257
Comb(S,k),196
316
Index 317
Combine(u),257
Common
factors(u,v),272
Complete sub-expression, 109
Complete
sub
expressions (u),177
Compound expression, 81
Computer algebra, 2
Computer algebra language, 5
Computer algebra system (CAS), 2
commercial, 6
mathematical knowledge in, 8
COMPUTER ALGEBRA,
Algorithms, Systems
and Applications, 26
Concurrent structural
substitution, 115
Concurrent
substitute (u,S),115,195
Contain
parameters (u,x),194
Contract
exp(u),290,305
Contract
exp
rules(u),291
Contract
log(u),305
Contract
trig(u),296,306
Contract
trig
power(u),306
Contract
trig
rules(u),297
Curvature (f,x),150
Czapor, S.R., 26
Data objects, 39
logical expressions, 54
Davenport, J.H., 26
Decimal(u),34,123
Decision structures, 141
Default simpliﬁcation, 52
deg(u,S),230
deg(u,x),214,230
Degree
of a GME, 229
of a GPE, 230
Degree(u,x),34,63
Degree
alternate(u,x),239
Degree
general(u,x),239
Degree
gpe(u,v),238
Degree
monomial
gpe(u,v),238
Degree
monomial
sv(u,x),219
Degree
sv(u,x),217,220
Delete(x,L),73
Denominator (u),123,260,270Denominator (u,L),271
Derivative (u,x),34,182,196
Derivative
order(u,x,y),197
Derive,6
Diﬀerential equation
Bernoulli, 241
exact,157
homogeneous, 168
homogeneous second order, 169
integrating factor, 157
separable, 157
singular solution, 166
variation of parameters, 169
Diﬀerentiation
of factorials, 196
of undeﬁned functions, 196
Distance
point
line(u,x,y,p),151
Distribute (u),258
Eﬀective step in an algorithm, 120
Evaluate(u,n),50
Evaluation
in Maple, 52
in Mathematica, 52
in MuPAD, 52
multi-level, 50
single level, 50
suppressed, 50
Even
odd(u,x),144
Expand
exp(u),279,280,286
Expand
exp
rules(A),279,280,286
Expand
log(u),286
Expand
main
op,258
Expand
power(u,n),254,259
Expand
product(r,s),253
Expand
restricted(u,T),258
Expand
tan(u),288
Expand
trig(u),283,287
Expand
trig
rules(u),283,287
Expd
exp(u),278
exponent( u),272
Exponential contraction, 276,289
Exponential expansion, 276
Expression
main operator, 87
root node of tree, 87
318 Index
structure, 84
tree,87
branch,87
evaluation, 49
FandGseries,155
Factor(u),34
Fateman, R. J., 75
FG(n,t),156
Fibonacci numbers
recursive deﬁnition, 175
Find
min
deg(S,x),151
First(L),72
Fitch, J.P., 26
Floor function, 257,306
FORMAC computer algebra
system,155
Formal parameters
in MPL,140
of a function, 133
of a procedure, 133
Fraction ( fraction),92
Free
of(u,t),110,179,194
mathematical properties
of,242
Free
of
sort(S),246
Geddes, K.O., 26
General monomial expression
(GME)
coeﬃcient part, 224
computational deﬁnition, 225
mathematical deﬁnition, 224
variable part, 224
General polynomial expression
(GPE)
collected form, 248
computational deﬁnition, 225
degree of, 229
mathematical deﬁnition, 224
General rational expression (GRE)
computational deﬁnition, 261
mathematical deﬁnition, 259
Generalized coeﬃcients, 224
Generalized variables, 224
Gerhard, J., 26Global symbol, 137
GPE
to
mult(u),246
Haskins, L., 10
Heck, A., 7
Homogeneous
polynomial, 238
Homogeneous (M,N,x,y ),169
Homogeneous
 2(a,b,c,x),169
Homogeneous
 polynomial
(u,x,y),238
Horner(u,x),195
Identiﬁer
as a mathematical symbol or
variable,32
as a programming variable, 32
in MPL,32
ifstructure, 141
if-elsestructure, 142
Implicit
derivative (u,y,x,n),197
Inﬁnite recursive loop, 175
Integer ( integer),104
Integer
gcd(a,b),122
Integral
linear properties, 200
Integral(f,x),34,206
Integral
table(f,x),209
Integration
derivative divides method, 203
substitution method, 200
table,200
Iquot(a,b),122
Irem(a,b),122
Irrational numbers
in MPL,32
Iteration structures, 145
Iter
fact(n),79
Jenks, R.D., 6
Join(L,M,...,N ),72
Kajler, N., 27
Kind(u),104
Index 319
Kline, M., 26
Kowalik, J.S., 27
Labahn, G., 26
Lagrange
polynomial (P,x),153
lc(u,x),214,233
Leading
coeﬀ
degree
gpe
(u,x),238
Leading
Coeﬃcient
gpe(u,x),234,238
Leading
coeﬃcient
monomial
sv
(u,x),222
Leading
coeﬃcient
sv(u,x),220,222
Leading
numer
coeﬀ
(u,L),246
Legendre (n,x),191
Legendre polynomials, 189
iterative algorithm, 192
Limit(u,x,a),34
Lin, C.C., 10
Line(u,x,y),153
Linear diﬀerential
operator, 240
Linear
derivative
order
(u,x,y),240
Linear
factors(u,x),151
Linear
form(u,x),181
Linear
properties (f,x),209
Lipson, J.D., 26
List (list),100
Lists,71
empty list([ ]), 71
mathematical properties, 71
primitive operations, 72
use in MPL, 71
membership( ∈),73
Local environment of a procedure,
134
Local variables in a procedure, 134
low
deg(u,x),236
Macsyma, 7,21,55,256
Maple,3,4,6,7,14–16,44,54,127,
129,130,145,193,246,267,
277,287
improperlyposedexpressions, 127
list operations, 73set operations, 70
MPL reserved operators, 35
MPL reserved symbols, 33
Map(F,u),188
Map(G,u,y,...,z ),188
Marchand, J.P., 10
Mathematica, 7,12,40,46,54,94,
95,113,130,145,240,246,256,
276
list operations, 73
set operations, 70
diﬀerential equations, 36
MPL operators, 35
MPL reserved symbols, 33
Mathematical algorithm, 119
Mathematical operators
procedures for, 133
Mathematical pseudo-language
(MPL),29
Max(S),198
Max
exponent(u,x),198
Mignotte, M., 26
Mishra, B., 26
Monomial
gpe(u,v),226,227
Monomial
sv(u,x),215,217,218
MPL
general form of a
function, 133
general form of a
procedure, 135
mathematical algorithm, 58
operators
algebraic, 32
logical,36
relational, 36
reserved symbols
e,33
∅,70
false,33
ı,33
∞,33
π,33
true,33
Multi-branch structure, 142
MuPAD,7,18,47,54,145,267,277,
287
320 Index
list operations, 73
MPL reserved operators, 35
MPL reserved symbols, 33
set operations, 70
Normal simpliﬁcation operator, 269
Number
of
operands(u),105
Numerator
simpliﬁcation context, 130
Numerator (u),123,260,270
Numerator (u,L),271
Numerical (u),195
Numerical expression, 195
Numerical
coeﬃcient (u),152
Operand(u,i),34,43,105
Operand
list(u),151
Operator
binary inﬁx, 85
function postﬁx, 85
n-ary inﬁx, 85
structure based, 108
unary postﬁx, 85
unary preﬁx, 85
Operator evaluation
and automatic simpliﬁcation of
arguments, 54
Parentheses level
diﬀerent, 85
same,85
Pavelle, R., 26
Perpendicular
 line(u,x,y,p),150
Polynomial
degree,214
height,221
leading coeﬃcient, 214
multivariate
mathematical
deﬁnition, 221
single variable
computational
deﬁnition, 215
mathematical deﬁnition, 214
Polynomial sign, 247
Polynomial
gpe(u,v),226,228Polynomial
height(u,x),221
Polynomial
mv(u,S),222
Polynomial
sign(u,L),247
Polynomial
sign
var(u),247
Polynomial
sq2(u,x),222
Polynomial
sv(u,x),215,218
Polynomial
sv
unexp(u,x),222
Polynomial
xy(u,x,y),222
Power set, 196
Power
set(S),196
Precedence rules
conventional
algebraic expressions, 86
simpliﬁed
algebraic expressions, 93
Primitive operations
general polynomial
expressions, 225
simpliﬁed mathematical
expressions, 104
single variable
polynomials, 215
Procedure
body of,134
iterative, 79
Properly posed operation, 126
Quadratic
form(u,x),195
Radical
form(f,x),210
Rational number arithmetic, 31
Rational simpliﬁcation, 270,271
Rational-expanded form, 268,270
Rational
expand(u),270
Rational
form(f,x),210
Rational
gre(u,v),261,270
Rationalization of algebraic
expressions, 262
Rationalized form
of an algebraic expression, 263
Rationalize
expression (u),265
Rationalize
sum(u,v),265
Rational
simplify(u),123
Rational
sv(u,x),223
Rational
variables(u),262,270
Rayna, G., 7
Index 321
real,31
Real ( real),104
Rec
fact(n),80,172
Recurrence relation, 190
Recursion
redundant, 183,193,226,256,266,
277,282
Recursion in mathematics, 82
Recursive chain, 193
Recursivedeﬁnitionoralgorithm, 77
Recursive procedure, 80,172
Recursivestructureofmathematical
expressions, 80
Reduce,7
Remembering procedure calls
in Maple, 193
Remove
duplicates (L),151
Rest(L),72
Return(u),135
Reverse(L),73
Richardson, D., 145
Rothstein, M., 26
Rule-based programming
in Maple, 185
in Mathematica, 184
sci.math.symbolicdiscussionsite, 26
Segel, L.A., 10
Semantic capacity, 126
Separable
ode(M,N,x,y ),168
Separate
factors(u,x),148
Separate
sin
cos(u),152
Separate
variables(u,x,y),152
Sequential structural
substitution, 114
Sequential
substitute (u,L),114,195
Set (set),100
Set
free
of(u,S),180,194
Set
product(A,B),151
Sets,69
diﬀerence ( ∼),69
empty set ( ∅),70
intersection ( ∩),69
mathematical properties, 69
union ( ∪),69use in MPL, 69
membership ( ∈),70
SIGSAM(SpecialInterestGroupon
Symbolic and Algebraic
Manipulation), 26
Simpliﬁcation context, 128
Simpliﬁed structure
of algebraic expressions, 90
of diﬀerences, 90
of fractions, 92
of lists,100
of logical expressions, 97
of products, 90
of quotients, 92
of relational expressions, 96
of set expressions, 100
of sums,90
Simplify
exp(u),305
Siret, Y., 26
Solve(u,x),34
Solve
ode(w,x,y),34,161,162
Solve
ode
2(a,b,c,f,x,y ),170
Solve
quadratic(u,x),151
Solve
exact(M,N,x,y ),163
Stack,174
S¸tef˘anescu, D., 26
Stoutemyer, D.R., 26
Structural assumptions for conven-
tional algebraic expressions, 86
Structural assumptions for
simpliﬁed algebraic
expressions, 90
Structural substitution
multiple, 114
Substitute (u,t=r),34,111
Substitute (u,v),195
Substitution
and evaluation, 112
structural, 111
Substitution
 method(f,x),206
Sutor, R.S., 6
Symbol ( symbol),104
Symbol manipulation, 2
Symbol manipulation system, 2
Symbolic programming language, 5
322 Index
SymbolicNet, 26
Symbols(u),194
Symmetric (u,x,y),151
Tangent
line(f,x,a),136
Taylor
2(u,x,y,a,b,n ),153
Taylor
ode(w,x,y,a,b,n ),155
Termination condition
in a recursive procedure, 172
in a recursive
procedure, 80
Total
degree(u),238
Tournier, E., 26
Transformation rule sequence, 182
rule convention, 184
Transformation rules
CF(Common
factors
(u,v)),272
FO(Factor
out(u)),272
GMEALT (alternate general
monomial expression), 238
GME(general monomial
expression), 225
GPE(general polynomial
expression), 225
ND(Numerator (u),
Denominator (u)),260
DERIV(Derivative
(u,x)),182
LNC(Leading
numer
coeﬀ
(u,L)),246
MON(singlevariablemonomial),
215
NUM(Numerical (u)),195POLY(singlevariablepolynomial),
215
TRIGSUB (Trig
substitute
(u)),186
VAR(Variables(u)),227
Transform
ode(w,x,y),162,240
Transform
ode
2(w,x,y),241
Tree-size of an expression, 195
Tree
size(u),195
Trial
substitutions (f),209
Trig
form(f,x),211,306
Trig
free
of(u),194
Trigonometric contraction, 293
Trigonometric expansion, 281
Trig
substitute (u),187,303
Trig
substitute
 map(u),190
Unassign(u),52
Variable evaluation, 50
Variables(u),227,237
Variation
of
param
(y1,y2,f,a,x),170
von zur Gathen, J., 26
Wester, M., 7,26
Winkler, F., 26
Wolfram, S., 7
Yap, C.K., 26
Yun, D.Y.Y., 26
Zero equivalence operator, 269
Zero equivalence problem, 145
Zippel, R., 26

A K
PETERS Computer Algebra and Symbolic ComputationCohenElementary Algorithms
A K Peters, Ltd.ISBN 1-56881-158-6Computer Algebra and
Symbolic Computation
Elementary AlgorithmsJOEL S. COHEN
The author explores the structure and implementation of computer
algebra algorithms as well as the mathematical and computationalconcepts behind them.
This book:
•Is accessible to students and appeals to professionals
•Introduces mathematical concepts as needed
•Contains a CD with the entire text, active reference hyperlinks,
and complete algorithms
Computer Algebra and Symbolic Computation  bridges the gap
between software manuals, which only explain how to use computeralgebra programs such as Mathematica, Maple, Derive , etc., and
graduate level texts, which only describe algorithms.
For a more advanced look at computer algebra, including the
application of algorithms to methods such as automatic simplification,polynomial decomposition, and polynomial factorization, see Computer
Algebra and Symbolic Computation: Mathematical Methods.
